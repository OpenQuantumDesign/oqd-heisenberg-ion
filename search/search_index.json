{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"Docs","text":"<p>Note</p> <p>Heisenberg Ion is still under active development so breaking changes are possible. See Features in Development for details.</p>"},{"location":"#introduction","title":"Introduction","text":"<p>Welcome to Heisenberg Ion, our open source quantum many-body physics simulator targeting lattice systems that can be natively realized in trapped ion architectures. We currently support Exact Diagonalization (ED) and Quantum Monte Carlo (QMC) Stochastic Series Expansion (SSE) engines for long range anisotropic Heisenberg models in the presence of external fields. </p> <p>While Heisenberg Ion is primarily a python package, it uses a C++ engine for large-scale QMC simulations.  Our ED calculator uses a Julia backend.  Both of these simulators are wrapped in a lightweight Python preprocessor responsible for driving the required engine.  </p>"},{"location":"#dependencies","title":"Dependencies","text":""},{"location":"#runtime-dependencies","title":"Runtime Dependencies","text":"<ul> <li>Python 3.10+  </li> <li>Julia 1.12+   </li> <li>CMake 3.12+  </li> <li>Clang 17+ or GCC 14+ (C++ Compiler)  CMake and a C++ compiler are required for building the long range QMC source code </li> </ul>"},{"location":"#python-packages","title":"Python Packages","text":"<p>This package also requires a number of Python libraries: - Numpy - Scipy - Matplotlib These are installed automatically by pip as part of the Heisenberg Ion package install</p>"},{"location":"#c-dependencies","title":"C++ Dependencies","text":"<ul> <li>spdlog  This is fetched and compiled automatically by CMake while building the C++ source if required</li> </ul>"},{"location":"#getting-started","title":"Getting Started","text":"<p>To use this package, first clone the Heisenberg Ion repository: <pre><code>git clone https://github.com/OpenQuantumDesign/oqd-heisenberg-ion.git\n</code></pre></p> <p>Then, install the package: <pre><code>pip install oqd-heisenberg-ion\n</code></pre></p>"},{"location":"#documentation","title":"Documentation","text":"<p>Documentation is developed using MkDocs. To install documentation-related dependencies, use:</p> <pre><code>pip install -e \".[docs]\n</code></pre> <p>See the User Guide and the example files in the repository for user-level documentation. A description of the SSE algorithm used in this package can be found in the Algorithms section. </p>"},{"location":"feat_dev/","title":"Features in Development","text":"<ul> <li> Use pydantic for input parsing and validation</li> <li> Switch to .hdf5 output format for shot data from QMC engines</li> <li> Add support for \\(2d\\) geometries</li> <li> Use JSON for passing parameters to long range QMC and ED engines</li> </ul>"},{"location":"algorithms/ed/","title":"Exact Diagonalization","text":"<p>In this section, we discuss how we can leverage the sparsity of the Hamiltonian to optimize the construction of the Hamiltonian matrix. To this end, consider the \\(1d\\) long-range XY model:</p> \\[ H = -J \\sum_{i &lt; j} J_{i,j} \\left( S_i^x S_j^x + S_i^y S_j^y \\right) = -\\frac{J}{2} \\sum_{i &lt; j} J_{i,j} \\left( S_i^+ S_j^- + S_i^- S_j^+ \\right) \\] <p>For our ED calculator, to be able to compute the superfluid density, we also consider a boundary phase twist. This yields the following Hamiltonian: </p> \\[ H = -\\frac{J}{2} \\sum_{i=1}^{N} \\sum_{r=1}^{(N-1)/2} J_{i,j} \\left( e^{r \\theta} S_i^+ S_{i+r}^- + e^{-r \\theta} S_i^- S_{i+r}^+ \\right) \\] <p>Here, we have restricted ourselves to the case of odd \\(N\\) for simplicity. The case for even \\(N\\) can be constructed analogously. Moreover, the above form can be obtained for open as well as periodic boundaries in the presence of long range interactions. However, a boundary phase twist would not necessarily be well-defined with open boundaries in the context of superfluidity. </p> <p>Note that the dimensions of the associated matrix are \\(2^N \\times 2^N\\). However, for a given product state (row of the matrix) in the \\(S_z\\) basis (which is the representation we will use), only \\(\\mathcal{O}(N^2)\\) terms have a non-zero overlap. We can use this to prevent iterating over \\(2^N\\) bitstrings twice (once for columns and once for rows, as would be required for a dense matrix). </p> <p>In practice, this can be done by iterating over all the \\(2^N\\) columns (hence the exponential scaling with system size). Each column number \\(k\\) admits a binary representation with \\(N\\) bits. Therefore, we can identify \\(k \\rightarrow |\\sigma_1,...,\\sigma_N \\rangle\\). Then, because our off-diagonal terms correspond to flipping a pair of opposite spins, we only get a non-zero matrix element if the row \\(l \\rightarrow |\\gamma_1,...,\\gamma_N \\rangle\\) is such that \\(\\gamma_t = \\sigma_t\\) for all \\(t \\in \\{1,...,N\\}\\) except for a single pair of indices, \\(t_1, t_2 \\in \\{1,...,N\\}\\) with \\(\\sigma_{t_1} \\neq \\sigma_{t_2}\\). </p> <p>To isolate all rows with a non-zero overlap, given a column, we can use bit-wise operations. We proceed by iterating over all sites \\(i\\) and all distances \\(r\\) in the lattice. This allows us to construct all pairs of sites \\((i,j)\\). Then, representing the column number \\(k\\) in binary, we can isolate the bits in \\(k\\) corresponding to sites \\(i\\) and \\(j\\) via a bitwise arithmetic shift to the right by \\(i\\) and \\(j\\) respectively. If the resulting bits \\(\\sigma_i, \\sigma_j\\) are opposite relative to one another, the XY term contributes a non-zero element. The following code block exhibits this construction: </p> <pre><code>\u03c3i = (k &gt;&gt; i) &amp; 1\n\u03c3j = (k &gt;&gt; j) &amp; 1\nmask = (\u03c3i == \u03c3j) ? 0 : 1\nnon_zero_element = -0.5 * J * mask * exp((\u03c3j - \u03c3i) * r * theta * 1im)\n</code></pre> <p>The first two lines in the above block isolate the bits \\(\\sigma_i, \\sigma_j\\) by performing a bitwise AND operation with \\(1\\) after the shift discussed above. The <code>mask</code> determines if the spins are flipped relative to each other. The row number associated with this matrix element can also be determined via bitwise operations similarly. Representing the column number \\(k\\) as a bitstring, the corresponding row number bitstring can be obtained by performing a bitwise XOR operation with the bitstrings \\([2^i]\\) and \\([2^j]\\). These strings have a \\(1\\) at location \\(i\\) and \\(j\\) respectively, and \\(0\\) at all other \\(N-1\\) locations. The row number \\(b\\) can be obtained in Julia via the following code using this approach: </p> <pre><code>b = k \u22bb 2^i \u22bb 2^j\n</code></pre> <p>The bitstring associated with \\(b\\) now is the same bitstring as \\(k\\) except for the \\(i\\) and \\(j\\) positions which are flipped relative to the bitstring corresponding to \\(k\\). To construct the diagonal entries, we can similarly use bitwise operations to map bits to the eigenvalues of \\(S_z\\). Since those are diagonal, no row index needs to be constructed to record those in the Hamiltonian. Diagonalization of the resulting Hamiltonian is done via the native LinearAlgebra library in Julia. </p>"},{"location":"algorithms/refs/","title":"References","text":""},{"location":"algorithms/refs/#directed-loop-quantum-monte-carlo","title":"Directed Loop Quantum Monte Carlo","text":"<pre><code>@article{PhysRevE.66.046701,\n  title = {Quantum Monte Carlo with directed loops},\n  author = {Sylju\\aa{}sen, Olav F. and Sandvik, Anders W.},\n  journal = {Phys. Rev. E},\n  volume = {66},\n  issue = {4},\n  pages = {046701},\n  numpages = {28},\n  year = {2002},\n  month = {Oct},\n  publisher = {American Physical Society},\n  doi = {10.1103/PhysRevE.66.046701},\n  url = {https://link.aps.org/doi/10.1103/PhysRevE.66.046701}\n}\n</code></pre>"},{"location":"algorithms/refs/#two-step-scheme-for-diagonal-updates","title":"Two Step Scheme For Diagonal Updates","text":"<pre><code>@Article{ejaaz2024sse,\n    title={{Stochastic series expansion quantum Monte Carlo for Rydberg arrays}},\n    author={Ejaaz Merali and Isaac J. S. De Vlugt and Roger G. Melko},\n    journal={SciPost Phys. Core},\n    volume={7},\n    pages={016},\n    year={2024},\n    publisher={SciPost},\n    doi={10.21468/SciPostPhysCore.7.2.016},\n    url={https://scipost.org/10.21468/SciPostPhysCore.7.2.016},\n}\n</code></pre>"},{"location":"algorithms/refs/#stochastic-series-expansion-review","title":"Stochastic Series Expansion Review","text":"<pre><code>@article{Sandvik2010Review,\n    author = {Sandvik, Anders W.},\n    title = {Computational Studies of Quantum Spin Systems},\n    journal = {AIP Conference Proceedings},\n    volume = {1297},\n    number = {1},\n    pages = {135-338},\n    year = {2010},\n    month = {11},\n    issn = {0094-243X},\n    doi = {10.1063/1.3518900},\n    url = {https://doi.org/10.1063/1.3518900}\n}\n</code></pre>"},{"location":"algorithms/sse/","title":"Stochastic Series Expansion","text":"<p>In this section, we provide a brief overview of the SSE algorithm. To this end, first consider the canonical ensemble partition function \\(Z\\): </p> \\[ Z = \\text{Tr} (e^{-\\beta H}), \\ \\ \\ \\rho = e^{-\\beta H} \\] <p>where \\(\\beta = 1/T\\) is the reciperocal temperature, \\(H\\) is the Hamiltonian, and we \\(\\rho\\) is the imaginary time propagator. In statitical mechanics, we are interested in equilibrium properties which can be evaluated via the usual approach:</p> \\[ \\langle O \\rangle = \\frac{1}{Z} \\text{Tr} (O e^{-\\beta H})  \\label{estiamtor_qmc} \\] <p>where \\(O\\) is the operator representing the observable property of interest. QMC, in general, involves mapping the \\(d\\) dimensional quantum problem to a \\(d+1\\) dimensional classical problem and then constructing a Markov chain to statistically evaluate expection values. For SSE, this is done by Taylor expanding the propagator:</p> \\[ Z = \\sum_{\\sigma} \\sum_{n=0}^{\\infty} \\frac{(-\\beta)^n}{n!} \\langle \\sigma|H|\\sigma\\rangle  \\label{taylor_rho_Z} \\] <p>Here, we have resolved the trace in \\(S_z\\) basis and \\(\\sigma = (\\sigma_1, ..., \\sigma_N)\\) with \\(\\sigma_i \\in \\{1,-1\\} \\ \\forall \\ i \\in \\{1,...,N\\}\\). Here, \\(N\\) is the total number of sites in the lattice. Now, for the sake of brevity, we restrict ourselves to the long-range \\(XY\\) model with power-law interactions:</p> \\[ H = - J \\sum_{i &lt; j} \\frac{1}{r_{ij}^\\alpha} \\left( S_i^x S_j^x + S_i^y S_j^y \\right) = - J \\sum_{b=1}^{N_b} \\left(H_{1.b} + H_{2,b} \\right) + JC \\] <p>Here, \\(b\\) denotes a single bond in the lattice and \\(N_b\\) represents the total number of bonds. The terms \\(H_{1,b}\\) and \\(H_{2,b}\\) are given by: </p> \\[ H_{1,b} = \\frac{1}{2r_b^\\alpha}, \\ \\ \\ H_{2,b} = \\frac{1}{2r_b^\\alpha} \\left(S_{i(b)}^+ S_{j(b)}^- + S_{i(b)}^- S_{j(b)}^+ \\right) \\] <p>The constant offset \\(JC = \\sum_b \\frac{J}{2 r_b^\\alpha}\\) only shifts the spectrum so it can be ignored and added back to the energy at the end of the calculation. We can express each term in the Taylor expansion of the propagator above as a sum over all permutations (the order of the permutation group being determined by the order of the expansion). Then, we can impose a cutoff \\(n_{max} = M\\) on the expansion order and combinatorially re-arrange terms to get:</p> \\[ Z = \\sum_{\\{\\sigma\\}, S_M} \\frac{(J \\beta)^n (M-n)!}{M!} \\prod_{k=1}^{M} \\langle \\sigma_k | H_{a_k, b_k} | \\sigma_{k+1} \\rangle \\] <p>In the above equation, \\(S_M = \\{(a_1,b_1),...,(a_M,b_M)\\}\\) with \\(a_k \\in \\{0,1,2\\}\\) and \\(b_k \\in \\{1,...,N_b\\}\\). The operator string has been padded with identity operators wherever needed by introducing the notation \\(H_{0,b} = I\\). Finally, we have also inserted \\(M-1\\) resolutions of identity in the \\(S_z\\) basis between each of the \\(M\\) operators. The Taylor expansion and the insertion of identities effectively maps this to a classical theory in \\((d+1)\\) dimensions. Note that for each \\(k\\), the many body indices \\(\\sigma_k\\) and \\(\\sigma_{k+1}\\) can either be the same or differ by a single flipped pair of spins in our construction. </p> <p>As with all QMC approaches, we treat the above sum as a set of classical configurations and use transition schemes (called moves) to propagate the system through the resulting state space. To ensure that the corresponding Markov chain converges to the desired distribution, these moves must satisfy detailed balance. In the SSE algorithm, we employ two types of moves: the diagonal transitions and the off-diagonal loop updates. </p>"},{"location":"algorithms/sse/#diagonal-updates","title":"Diagonal Updates","text":"<p>The diagonal update allows us to vary the expansion order \\(n\\) via insertions and removals of diagonal operators \\(H_{1,b}\\) in the operator string. This can be done using the heatbath scheme, which allows us to pre-compute the probability tables and index them in the QMC update implementation efficiently so that the probabilities do not have to be evaluated on the fly. In particular for the long range XY model with power-law interactions, it can be shown that the transition probabilities are given by: </p> \\[  P(n \\rightarrow n+1) = \\text{min} \\left(1, \\frac{\\beta C}{M-n} \\right) \\] \\[ P(n+1 \\rightarrow n) = \\text{min} \\left(1, \\frac{M-n+1}{\\beta C} \\right) \\] <p>After an insertion update has been accepted for a particular time-slice \\(n\\), the bond is determined by Gibbs sampling the discrete distribution defined by: \\(P(b) = 1/2r_b^\\alpha\\). </p>"},{"location":"algorithms/sse/#off-diagonal-updates","title":"Off-Diagonal Updates","text":"<p>The off-diagonal updates correspond to replacing non-identity diagonal operators with off-diagonal ones (\\(H_{2,b}\\)) probabilistically. This is done using the directed loop technique. In practice, this corresponds to mapping each matrix element in the operator list above, to a set of four vertex leg variables. Each leg denotes a classical spin with value \\(\\sigma_l \\in \\{-1,1\\}\\). We then construct a loop in the \\((d+1)\\) configuration space by entering a vertex at one of its legs and exiting at another leg. This process flips both the entrance and exit legs, leaving the other two leg variables intact. </p> <p>We continue traversing the state space after exiting a vertex by moving our pointer to the next time-slice on the same site index with a non-identity operator. This new leg now becomes the entrance leg and same transition approach can be used again until the loop closes. The exit leg, given an entrance leg at each step is determined probabilistically. These probabilities, in general, depend on the model under question. Two common approaches for computing these probabilities are: the heatbath scheme and the directed loop scheme. Typically, the directed loop technique offers a more ergodic traversal of the state space by minimizing bounces (exit leg being the same as the entrance leg). In practice, these off-diagonal update schemes can be implemented efficiently using a linked list data structure, which is the approach used by the Heisenberg Ion package. </p> <p>For certain models such as the XY model, bounces can be entirely excluded, and it can be shown that the entire \\((d+1)\\) dimensional state space can be sub-divided into loops. Moreover, these loops can then be flipped independently with a probability of \\(1/2\\) while respecting detailed balance. This approach is what we refer to as the deterministic algorithm in Heisenberg Ion package. In general, a set of transition probabilities is valid if it satisfies the detailed balance requirement defined by the following:</p> \\[  P(s \\rightarrow s') W(s) = P(s' \\rightarrow s) W(s')  \\] <p>Here, \\(s\\) and \\(s'\\) are some arbitrary configurations of the entire state space with weights \\(W(s)\\) and \\(W(s')\\) respectively, and \\(P(s \\rightarrow s')\\) is the transition probability between those configurations. Both the heatbath and the directed loop schemes satisfy this requirement. </p>"},{"location":"algorithms/sse/#estimators","title":"Estimators","text":"<p>SSE offers a variety of convenient estimators for common observable quantities of interest, such as the energy and spin stiffness. The equilibrium energy can be computed using the thermodynamic estimator: </p> \\[  E = -\\frac{1}{Z} \\frac{\\partial Z}{\\partial \\beta} \\] <p>Using the Taylor expansion form for \\(Z\\) given by Eq. \\(\\eqref{taylor_rho_Z}\\), we get the following estimator for the thermodynamic energy:</p> \\[  E = \\frac{1}{Z} \\sum_{\\sigma} \\sum_{n=0}^{\\infty} \\left( \\frac{-n}{\\beta} \\right) \\frac{(-\\beta)^n}{n!} \\langle \\sigma|H|\\sigma\\rangle = - \\frac{\\langle n \\rangle}{\\beta} \\] <p>The magnetization, defined by \\(M_z = \\frac{1}{N}\\sum_{i=1}^{N} \\sigma_z^i\\) can be computed directly using Eq. \\(\\eqref{estiamtor_qmc}\\): </p> \\[ \\langle M_z \\rangle = \\frac{1}{N} \\langle N_{0} - N_{1} \\rangle \\] <p>where \\(N_0\\) is the number of spins in the lattice with \\(\\sigma = 1\\) and \\(N_1\\) is the number of spins in the lattice with \\(\\sigma = -1\\) at each simulation step for the first time-slice. Since the trace yields periodic boundaries in imaginary time, we could also average this estimator over all time-slices. </p> <p>The spin stiffnes is defined as the free energy response to a boundary phase twist \\(\\theta\\). The corresponding phase twist Hamiltonian is defined by: </p> \\[ H(\\theta) = -\\frac{J}{2} \\sum_{i=0}^{N-1} \\sum_{r=1}^{(N-1)/2} \\frac{1}{r_b^\\alpha} \\left( e^{-i r \\theta} S_i^{+} S_{i+r}^{-} + e^{i r \\theta} S_{i}^{-} S_{i+r}^{+} \\right) \\] <p>Note that we have assumed periodic boundaries here since a boundary phase twist would not necessarily be well-defined in the presence of open boundary conditions. The spin stiffness is then given by: </p> \\[  \\rho_s = \\frac{1}{N}\\frac{\\partial^2 F}{\\partial \\theta^2} \\Biggr|_{\\theta = 0} \\] <p>In general, this stiffness can be related to the winding number \\(W\\) as follows: </p> \\[ \\rho_s = \\frac{1}{\\beta N^{2-d}} \\langle W^2 \\rangle \\] <p>The winding number has a very convenient estimator in SSE. It is given by accumulating the off-diagonal vertices across all time-slices, with a weight of \\(+r\\) for each \\(S_i^- S_{i+r}^+\\) operator, and a weight of \\(-r\\) for each \\(S_i^{+} S_{i+r}^-\\) operator, and \\(0\\) otherwise. Therefore, the evaluation of the spin stiffness in SSE reduces to a simple operator counting estimator.  </p> <p>In addition to these estimators, the Heisenberg Ion implementation of long range SSE can also be configured to produce shot data. This is produced by recording the entire list of spins at the first time-slice for each simulation step. This should, in principle, allow for the evaluation of all diagonal (in the \\(S_z\\) basis) observables of interest. Finally, for the evaluation of ground state properties in QMC, we can evaluate our observables of interest for increasing values of \\(\\beta\\) until the results converge. The converged values of the observables will then correspond to negligible finite temperature systematic error. </p>"},{"location":"api/drivers/","title":"Drivers","text":""},{"location":"api/drivers/#driver","title":"Driver","text":""},{"location":"api/drivers/#oqd_heisenberg_ion.common.driver","title":"<code>oqd_heisenberg_ion.common.driver</code>","text":""},{"location":"api/drivers/#oqd_heisenberg_ion.common.driver.base","title":"<code>base</code>","text":""},{"location":"api/drivers/#oqd_heisenberg_ion.common.driver.base.Driver","title":"<code>Driver</code>","text":"<p>Driver base class</p> <p>Calls the required simulator engine after preprocessing</p> Source code in <code>src/oqd_heisenberg_ion/common/driver/base.py</code> <pre><code>class Driver:\n    \"\"\"Driver base class\n\n    Calls the required simulator engine after preprocessing\n\n    \"\"\"\n\n    def __init__(self, simulation_folder):\n        \"\"\"Driver base class constructor\n\n        Args:\n            simulation_folder (str): root directory for storing simulator outputs\n\n        Raises:\n                Exception: if the root simulation folder does not exist\n        \"\"\"\n\n        self.simulation_folder = simulation_folder\n        if not os.path.exists(self.simulation_folder):\n            raise Exception(\"Unable to find the root simulation folder\\n\")\n\n    def simulate(self):\n        \"\"\"Driver should always have a simulate method implemented by subclasses\"\"\"\n\n        pass\n</code></pre>"},{"location":"api/drivers/#oqd_heisenberg_ion.common.driver.base.Driver.__init__","title":"<code>__init__</code>","text":"<p>Driver base class constructor</p> <p>Parameters:</p> <ul> <li> <code>simulation_folder</code>               (<code>str</code>)           \u2013            <p>root directory for storing simulator outputs</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>Exception</code>             \u2013            <p>if the root simulation folder does not exist</p> </li> </ul> Source code in <code>src/oqd_heisenberg_ion/common/driver/base.py</code> <pre><code>def __init__(self, simulation_folder):\n    \"\"\"Driver base class constructor\n\n    Args:\n        simulation_folder (str): root directory for storing simulator outputs\n\n    Raises:\n            Exception: if the root simulation folder does not exist\n    \"\"\"\n\n    self.simulation_folder = simulation_folder\n    if not os.path.exists(self.simulation_folder):\n        raise Exception(\"Unable to find the root simulation folder\\n\")\n</code></pre>"},{"location":"api/drivers/#oqd_heisenberg_ion.common.driver.base.Driver.simulate","title":"<code>simulate</code>","text":"<p>Driver should always have a simulate method implemented by subclasses</p> Source code in <code>src/oqd_heisenberg_ion/common/driver/base.py</code> <pre><code>def simulate(self):\n    \"\"\"Driver should always have a simulate method implemented by subclasses\"\"\"\n\n    pass\n</code></pre>"},{"location":"api/drivers/#oqd_heisenberg_ion.common.driver.factory","title":"<code>factory</code>","text":""},{"location":"api/drivers/#oqd_heisenberg_ion.common.driver.factory.DriverFactory","title":"<code>DriverFactory</code>","text":"<p>Generates a Driver object based on input specifications</p> <p>Carries a registry of recognized Driver subclasses, the constructors of which are called to build the Driver objects</p> <p>Raises:</p> <ul> <li> <code>ValueError</code>             \u2013            <p>if the requested driver implementation is not found</p> </li> </ul> Source code in <code>src/oqd_heisenberg_ion/common/driver/factory.py</code> <pre><code>class DriverFactory:\n    \"\"\"\n     Generates a Driver object based on input specifications\n\n     Carries a registry of recognized Driver subclasses, the constructors of which are called to build the Driver objects\n\n    Raises:\n        ValueError: if the requested driver implementation is not found\n\n    \"\"\"\n\n    registry = {}\n\n    def register(cls, name, subclass):\n        \"\"\"\n        adds a Driver subclass to the registry\n\n        Args:\n            name (str): defines the name of the subclass to be registered\n            subclass (Type[Driver]): specifies the subclass to be registered\n        \"\"\"\n\n        cls.registry[name] = subclass\n\n    def create(cls, name, root_folder, simulator_inputs):\n        \"\"\"\n        generates an instance of the requested subclass of Driver\n\n        Args:\n            name (str): specifies the name of the requested subclass\n            root_folder (str): root directory for simulation outputs\n            simulator_inputs (dict): contains the key word arguments to instantiate the Driver subclass requested\n\n        Raises:\n            Exception: if requested driver not found in registry\n\n        Returns:\n            (Driver): instance of requested driver subclass\n        \"\"\"\n\n        if name not in cls.registry:\n            raise Exception(f\"Driver implementation not found for name: {name}\")\n        else:\n            return cls.registry[name](root_folder, simulator_inputs)\n</code></pre>"},{"location":"api/drivers/#oqd_heisenberg_ion.common.driver.factory.DriverFactory.register","title":"<code>register</code>","text":"<p>adds a Driver subclass to the registry</p> <p>Parameters:</p> <ul> <li> <code>name</code>               (<code>str</code>)           \u2013            <p>defines the name of the subclass to be registered</p> </li> <li> <code>subclass</code>               (<code>Type[Driver]</code>)           \u2013            <p>specifies the subclass to be registered</p> </li> </ul> Source code in <code>src/oqd_heisenberg_ion/common/driver/factory.py</code> <pre><code>def register(cls, name, subclass):\n    \"\"\"\n    adds a Driver subclass to the registry\n\n    Args:\n        name (str): defines the name of the subclass to be registered\n        subclass (Type[Driver]): specifies the subclass to be registered\n    \"\"\"\n\n    cls.registry[name] = subclass\n</code></pre>"},{"location":"api/drivers/#oqd_heisenberg_ion.common.driver.factory.DriverFactory.create","title":"<code>create</code>","text":"<p>generates an instance of the requested subclass of Driver</p> <p>Parameters:</p> <ul> <li> <code>name</code>               (<code>str</code>)           \u2013            <p>specifies the name of the requested subclass</p> </li> <li> <code>root_folder</code>               (<code>str</code>)           \u2013            <p>root directory for simulation outputs</p> </li> <li> <code>simulator_inputs</code>               (<code>dict</code>)           \u2013            <p>contains the key word arguments to instantiate the Driver subclass requested</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>Exception</code>             \u2013            <p>if requested driver not found in registry</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Driver</code>           \u2013            <p>instance of requested driver subclass</p> </li> </ul> Source code in <code>src/oqd_heisenberg_ion/common/driver/factory.py</code> <pre><code>def create(cls, name, root_folder, simulator_inputs):\n    \"\"\"\n    generates an instance of the requested subclass of Driver\n\n    Args:\n        name (str): specifies the name of the requested subclass\n        root_folder (str): root directory for simulation outputs\n        simulator_inputs (dict): contains the key word arguments to instantiate the Driver subclass requested\n\n    Raises:\n        Exception: if requested driver not found in registry\n\n    Returns:\n        (Driver): instance of requested driver subclass\n    \"\"\"\n\n    if name not in cls.registry:\n        raise Exception(f\"Driver implementation not found for name: {name}\")\n    else:\n        return cls.registry[name](root_folder, simulator_inputs)\n</code></pre>"},{"location":"api/drivers/#long-range-quantum-monte-carlo","title":"Long Range Quantum Monte Carlo","text":""},{"location":"api/drivers/#oqd_heisenberg_ion.simulators.qmc.long_range.driver","title":"<code>oqd_heisenberg_ion.simulators.qmc.long_range.driver</code>","text":""},{"location":"api/drivers/#oqd_heisenberg_ion.simulators.qmc.long_range.driver.LongRangeQMC","title":"<code>LongRangeQMC</code>","text":"<p>               Bases: <code>Driver</code></p> <p>Driver subclass for long range QMC</p> Source code in <code>src/oqd_heisenberg_ion/simulators/qmc/long_range/driver.py</code> <pre><code>class LongRangeQMC(Driver):\n    \"\"\"\n    Driver subclass for long range QMC\n    \"\"\"\n\n    def __init__(self, simulation_folder, simulator_inputs):\n        \"\"\"\n        builds and compiles the C++ engine if needed after extracting the build directory and input file for the QMC engine\n\n        Args:\n            simulation_folder (str): simulation output folder\n            simulator_inputs (dict): specifies either the binaries or the cpp source directory\n        \"\"\"\n\n        super().__init__(simulation_folder)\n\n        self.input_file = os.path.join(simulation_folder, \"inputs.txt\")\n        self.build_dir = os.path.join(simulation_folder, \"build\")\n        os.mkdir(self.build_dir)\n\n        self.bin_dir = simulator_inputs[\"bin_folder\"]\n        self.source_dir = simulator_inputs[\"cpp_source_folder\"]\n\n        if self.bin_dir is None:\n            self.build_from_cmake(self.source_dir)\n            self.compile_source()\n\n    def build_from_cmake(self, cpp_source):\n        \"\"\"\n        method for calling cmake via Python subprocess\n\n        Args:\n            cpp_source (str): path pointing to the C++ source code\n        \"\"\"\n\n        configure_command = [\"cmake\", cpp_source, \"-DCMAKE_BUILD_TYPE=Release\"]\n        try:\n            subprocess.run(configure_command, cwd=self.build_dir, check=True, capture_output=True, text=True)\n        except subprocess.CalledProcessError as error:\n            print(\"Build from cmake failed with exit code: {}\\n\".format(error.returncode))\n            print(\"STDOUT: {}\".format(error.stdout))\n            print(\"STDERR:{}\".format(error.stderr))\n\n    def compile_source(self):\n        \"\"\"\n        method for compiling the C++ source code\n        \"\"\"\n\n        compile_command = [\"cmake\", \"--build\", \".\", \"-j\"]\n        try:\n            subprocess.run(compile_command, cwd=self.build_dir, check=True, capture_output=True, text=True)\n        except subprocess.CalledProcessError as error:\n            print(\"Compile failed with exit code: {}\\n\".format(error.returncode))\n            print(\"STDOUT: {}\".format(error.stdout))\n            print(\"STDERR:{}\".format(error.stderr))\n\n    def simulate(self):\n        \"\"\"\n        method for calling the C++ engine for simulating the system, via a Python subprocess call\n\n        Returns:\n            (int): exit code, 0 if the simulation terminates gracefully\n        \"\"\"\n\n        if self.bin_dir is not None:\n            copy_command = [\"cp\", \"-r\", self.bin_dir, self.build_dir]\n            try:\n                subprocess.run(copy_command, check=True, capture_output=True, text=True)\n            except subprocess.CalledProcessError as error:\n                print(\"Copying binaries run failed with exit code: {}\\n\".format(error.returncode))\n                print(\"STDOUT: {}\".format(error.stdout))\n                print(\"STDERR:{}\".format(error.stderr))\n\n        try:\n            subprocess.run(\n                [\"./cpp_qmc\", self.input_file], cwd=self.build_dir, check=True, capture_output=True, text=True\n            )\n        except subprocess.CalledProcessError as error:\n            print(\"Cpp run failed with exit code: {}\\n\".format(error.returncode))\n            print(\"STDOUT: {}\".format(error.stdout))\n            print(\"STDERR:{}\".format(error.stderr))\n            raise\n\n        return 0\n</code></pre>"},{"location":"api/drivers/#oqd_heisenberg_ion.simulators.qmc.long_range.driver.LongRangeQMC.__init__","title":"<code>__init__</code>","text":"<p>builds and compiles the C++ engine if needed after extracting the build directory and input file for the QMC engine</p> <p>Parameters:</p> <ul> <li> <code>simulation_folder</code>               (<code>str</code>)           \u2013            <p>simulation output folder</p> </li> <li> <code>simulator_inputs</code>               (<code>dict</code>)           \u2013            <p>specifies either the binaries or the cpp source directory</p> </li> </ul> Source code in <code>src/oqd_heisenberg_ion/simulators/qmc/long_range/driver.py</code> <pre><code>def __init__(self, simulation_folder, simulator_inputs):\n    \"\"\"\n    builds and compiles the C++ engine if needed after extracting the build directory and input file for the QMC engine\n\n    Args:\n        simulation_folder (str): simulation output folder\n        simulator_inputs (dict): specifies either the binaries or the cpp source directory\n    \"\"\"\n\n    super().__init__(simulation_folder)\n\n    self.input_file = os.path.join(simulation_folder, \"inputs.txt\")\n    self.build_dir = os.path.join(simulation_folder, \"build\")\n    os.mkdir(self.build_dir)\n\n    self.bin_dir = simulator_inputs[\"bin_folder\"]\n    self.source_dir = simulator_inputs[\"cpp_source_folder\"]\n\n    if self.bin_dir is None:\n        self.build_from_cmake(self.source_dir)\n        self.compile_source()\n</code></pre>"},{"location":"api/drivers/#oqd_heisenberg_ion.simulators.qmc.long_range.driver.LongRangeQMC.build_from_cmake","title":"<code>build_from_cmake</code>","text":"<p>method for calling cmake via Python subprocess</p> <p>Parameters:</p> <ul> <li> <code>cpp_source</code>               (<code>str</code>)           \u2013            <p>path pointing to the C++ source code</p> </li> </ul> Source code in <code>src/oqd_heisenberg_ion/simulators/qmc/long_range/driver.py</code> <pre><code>def build_from_cmake(self, cpp_source):\n    \"\"\"\n    method for calling cmake via Python subprocess\n\n    Args:\n        cpp_source (str): path pointing to the C++ source code\n    \"\"\"\n\n    configure_command = [\"cmake\", cpp_source, \"-DCMAKE_BUILD_TYPE=Release\"]\n    try:\n        subprocess.run(configure_command, cwd=self.build_dir, check=True, capture_output=True, text=True)\n    except subprocess.CalledProcessError as error:\n        print(\"Build from cmake failed with exit code: {}\\n\".format(error.returncode))\n        print(\"STDOUT: {}\".format(error.stdout))\n        print(\"STDERR:{}\".format(error.stderr))\n</code></pre>"},{"location":"api/drivers/#oqd_heisenberg_ion.simulators.qmc.long_range.driver.LongRangeQMC.compile_source","title":"<code>compile_source</code>","text":"<p>method for compiling the C++ source code</p> Source code in <code>src/oqd_heisenberg_ion/simulators/qmc/long_range/driver.py</code> <pre><code>def compile_source(self):\n    \"\"\"\n    method for compiling the C++ source code\n    \"\"\"\n\n    compile_command = [\"cmake\", \"--build\", \".\", \"-j\"]\n    try:\n        subprocess.run(compile_command, cwd=self.build_dir, check=True, capture_output=True, text=True)\n    except subprocess.CalledProcessError as error:\n        print(\"Compile failed with exit code: {}\\n\".format(error.returncode))\n        print(\"STDOUT: {}\".format(error.stdout))\n        print(\"STDERR:{}\".format(error.stderr))\n</code></pre>"},{"location":"api/drivers/#oqd_heisenberg_ion.simulators.qmc.long_range.driver.LongRangeQMC.simulate","title":"<code>simulate</code>","text":"<p>method for calling the C++ engine for simulating the system, via a Python subprocess call</p> <p>Returns:</p> <ul> <li> <code>int</code>           \u2013            <p>exit code, 0 if the simulation terminates gracefully</p> </li> </ul> Source code in <code>src/oqd_heisenberg_ion/simulators/qmc/long_range/driver.py</code> <pre><code>def simulate(self):\n    \"\"\"\n    method for calling the C++ engine for simulating the system, via a Python subprocess call\n\n    Returns:\n        (int): exit code, 0 if the simulation terminates gracefully\n    \"\"\"\n\n    if self.bin_dir is not None:\n        copy_command = [\"cp\", \"-r\", self.bin_dir, self.build_dir]\n        try:\n            subprocess.run(copy_command, check=True, capture_output=True, text=True)\n        except subprocess.CalledProcessError as error:\n            print(\"Copying binaries run failed with exit code: {}\\n\".format(error.returncode))\n            print(\"STDOUT: {}\".format(error.stdout))\n            print(\"STDERR:{}\".format(error.stderr))\n\n    try:\n        subprocess.run(\n            [\"./cpp_qmc\", self.input_file], cwd=self.build_dir, check=True, capture_output=True, text=True\n        )\n    except subprocess.CalledProcessError as error:\n        print(\"Cpp run failed with exit code: {}\\n\".format(error.returncode))\n        print(\"STDOUT: {}\".format(error.stdout))\n        print(\"STDERR:{}\".format(error.stderr))\n        raise\n\n    return 0\n</code></pre>"},{"location":"api/drivers/#nearest-neighbor-quantum-monte-carlo","title":"Nearest Neighbor Quantum Monte Carlo","text":""},{"location":"api/drivers/#oqd_heisenberg_ion.simulators.qmc.nearest_neighbor.driver","title":"<code>oqd_heisenberg_ion.simulators.qmc.nearest_neighbor.driver</code>","text":""},{"location":"api/drivers/#oqd_heisenberg_ion.simulators.qmc.nearest_neighbor.driver.NearestNeighborQMC","title":"<code>NearestNeighborQMC</code>","text":"<p>               Bases: <code>Driver</code></p> <p>Driver subclass for nearest neighbor qmc</p> Source code in <code>src/oqd_heisenberg_ion/simulators/qmc/nearest_neighbor/driver.py</code> <pre><code>class NearestNeighborQMC(Driver):\n    \"\"\"\n    Driver subclass for nearest neighbor qmc\n    \"\"\"\n\n    def __init__(self, simulation_folder, simulator_inputs):\n        \"\"\"\n        initializes the nearest neighbor qmc driver and counts the number of parameter sets\n\n        Args:\n            simulation_folder (str): path to the simulation output folder\n            simulator_inputs (list[dict]): list of nearest neighbor qmc parameter sets to be simulated\n        \"\"\"\n\n        super().__init__(simulation_folder)\n\n        self.sse_inputs = simulator_inputs\n\n        self.num_parameter_sets = len(simulator_inputs)\n\n    def simulate(self):\n        \"\"\"\n        calls the Python ConfigurationGenerator class, the nearest neighbor qmc engine\n\n        Returns:\n            (int): exit code, 0 if the simulation terminates gracefully\n        \"\"\"\n\n        for i in range(self.num_parameter_sets):\n            run_folder = self.sse_inputs[i].run_folder\n            system = self.sse_inputs[i].system\n            sampling_args = self.sse_inputs[i].sampling_parameters\n\n            config_generator = ConfigurationGenerator(system, sampling_args, run_folder)\n            config_generator.simulate()\n            config_generator.write_outputs()\n\n        return 0\n</code></pre>"},{"location":"api/drivers/#oqd_heisenberg_ion.simulators.qmc.nearest_neighbor.driver.NearestNeighborQMC.__init__","title":"<code>__init__</code>","text":"<p>initializes the nearest neighbor qmc driver and counts the number of parameter sets</p> <p>Parameters:</p> <ul> <li> <code>simulation_folder</code>               (<code>str</code>)           \u2013            <p>path to the simulation output folder</p> </li> <li> <code>simulator_inputs</code>               (<code>list[dict]</code>)           \u2013            <p>list of nearest neighbor qmc parameter sets to be simulated</p> </li> </ul> Source code in <code>src/oqd_heisenberg_ion/simulators/qmc/nearest_neighbor/driver.py</code> <pre><code>def __init__(self, simulation_folder, simulator_inputs):\n    \"\"\"\n    initializes the nearest neighbor qmc driver and counts the number of parameter sets\n\n    Args:\n        simulation_folder (str): path to the simulation output folder\n        simulator_inputs (list[dict]): list of nearest neighbor qmc parameter sets to be simulated\n    \"\"\"\n\n    super().__init__(simulation_folder)\n\n    self.sse_inputs = simulator_inputs\n\n    self.num_parameter_sets = len(simulator_inputs)\n</code></pre>"},{"location":"api/drivers/#oqd_heisenberg_ion.simulators.qmc.nearest_neighbor.driver.NearestNeighborQMC.simulate","title":"<code>simulate</code>","text":"<p>calls the Python ConfigurationGenerator class, the nearest neighbor qmc engine</p> <p>Returns:</p> <ul> <li> <code>int</code>           \u2013            <p>exit code, 0 if the simulation terminates gracefully</p> </li> </ul> Source code in <code>src/oqd_heisenberg_ion/simulators/qmc/nearest_neighbor/driver.py</code> <pre><code>def simulate(self):\n    \"\"\"\n    calls the Python ConfigurationGenerator class, the nearest neighbor qmc engine\n\n    Returns:\n        (int): exit code, 0 if the simulation terminates gracefully\n    \"\"\"\n\n    for i in range(self.num_parameter_sets):\n        run_folder = self.sse_inputs[i].run_folder\n        system = self.sse_inputs[i].system\n        sampling_args = self.sse_inputs[i].sampling_parameters\n\n        config_generator = ConfigurationGenerator(system, sampling_args, run_folder)\n        config_generator.simulate()\n        config_generator.write_outputs()\n\n    return 0\n</code></pre>"},{"location":"api/drivers/#exact-diagonalization","title":"Exact Diagonalization","text":""},{"location":"api/drivers/#oqd_heisenberg_ion.simulators.ed.driver","title":"<code>oqd_heisenberg_ion.simulators.ed.driver</code>","text":""},{"location":"api/drivers/#oqd_heisenberg_ion.simulators.ed.driver.ExactDiagonalization","title":"<code>ExactDiagonalization</code>","text":"<p>               Bases: <code>Driver</code></p> <p>Driver subclass for Exact Diagonalization. Calls the Julia ED engine via a python subprocess which uses the input file generated by the preprocessor to specify the simulation parameters</p> Source code in <code>src/oqd_heisenberg_ion/simulators/ed/driver.py</code> <pre><code>class ExactDiagonalization(Driver):\n    \"\"\"\n    Driver subclass for Exact Diagonalization.\n    Calls the Julia ED engine via a python subprocess which uses the input file generated by the preprocessor to specify the simulation parameters\n    \"\"\"\n\n    def __init__(self, simulation_folder, simulator_inputs):\n        \"\"\"\n        constructor for the ED Driver subclass. Specifies the ED engine path, the ED engine input file path and the Julia path\n\n        Args:\n            simulation_folder (str): the parameter set simulation folder\n            simulator_inputs (dict): contains the Julia path as a key value pair\n        \"\"\"\n\n        super().__init__(simulation_folder)\n\n        self.input_file = os.path.join(simulation_folder, \"inputs.txt\")\n        self.julia_path = simulator_inputs[\"julia_path\"]\n        self.ed_engine = os.path.dirname(os.path.abspath(__file__)) + \"/engine.jl\"\n\n    def simulate(self):\n        \"\"\"\n        calls the Julia engine for the ED calculation\n\n        Returns:\n            (int): exit code, 0 if the program executes to completion\n        \"\"\"\n\n        try:\n            subprocess.run(\n                [self.julia_path, self.ed_engine, self.input_file], check=True, capture_output=True, text=True\n            )\n        except subprocess.CalledProcessError as error:\n            print(f\"Julia execution failed with exit code: {error.returncode}\\n\")\n            print(f\"STDOUT: {error.stdout}\")\n            print(f\"STDERR:{error.stderr}\")\n            raise\n\n        return 0\n</code></pre>"},{"location":"api/drivers/#oqd_heisenberg_ion.simulators.ed.driver.ExactDiagonalization.__init__","title":"<code>__init__</code>","text":"<p>constructor for the ED Driver subclass. Specifies the ED engine path, the ED engine input file path and the Julia path</p> <p>Parameters:</p> <ul> <li> <code>simulation_folder</code>               (<code>str</code>)           \u2013            <p>the parameter set simulation folder</p> </li> <li> <code>simulator_inputs</code>               (<code>dict</code>)           \u2013            <p>contains the Julia path as a key value pair</p> </li> </ul> Source code in <code>src/oqd_heisenberg_ion/simulators/ed/driver.py</code> <pre><code>def __init__(self, simulation_folder, simulator_inputs):\n    \"\"\"\n    constructor for the ED Driver subclass. Specifies the ED engine path, the ED engine input file path and the Julia path\n\n    Args:\n        simulation_folder (str): the parameter set simulation folder\n        simulator_inputs (dict): contains the Julia path as a key value pair\n    \"\"\"\n\n    super().__init__(simulation_folder)\n\n    self.input_file = os.path.join(simulation_folder, \"inputs.txt\")\n    self.julia_path = simulator_inputs[\"julia_path\"]\n    self.ed_engine = os.path.dirname(os.path.abspath(__file__)) + \"/engine.jl\"\n</code></pre>"},{"location":"api/drivers/#oqd_heisenberg_ion.simulators.ed.driver.ExactDiagonalization.simulate","title":"<code>simulate</code>","text":"<p>calls the Julia engine for the ED calculation</p> <p>Returns:</p> <ul> <li> <code>int</code>           \u2013            <p>exit code, 0 if the program executes to completion</p> </li> </ul> Source code in <code>src/oqd_heisenberg_ion/simulators/ed/driver.py</code> <pre><code>def simulate(self):\n    \"\"\"\n    calls the Julia engine for the ED calculation\n\n    Returns:\n        (int): exit code, 0 if the program executes to completion\n    \"\"\"\n\n    try:\n        subprocess.run(\n            [self.julia_path, self.ed_engine, self.input_file], check=True, capture_output=True, text=True\n        )\n    except subprocess.CalledProcessError as error:\n        print(f\"Julia execution failed with exit code: {error.returncode}\\n\")\n        print(f\"STDOUT: {error.stdout}\")\n        print(f\"STDERR:{error.stderr}\")\n        raise\n\n    return 0\n</code></pre>"},{"location":"api/interface/","title":"Interface","text":""},{"location":"api/interface/#main","title":"Main","text":""},{"location":"api/interface/#oqd_heisenberg_ion.interface.main","title":"<code>oqd_heisenberg_ion.interface.main</code>","text":""},{"location":"api/interface/#oqd_heisenberg_ion.interface.main.main","title":"<code>main</code>","text":"<p>main entry point of the package when called from the command line</p> <p>Parameters:</p> <ul> <li> <code>argv</code>               (<code>list[str]</code>, default:                   <code>None</code> )           \u2013            <p>list of command line arguments. Defaults to None.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>int</code>           \u2013            <p>exit code, equals 0 if program executes successfully</p> </li> </ul> Source code in <code>src/oqd_heisenberg_ion/interface/main.py</code> <pre><code>def main(argv=None):\n    \"\"\"\n    main entry point of the package when called from the command line\n\n    Args:\n        argv (list[str], optional): list of command line arguments. Defaults to None.\n\n    Returns:\n        (int): exit code, equals 0 if program executes successfully\n    \"\"\"\n\n    parser = argparse.ArgumentParser()\n    parser.add_argument(\"--input\", \"-i\", required=True, help=\"Path to input file.\")\n    parser.add_argument(\n        \"--override\",\n        \"-o\",\n        required=False,\n        action=\"append\",\n        nargs=2,\n        metavar=(\"KEY\", \"VALUE\"),\n        help=\"Override key word arguments\",\n    )\n    args = parser.parse_args(argv)\n\n    override_dict = extract_override_arguments(args)\n\n    sim_workflow = Orchestrator(input_file=args.input, **override_dict)\n    sim_workflow.simulate()\n\n    return 0\n</code></pre>"},{"location":"api/interface/#orchestrator","title":"Orchestrator","text":""},{"location":"api/interface/#oqd_heisenberg_ion.interface.orchestrator","title":"<code>oqd_heisenberg_ion.interface.orchestrator</code>","text":""},{"location":"api/interface/#oqd_heisenberg_ion.interface.orchestrator.Orchestrator","title":"<code>Orchestrator</code>","text":"<p>Responsible for managing the entire workflow of the package. Sequentially reads the inputs, calls the preprocessor, driver and simulator</p> Source code in <code>src/oqd_heisenberg_ion/interface/orchestrator.py</code> <pre><code>class Orchestrator:\n    \"\"\"\n    Responsible for managing the entire workflow of the package. Sequentially reads the inputs, calls the preprocessor, driver and simulator\n    \"\"\"\n\n    def __init__(self, **kwargs):\n        \"\"\"\n        constructor for the Orchestrator class. Determines whether inputs should be read from file or are provided as key word arguments\n\n        Args:\n            **kwargs (dict): key word arguments. An input file is expected if one of the keys is 'input_file'\n        \"\"\"\n\n        if \"input_file\" in kwargs:\n            self.build_from_file(**kwargs)\n        else:\n            self.build_from_parameters(**kwargs)\n\n    def build_from_file(self, input_file, **kwargs):\n        \"\"\"\n        used to call the preprocessor if input file needs to be read for the simulation.\n\n        Args:\n            input_file (str): path to the input file\n        \"\"\"\n\n        file_inputs = InputReader(input_file_path=input_file)\n        file_inputs.read_inputs_from_file(**kwargs)\n        simulator = file_inputs.simulator\n\n        preprocessor = PreprocessorFactory.create(simulator, file_inputs.parameter_set_list)\n        driver_inputs = preprocessor.preprocess()\n\n        self.driver = DriverFactory.create(simulator, preprocessor.simulation_folder, driver_inputs)\n\n    def build_from_parameters(self, **kwargs):\n        \"\"\"\n        used to call the preprocessor if the simulation inputs are provided as key word arguments\n        \"\"\"\n\n        simulator = kwargs[\"simulator\"]\n\n        inputs = InputReader()\n        inputs.read_kwarg_inputs(**kwargs)\n\n        parameter_set_list = inputs.parameter_set_list\n\n        preprocessor = PreprocessorFactory.create(simulator, parameter_set_list)\n        driver_inputs = preprocessor.preprocess()\n\n        self.driver = DriverFactory.create(simulator, preprocessor.simulation_folder, driver_inputs)\n\n    def simulate(self):\n        \"\"\"\n        simulates the entire workflow\n\n        Returns:\n            (int): the exit code, 0 when the program executes to completion\n        \"\"\"\n\n        self.driver.simulate()\n\n        return 0\n</code></pre>"},{"location":"api/interface/#oqd_heisenberg_ion.interface.orchestrator.Orchestrator.__init__","title":"<code>__init__</code>","text":"<p>constructor for the Orchestrator class. Determines whether inputs should be read from file or are provided as key word arguments</p> <p>Parameters:</p> <ul> <li> <code>**kwargs</code>               (<code>dict</code>, default:                   <code>{}</code> )           \u2013            <p>key word arguments. An input file is expected if one of the keys is 'input_file'</p> </li> </ul> Source code in <code>src/oqd_heisenberg_ion/interface/orchestrator.py</code> <pre><code>def __init__(self, **kwargs):\n    \"\"\"\n    constructor for the Orchestrator class. Determines whether inputs should be read from file or are provided as key word arguments\n\n    Args:\n        **kwargs (dict): key word arguments. An input file is expected if one of the keys is 'input_file'\n    \"\"\"\n\n    if \"input_file\" in kwargs:\n        self.build_from_file(**kwargs)\n    else:\n        self.build_from_parameters(**kwargs)\n</code></pre>"},{"location":"api/interface/#oqd_heisenberg_ion.interface.orchestrator.Orchestrator.build_from_file","title":"<code>build_from_file</code>","text":"<p>used to call the preprocessor if input file needs to be read for the simulation.</p> <p>Parameters:</p> <ul> <li> <code>input_file</code>               (<code>str</code>)           \u2013            <p>path to the input file</p> </li> </ul> Source code in <code>src/oqd_heisenberg_ion/interface/orchestrator.py</code> <pre><code>def build_from_file(self, input_file, **kwargs):\n    \"\"\"\n    used to call the preprocessor if input file needs to be read for the simulation.\n\n    Args:\n        input_file (str): path to the input file\n    \"\"\"\n\n    file_inputs = InputReader(input_file_path=input_file)\n    file_inputs.read_inputs_from_file(**kwargs)\n    simulator = file_inputs.simulator\n\n    preprocessor = PreprocessorFactory.create(simulator, file_inputs.parameter_set_list)\n    driver_inputs = preprocessor.preprocess()\n\n    self.driver = DriverFactory.create(simulator, preprocessor.simulation_folder, driver_inputs)\n</code></pre>"},{"location":"api/interface/#oqd_heisenberg_ion.interface.orchestrator.Orchestrator.build_from_parameters","title":"<code>build_from_parameters</code>","text":"<p>used to call the preprocessor if the simulation inputs are provided as key word arguments</p> Source code in <code>src/oqd_heisenberg_ion/interface/orchestrator.py</code> <pre><code>def build_from_parameters(self, **kwargs):\n    \"\"\"\n    used to call the preprocessor if the simulation inputs are provided as key word arguments\n    \"\"\"\n\n    simulator = kwargs[\"simulator\"]\n\n    inputs = InputReader()\n    inputs.read_kwarg_inputs(**kwargs)\n\n    parameter_set_list = inputs.parameter_set_list\n\n    preprocessor = PreprocessorFactory.create(simulator, parameter_set_list)\n    driver_inputs = preprocessor.preprocess()\n\n    self.driver = DriverFactory.create(simulator, preprocessor.simulation_folder, driver_inputs)\n</code></pre>"},{"location":"api/interface/#oqd_heisenberg_ion.interface.orchestrator.Orchestrator.simulate","title":"<code>simulate</code>","text":"<p>simulates the entire workflow</p> <p>Returns:</p> <ul> <li> <code>int</code>           \u2013            <p>the exit code, 0 when the program executes to completion</p> </li> </ul> Source code in <code>src/oqd_heisenberg_ion/interface/orchestrator.py</code> <pre><code>def simulate(self):\n    \"\"\"\n    simulates the entire workflow\n\n    Returns:\n        (int): the exit code, 0 when the program executes to completion\n    \"\"\"\n\n    self.driver.simulate()\n\n    return 0\n</code></pre>"},{"location":"api/interface/#input-file-reader","title":"Input File Reader","text":""},{"location":"api/interface/#oqd_heisenberg_ion.common.inputs.input_reader","title":"<code>oqd_heisenberg_ion.common.inputs.input_reader</code>","text":""},{"location":"api/interface/#oqd_heisenberg_ion.common.inputs.input_reader.InputReader","title":"<code>InputReader</code>","text":"<p>Extracts provided inputs and generates a list of parameter sets, with each parameter set represented as a dict. Inputs need to be provided either in a tab-delimited file or as key word arguments</p> Source code in <code>src/oqd_heisenberg_ion/common/inputs/input_reader.py</code> <pre><code>class InputReader:\n    \"\"\"\n    Extracts provided inputs and generates a list of parameter sets, with each parameter set represented as a dict.\n    Inputs need to be provided either in a tab-delimited file or as key word arguments\n    \"\"\"\n\n    def __init__(self, simulator=None, input_file_path=None):\n        \"\"\"\n        initializes the InputReader\n\n        Args:\n            input_file_path (str, optional): path to input file. Defaults to None.\n        \"\"\"\n        if input_file_path is not None:\n            self.input_file = os.path.abspath(input_file_path)\n        if simulator is not None:\n            self.simulator = convert_to_snake_case(simulator)\n\n        self.num_parameter_sets = 1\n\n        self.is_param_iterable = {}\n\n        self.parameter_set_list = []\n\n    def read_kwarg_inputs(self, **kwargs):\n        \"\"\"\n        Extracts inputs from key word arguments and builds list of parameter sets\n\n        Args:\n            **kwargs (dict): input key word arguments provided by user\n        \"\"\"\n\n        input_config = self.extract_kwarg_inputs(**kwargs)\n\n        self.extract_parameter_set_list(input_config)\n\n    def read_inputs_from_file(self, **overrides):\n        \"\"\"\n        Extracts inputs from file and builds list of parameter sets\n\n        Args:\n            **overrides (dict): input key word arguments provided by user as overrides\n        \"\"\"\n\n        input_config = self.extract_file_key_value_inputs()\n\n        input_config = self.override_file_inputs(input_config, **overrides)\n\n        self.extract_parameter_set_list(input_config)\n\n        self.simulator = convert_to_snake_case(self.parameter_set_list[0][\"simulator\"])\n\n    def extract_file_key_value_inputs(self):\n        \"\"\"\n        Reads input file to generate a dict of key value pairs specifying parameters. Each value is a list of parameters\n\n        Returns:\n            (dict): containing the key value pairs from the tab delimited input file\n        \"\"\"\n\n        input_config = {}\n\n        with open(self.input_file) as f:\n            line_count = 0\n\n            for line in f.readlines():\n                line_count += 1\n\n                if line.startswith(\"#\") or line.strip() == \"\":\n                    continue\n\n                line_data = line.strip().split(\"\\t\")\n\n                key = line_data[0]\n                data = line_data[1].strip().split(\",\")\n\n                input_config = self.record_input(input_config, key, data)\n\n        return input_config\n\n    def extract_kwarg_inputs(self, **kwargs):\n        \"\"\"\n        Uses key word arguments to generate a dict of key value pairs specifying parameters. Each value is a list of parameters\n\n        Returns:\n            (dict): containing the key value pairs from the tab delimited input file\n        \"\"\"\n\n        input_config = {}\n\n        for key, val in kwargs.items():\n            if isinstance(val, Sequence) and not isinstance(val, str):\n                input_config = self.record_input(input_config, key, val)\n            else:\n                input_config = self.record_input(input_config, key, [val])\n\n        return input_config\n\n    def record_input(self, input_config, key, data):\n        \"\"\"\n        counts the parameter sets for a given key and records the key and the value in the input_config dictionary\n\n        Args:\n            input_config (dict): key value pairs container for input parameters\n            key (str): parameter key\n            data (str): parameter value\n\n        Returns:\n            (dict): containing the key value pairs from the tab delimited input file\n        \"\"\"\n\n        count_entries = len(data)\n        self.count_parameter_sets(count_entries, key)\n\n        input_config[key] = data\n        self.is_param_iterable[key] = count_entries != 1\n\n        return input_config\n\n    def override_file_inputs(self, input_config, **kwargs):\n        \"\"\"\n        overrides file parameter specification with given parameter values\n\n        Args:\n            input_config (dict): key value pairs container for input parameters\n            **kwargs (dict): key word arguments containing the overriding keys and values\n\n        Returns:\n            (dict): key value pairs container for input parameters\n        \"\"\"\n\n        for key, val in kwargs.items():\n            data = val.strip().split(\",\")\n            self.record_input(input_config, key, data)\n\n        return input_config\n\n    def count_parameter_sets(self, count_entries, key):\n        \"\"\"\n        updates the number of parameter sets if more than one parameter set is specified for given key\n\n        Args:\n            count_entries (int): number of entries for given key\n            key (str): parameter key\n\n        Raises:\n            Exception: if number of values provided for key and number of parameter sets &gt; 1 are inconsistent\n        \"\"\"\n\n        if count_entries != 1:\n            if self.num_parameter_sets == 1:\n                self.num_parameter_sets = count_entries\n                self.key_num_parameters_set = key\n\n            # Can't have n&gt;1 parameter sets in one field and m&gt;1 parameter sets in another\n            elif self.num_parameter_sets != count_entries:\n                raise Exception(f\"Inconistent number of entries for fields: {key} and {self.key_num_parameters_set}\\n\")\n\n    def extract_parameter_set_list(self, input_config):\n        \"\"\"\n        populates the list of parameter sets (class member) from the dictionary of input key value pairs\n\n        Args:\n            input_config (dict): contains the key value pairs specifying the parameter set\n        \"\"\"\n        if not self.parameter_set_list:\n            for i in range(self.num_parameter_sets):\n                self.parameter_set_list.append({})\n        elif len(self.parameter_set_list) == 1:\n            for i in range(len(self.parameter_set_list), self.num_parameter_sets):\n                self.parameter_set_list.append(copy.deepcopy(self.parameter_set_list[0]))\n        elif len(self.parameter_set_list) != self.num_parameter_sets:\n            raise Exception(\"Inconsistent numbers of parameter sets encountered\")\n\n        for key, val in input_config.items():\n            if len(val) == 1:\n                for i in range(self.num_parameter_sets):\n                    self.parameter_set_list[i][key] = val[0]\n            else:\n                for i in range(self.num_parameter_sets):\n                    self.parameter_set_list[i][key] = val[i]\n</code></pre>"},{"location":"api/interface/#oqd_heisenberg_ion.common.inputs.input_reader.InputReader.__init__","title":"<code>__init__</code>","text":"<p>initializes the InputReader</p> <p>Parameters:</p> <ul> <li> <code>input_file_path</code>               (<code>str</code>, default:                   <code>None</code> )           \u2013            <p>path to input file. Defaults to None.</p> </li> </ul> Source code in <code>src/oqd_heisenberg_ion/common/inputs/input_reader.py</code> <pre><code>def __init__(self, simulator=None, input_file_path=None):\n    \"\"\"\n    initializes the InputReader\n\n    Args:\n        input_file_path (str, optional): path to input file. Defaults to None.\n    \"\"\"\n    if input_file_path is not None:\n        self.input_file = os.path.abspath(input_file_path)\n    if simulator is not None:\n        self.simulator = convert_to_snake_case(simulator)\n\n    self.num_parameter_sets = 1\n\n    self.is_param_iterable = {}\n\n    self.parameter_set_list = []\n</code></pre>"},{"location":"api/interface/#oqd_heisenberg_ion.common.inputs.input_reader.InputReader.read_kwarg_inputs","title":"<code>read_kwarg_inputs</code>","text":"<p>Extracts inputs from key word arguments and builds list of parameter sets</p> <p>Parameters:</p> <ul> <li> <code>**kwargs</code>               (<code>dict</code>, default:                   <code>{}</code> )           \u2013            <p>input key word arguments provided by user</p> </li> </ul> Source code in <code>src/oqd_heisenberg_ion/common/inputs/input_reader.py</code> <pre><code>def read_kwarg_inputs(self, **kwargs):\n    \"\"\"\n    Extracts inputs from key word arguments and builds list of parameter sets\n\n    Args:\n        **kwargs (dict): input key word arguments provided by user\n    \"\"\"\n\n    input_config = self.extract_kwarg_inputs(**kwargs)\n\n    self.extract_parameter_set_list(input_config)\n</code></pre>"},{"location":"api/interface/#oqd_heisenberg_ion.common.inputs.input_reader.InputReader.read_inputs_from_file","title":"<code>read_inputs_from_file</code>","text":"<p>Extracts inputs from file and builds list of parameter sets</p> <p>Parameters:</p> <ul> <li> <code>**overrides</code>               (<code>dict</code>, default:                   <code>{}</code> )           \u2013            <p>input key word arguments provided by user as overrides</p> </li> </ul> Source code in <code>src/oqd_heisenberg_ion/common/inputs/input_reader.py</code> <pre><code>def read_inputs_from_file(self, **overrides):\n    \"\"\"\n    Extracts inputs from file and builds list of parameter sets\n\n    Args:\n        **overrides (dict): input key word arguments provided by user as overrides\n    \"\"\"\n\n    input_config = self.extract_file_key_value_inputs()\n\n    input_config = self.override_file_inputs(input_config, **overrides)\n\n    self.extract_parameter_set_list(input_config)\n\n    self.simulator = convert_to_snake_case(self.parameter_set_list[0][\"simulator\"])\n</code></pre>"},{"location":"api/interface/#oqd_heisenberg_ion.common.inputs.input_reader.InputReader.extract_file_key_value_inputs","title":"<code>extract_file_key_value_inputs</code>","text":"<p>Reads input file to generate a dict of key value pairs specifying parameters. Each value is a list of parameters</p> <p>Returns:</p> <ul> <li> <code>dict</code>           \u2013            <p>containing the key value pairs from the tab delimited input file</p> </li> </ul> Source code in <code>src/oqd_heisenberg_ion/common/inputs/input_reader.py</code> <pre><code>def extract_file_key_value_inputs(self):\n    \"\"\"\n    Reads input file to generate a dict of key value pairs specifying parameters. Each value is a list of parameters\n\n    Returns:\n        (dict): containing the key value pairs from the tab delimited input file\n    \"\"\"\n\n    input_config = {}\n\n    with open(self.input_file) as f:\n        line_count = 0\n\n        for line in f.readlines():\n            line_count += 1\n\n            if line.startswith(\"#\") or line.strip() == \"\":\n                continue\n\n            line_data = line.strip().split(\"\\t\")\n\n            key = line_data[0]\n            data = line_data[1].strip().split(\",\")\n\n            input_config = self.record_input(input_config, key, data)\n\n    return input_config\n</code></pre>"},{"location":"api/interface/#oqd_heisenberg_ion.common.inputs.input_reader.InputReader.extract_kwarg_inputs","title":"<code>extract_kwarg_inputs</code>","text":"<p>Uses key word arguments to generate a dict of key value pairs specifying parameters. Each value is a list of parameters</p> <p>Returns:</p> <ul> <li> <code>dict</code>           \u2013            <p>containing the key value pairs from the tab delimited input file</p> </li> </ul> Source code in <code>src/oqd_heisenberg_ion/common/inputs/input_reader.py</code> <pre><code>def extract_kwarg_inputs(self, **kwargs):\n    \"\"\"\n    Uses key word arguments to generate a dict of key value pairs specifying parameters. Each value is a list of parameters\n\n    Returns:\n        (dict): containing the key value pairs from the tab delimited input file\n    \"\"\"\n\n    input_config = {}\n\n    for key, val in kwargs.items():\n        if isinstance(val, Sequence) and not isinstance(val, str):\n            input_config = self.record_input(input_config, key, val)\n        else:\n            input_config = self.record_input(input_config, key, [val])\n\n    return input_config\n</code></pre>"},{"location":"api/interface/#oqd_heisenberg_ion.common.inputs.input_reader.InputReader.record_input","title":"<code>record_input</code>","text":"<p>counts the parameter sets for a given key and records the key and the value in the input_config dictionary</p> <p>Parameters:</p> <ul> <li> <code>input_config</code>               (<code>dict</code>)           \u2013            <p>key value pairs container for input parameters</p> </li> <li> <code>key</code>               (<code>str</code>)           \u2013            <p>parameter key</p> </li> <li> <code>data</code>               (<code>str</code>)           \u2013            <p>parameter value</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>dict</code>           \u2013            <p>containing the key value pairs from the tab delimited input file</p> </li> </ul> Source code in <code>src/oqd_heisenberg_ion/common/inputs/input_reader.py</code> <pre><code>def record_input(self, input_config, key, data):\n    \"\"\"\n    counts the parameter sets for a given key and records the key and the value in the input_config dictionary\n\n    Args:\n        input_config (dict): key value pairs container for input parameters\n        key (str): parameter key\n        data (str): parameter value\n\n    Returns:\n        (dict): containing the key value pairs from the tab delimited input file\n    \"\"\"\n\n    count_entries = len(data)\n    self.count_parameter_sets(count_entries, key)\n\n    input_config[key] = data\n    self.is_param_iterable[key] = count_entries != 1\n\n    return input_config\n</code></pre>"},{"location":"api/interface/#oqd_heisenberg_ion.common.inputs.input_reader.InputReader.override_file_inputs","title":"<code>override_file_inputs</code>","text":"<p>overrides file parameter specification with given parameter values</p> <p>Parameters:</p> <ul> <li> <code>input_config</code>               (<code>dict</code>)           \u2013            <p>key value pairs container for input parameters</p> </li> <li> <code>**kwargs</code>               (<code>dict</code>, default:                   <code>{}</code> )           \u2013            <p>key word arguments containing the overriding keys and values</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>dict</code>           \u2013            <p>key value pairs container for input parameters</p> </li> </ul> Source code in <code>src/oqd_heisenberg_ion/common/inputs/input_reader.py</code> <pre><code>def override_file_inputs(self, input_config, **kwargs):\n    \"\"\"\n    overrides file parameter specification with given parameter values\n\n    Args:\n        input_config (dict): key value pairs container for input parameters\n        **kwargs (dict): key word arguments containing the overriding keys and values\n\n    Returns:\n        (dict): key value pairs container for input parameters\n    \"\"\"\n\n    for key, val in kwargs.items():\n        data = val.strip().split(\",\")\n        self.record_input(input_config, key, data)\n\n    return input_config\n</code></pre>"},{"location":"api/interface/#oqd_heisenberg_ion.common.inputs.input_reader.InputReader.count_parameter_sets","title":"<code>count_parameter_sets</code>","text":"<p>updates the number of parameter sets if more than one parameter set is specified for given key</p> <p>Parameters:</p> <ul> <li> <code>count_entries</code>               (<code>int</code>)           \u2013            <p>number of entries for given key</p> </li> <li> <code>key</code>               (<code>str</code>)           \u2013            <p>parameter key</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>Exception</code>             \u2013            <p>if number of values provided for key and number of parameter sets &gt; 1 are inconsistent</p> </li> </ul> Source code in <code>src/oqd_heisenberg_ion/common/inputs/input_reader.py</code> <pre><code>def count_parameter_sets(self, count_entries, key):\n    \"\"\"\n    updates the number of parameter sets if more than one parameter set is specified for given key\n\n    Args:\n        count_entries (int): number of entries for given key\n        key (str): parameter key\n\n    Raises:\n        Exception: if number of values provided for key and number of parameter sets &gt; 1 are inconsistent\n    \"\"\"\n\n    if count_entries != 1:\n        if self.num_parameter_sets == 1:\n            self.num_parameter_sets = count_entries\n            self.key_num_parameters_set = key\n\n        # Can't have n&gt;1 parameter sets in one field and m&gt;1 parameter sets in another\n        elif self.num_parameter_sets != count_entries:\n            raise Exception(f\"Inconistent number of entries for fields: {key} and {self.key_num_parameters_set}\\n\")\n</code></pre>"},{"location":"api/interface/#oqd_heisenberg_ion.common.inputs.input_reader.InputReader.extract_parameter_set_list","title":"<code>extract_parameter_set_list</code>","text":"<p>populates the list of parameter sets (class member) from the dictionary of input key value pairs</p> <p>Parameters:</p> <ul> <li> <code>input_config</code>               (<code>dict</code>)           \u2013            <p>contains the key value pairs specifying the parameter set</p> </li> </ul> Source code in <code>src/oqd_heisenberg_ion/common/inputs/input_reader.py</code> <pre><code>def extract_parameter_set_list(self, input_config):\n    \"\"\"\n    populates the list of parameter sets (class member) from the dictionary of input key value pairs\n\n    Args:\n        input_config (dict): contains the key value pairs specifying the parameter set\n    \"\"\"\n    if not self.parameter_set_list:\n        for i in range(self.num_parameter_sets):\n            self.parameter_set_list.append({})\n    elif len(self.parameter_set_list) == 1:\n        for i in range(len(self.parameter_set_list), self.num_parameter_sets):\n            self.parameter_set_list.append(copy.deepcopy(self.parameter_set_list[0]))\n    elif len(self.parameter_set_list) != self.num_parameter_sets:\n        raise Exception(\"Inconsistent numbers of parameter sets encountered\")\n\n    for key, val in input_config.items():\n        if len(val) == 1:\n            for i in range(self.num_parameter_sets):\n                self.parameter_set_list[i][key] = val[0]\n        else:\n            for i in range(self.num_parameter_sets):\n                self.parameter_set_list[i][key] = val[i]\n</code></pre>"},{"location":"api/postproc/","title":"Post Processing Utilities","text":""},{"location":"api/postproc/#oqd_heisenberg_ion.common.postprocess","title":"<code>oqd_heisenberg_ion.common.postprocess</code>","text":""},{"location":"api/postproc/#oqd_heisenberg_ion.common.postprocess.ffs","title":"<code>ffs</code>","text":""},{"location":"api/postproc/#oqd_heisenberg_ion.common.postprocess.ffs.free_fermion_energy","title":"<code>free_fermion_energy</code>","text":"<p>computes the ground state energy per site associated with a chain of free fermions</p> <p>N should not be divisible by 4 for this calculation to yield the correct energy</p> <p>Parameters:</p> <ul> <li> <code>N</code>               (<code>int</code>)           \u2013            <p>number of sites</p> </li> <li> <code>phi</code>               (<code>float</code>)           \u2013            <p>boundary twist angle</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>float</code>           \u2013            <p>energy per site</p> </li> </ul> Source code in <code>src/oqd_heisenberg_ion/common/postprocess/ffs.py</code> <pre><code>def free_fermion_energy(N, phi):\n    \"\"\"\n    computes the ground state energy per site associated with a chain of free fermions\n\n    N should not be divisible by 4 for this calculation to yield the correct energy\n\n    Args:\n        N (int): number of sites\n        phi (float): boundary twist angle\n\n    Returns:\n        (float): energy per site\n    \"\"\"\n    s_min = -int(N / 2)\n    E = 0.0\n    for i in range(N):\n        s = s_min + i\n        eval = -np.cos(2 * np.pi * s / N - phi / N)\n        if eval &lt; 0.0:\n            E += eval\n\n    # if (s != s_max):\n    #    raise Exception(\"s not equal to s_max\")\n\n    return E / N\n</code></pre>"},{"location":"api/postproc/#oqd_heisenberg_ion.common.postprocess.ffs.free_fermion_stiffness","title":"<code>free_fermion_stiffness</code>","text":"<p>computes the spin stiffness associated with a chain of free fermions</p> <p>Parameters:</p> <ul> <li> <code>N</code>               (<code>int</code>)           \u2013            <p>number of sites</p> </li> <li> <code>phi</code>               (<code>float</code>)           \u2013            <p>boundary twist angle</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>float</code>           \u2013            <p>spin stiffness</p> </li> </ul> Source code in <code>src/oqd_heisenberg_ion/common/postprocess/ffs.py</code> <pre><code>def free_fermion_stiffness(N, phi):\n    \"\"\"\n    computes the spin stiffness associated with a chain of free fermions\n\n    Args:\n        N (int): number of sites\n        phi (float): boundary twist angle\n\n    Returns:\n        (float): spin stiffness\n    \"\"\"\n\n    E_phi = free_fermion_energy(N, phi)\n    E_zero = free_fermion_energy(N, 0.0)\n    E_minus_phi = free_fermion_energy(N, -phi)\n\n    rho = (N**2) * ((E_phi + E_minus_phi - 2.0 * E_zero) / (phi**2))\n\n    return rho\n</code></pre>"},{"location":"api/postproc/#oqd_heisenberg_ion.common.postprocess.swt","title":"<code>swt</code>","text":""},{"location":"api/postproc/#oqd_heisenberg_ion.common.postprocess.swt.gamma_k","title":"<code>gamma_k</code>","text":"<p>computes the coefficient gamma corresponding to the kth Fourier mode in linear spin wave theory for the power law decay spin-1/2 XY model For details, see: https://arxiv.org/pdf/2601.20058</p> <p>Parameters:</p> <ul> <li> <code>N</code>               (<code>int</code>)           \u2013            <p>number of sites</p> </li> <li> <code>k</code>               (<code>int</code>)           \u2013            <p>Fourier mode</p> </li> <li> <code>theta</code>               (<code>float</code>)           \u2013            <p>twist angle</p> </li> <li> <code>alpha</code>               (<code>float</code>)           \u2013            <p>power law decay exponent in interaction couplings</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>float</code>           \u2013            <p>gamma_k</p> </li> </ul> Source code in <code>src/oqd_heisenberg_ion/common/postprocess/swt.py</code> <pre><code>def gamma_k(N, k, theta, alpha):\n    \"\"\"\n    computes the coefficient gamma corresponding to the kth Fourier mode in linear spin wave theory for the power law decay spin-1/2 XY model\n    For details, see: https://arxiv.org/pdf/2601.20058\n\n    Args:\n        N (int): number of sites\n        k (int): Fourier mode\n        theta (float): twist angle\n        alpha (float): power law decay exponent in interaction couplings\n\n    Returns:\n        (float): gamma_k\n    \"\"\"\n\n    gamma = 0.0\n    num_terms = int((N - 1) / 2)\n    for r in range(1, num_terms + 1):\n        gamma += (1.0 / (r**alpha)) * np.cos(2.0 * np.pi * r * k / N) * np.cos(r * theta)\n\n    return gamma\n</code></pre>"},{"location":"api/postproc/#oqd_heisenberg_ion.common.postprocess.swt.E_0_LSW","title":"<code>E_0_LSW</code>","text":"<p>computes the ground state energy in linear spin wave theory for the power law decay spin-1/2 XY model. For details, see: https://arxiv.org/pdf/2601.20058</p> <p>Parameters:</p> <ul> <li> <code>N</code>               (<code>int</code>)           \u2013            <p>number of sites</p> </li> <li> <code>alpha</code>               (<code>float</code>)           \u2013            <p>power law decay exponent</p> </li> <li> <code>J</code>               (<code>float</code>)           \u2013            <p>Energy scale</p> </li> <li> <code>theta</code>               (<code>float</code>, default:                   <code>0.0</code> )           \u2013            <p>Boundary twist angle. Defaults to 0.0.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>float</code>           \u2013            <p>ground state energy in linear spin wave theory</p> </li> </ul> Source code in <code>src/oqd_heisenberg_ion/common/postprocess/swt.py</code> <pre><code>def E_0_LSW(N, alpha, J, theta=0.0):\n    \"\"\"\n    computes the ground state energy in linear spin wave theory for the power law decay spin-1/2 XY model.\n    For details, see: https://arxiv.org/pdf/2601.20058\n\n    Args:\n        N (int): number of sites\n        alpha (float): power law decay exponent\n        J (float): Energy scale\n        theta (float, optional): Boundary twist angle. Defaults to 0.0.\n\n    Returns:\n        (float): ground state energy in linear spin wave theory\n    \"\"\"\n\n    gamma_0 = gamma_k(N, 0, theta, alpha)\n    energy = (-3.0 / 2.0) * N\n\n    for j in range(N):\n        gamma_j = gamma_k(N, j, theta, alpha)\n        energy += np.sqrt(1.0 - gamma_j / gamma_0) + gamma_j / (2.0 * gamma_0)\n\n    energy *= J * gamma_0 / 2.0\n\n    return energy\n</code></pre>"},{"location":"api/postproc/#oqd_heisenberg_ion.common.postprocess.swt.E_0_MF","title":"<code>E_0_MF</code>","text":"<p>computes the ground state energy in mean field theory for the power law decay spin-1/2 XY model. For details, see: https://arxiv.org/pdf/2601.20058</p> <p>Parameters:</p> <ul> <li> <code>N</code>               (<code>int</code>)           \u2013            <p>number of sites</p> </li> <li> <code>alpha</code>               (<code>float</code>)           \u2013            <p>power law decay exponent</p> </li> <li> <code>J</code>               (<code>float</code>)           \u2013            <p>Energy scale</p> </li> <li> <code>theta</code>               (<code>float</code>, default:                   <code>0.0</code> )           \u2013            <p>Boundary twist angle. Defaults to 0.0.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>float</code>           \u2013            <p>ground state energy in mean field theory</p> </li> </ul> Source code in <code>src/oqd_heisenberg_ion/common/postprocess/swt.py</code> <pre><code>def E_0_MF(N, alpha, J, theta=0.0):\n    \"\"\"\n    computes the ground state energy in mean field theory for the power law decay spin-1/2 XY model.\n    For details, see: https://arxiv.org/pdf/2601.20058\n\n    Args:\n        N (int): number of sites\n        alpha (float): power law decay exponent\n        J (float): Energy scale\n        theta (float, optional): Boundary twist angle. Defaults to 0.0.\n\n    Returns:\n        (float): ground state energy in mean field theory\n    \"\"\"\n\n    gamma_0 = gamma_k(N, 0, theta, alpha)\n\n    energy = -J * N * gamma_0 / 4.0\n\n    return energy\n</code></pre>"},{"location":"api/postproc/#oqd_heisenberg_ion.common.postprocess.swt.E_0_LSW_NN","title":"<code>E_0_LSW_NN</code>","text":"<p>computes the ground state energy in linear spin wave theory for the nearest neighbor spin-1/2 XY model. For details, see: https://arxiv.org/pdf/2601.20058</p> <p>Parameters:</p> <ul> <li> <code>N</code>               (<code>int</code>)           \u2013            <p>number of sites</p> </li> <li> <code>J</code>               (<code>float</code>)           \u2013            <p>Energy scale</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>float</code>           \u2013            <p>ground state energy in linear spin wave theory</p> </li> </ul> Source code in <code>src/oqd_heisenberg_ion/common/postprocess/swt.py</code> <pre><code>def E_0_LSW_NN(N, J):\n    \"\"\"\n    computes the ground state energy in linear spin wave theory for the nearest neighbor spin-1/2 XY model.\n    For details, see: https://arxiv.org/pdf/2601.20058\n\n    Args:\n        N (int): number of sites\n        J (float): Energy scale\n\n    Returns:\n        (float): ground state energy in linear spin wave theory\n    \"\"\"\n\n    energy = (-3.0 / 2.0) * N\n\n    for j in range(N):\n        gamma_j = np.cos(2.0 * np.pi * j / N)\n        energy += np.sqrt(1.0 - gamma_j) + gamma_j / (2.0)\n\n    energy *= J / 2.0\n\n    return energy\n</code></pre>"},{"location":"api/postproc/#oqd_heisenberg_ion.common.postprocess.swt.rho_2","title":"<code>rho_2</code>","text":"<p>computes the spin stiffness for the power law decay spin-1/2 XY model in linear spin wave theory For details, see: https://arxiv.org/pdf/2601.20058</p> <p>Parameters:</p> <ul> <li> <code>N</code>               (<code>int</code>)           \u2013            <p>number of sites</p> </li> <li> <code>alpha</code>               (<code>float</code>)           \u2013            <p>power law decay exponent</p> </li> <li> <code>theta</code>               (<code>float</code>)           \u2013            <p>twist angle</p> </li> <li> <code>J_1</code>               (<code>float</code>)           \u2013            <p>energy scale</p> </li> <li> <code>J_2</code>               (<code>float</code>, default:                   <code>1.0</code> )           \u2013            <p>energy scale. Defaults to 1.0. Should typically be set equal to J_1</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>float</code>           \u2013            <p>spin wave theory spin stiffness</p> </li> </ul> Source code in <code>src/oqd_heisenberg_ion/common/postprocess/swt.py</code> <pre><code>def rho_2(N, alpha, theta, J_1, J_2=1.0):\n    \"\"\"\n    computes the spin stiffness for the power law decay spin-1/2 XY model in linear spin wave theory\n    For details, see: https://arxiv.org/pdf/2601.20058\n\n    Args:\n        N (int): number of sites\n        alpha (float): power law decay exponent\n        theta (float): twist angle\n        J_1 (float): energy scale\n        J_2 (float, optional): energy scale. Defaults to 1.0. Should typically be set equal to J_1\n\n    Returns:\n        (float): spin wave theory spin stiffness\n    \"\"\"\n\n    energy_theta = E_0_LSW(N, alpha, J_1, theta)\n    energy_0 = E_0_LSW(N, alpha, J_2, 0.0)\n    rho_N_alpha = 2.0 * (energy_theta - energy_0) / (N * (theta**2))\n\n    return rho_N_alpha\n</code></pre>"},{"location":"api/postproc/#oqd_heisenberg_ion.common.postprocess.swt.rho_mf","title":"<code>rho_mf</code>","text":"<p>computes the spin stiffness for the power law decay spin-1/2 XY model in mean field theory For details, see: https://arxiv.org/pdf/2601.20058</p> <p>Parameters:</p> <ul> <li> <code>N</code>               (<code>int</code>)           \u2013            <p>number of sites</p> </li> <li> <code>alpha</code>               (<code>float</code>)           \u2013            <p>power law decay exponent</p> </li> <li> <code>theta</code>               (<code>float</code>)           \u2013            <p>twist angle</p> </li> <li> <code>J</code>               (<code>float</code>)           \u2013            <p>energy scale</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>float</code>           \u2013            <p>mean field theory spin stiffness</p> </li> </ul> Source code in <code>src/oqd_heisenberg_ion/common/postprocess/swt.py</code> <pre><code>def rho_mf(N, alpha, theta, J):\n    \"\"\"\n    computes the spin stiffness for the power law decay spin-1/2 XY model in mean field theory\n    For details, see: https://arxiv.org/pdf/2601.20058\n\n    Args:\n        N (int): number of sites\n        alpha (float): power law decay exponent\n        theta (float): twist angle\n        J (float): energy scale\n\n    Returns:\n        (float): mean field theory spin stiffness\n    \"\"\"\n\n    energy_theta = E_0_MF(N, alpha, J, theta)\n    energy_0 = E_0_MF(N, alpha, J, 0.0)\n    rho_N_alpha = 2.0 * (energy_theta - energy_0) / (N * (theta**2))\n\n    return rho_N_alpha\n</code></pre>"},{"location":"api/postproc/#oqd_heisenberg_ion.common.postprocess.utils","title":"<code>utils</code>","text":""},{"location":"api/postproc/#oqd_heisenberg_ion.common.postprocess.utils.combine_different_runs","title":"<code>combine_different_runs</code>","text":"<p>concatenates two data sets</p> <p>Parameters:</p> <ul> <li> <code>data_1</code>               (<code>ndarray[float]</code>)           \u2013            <p>T1 x 1 array containing the first data set</p> </li> <li> <code>data_2</code>               (<code>ndarray[float]</code>)           \u2013            <p>T2 x 1 array containing the second data set</p> </li> <li> <code>drop_samples_1</code>               (<code>int</code>)           \u2013            <p>number of samples to drop from the top in data1</p> </li> <li> <code>drop_samples_2</code>               (<code>int</code>)           \u2013            <p>number of samples to drop from the top in data2</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>ndarray[float]</code>           \u2013            <p>(T3 x 1) array containing the concatenated data set</p> </li> </ul> Source code in <code>src/oqd_heisenberg_ion/common/postprocess/utils.py</code> <pre><code>def combine_different_runs(data_1, data_2, drop_samples_1, drop_samples_2):\n    \"\"\"\n    concatenates two data sets\n\n    Args:\n        data_1 (numpy.ndarray[float]): T1 x 1 array containing the first data set\n        data_2 (numpy.ndarray[float]): T2 x 1 array containing the second data set\n        drop_samples_1 (int): number of samples to drop from the top in data1\n        drop_samples_2 (int): number of samples to drop from the top in data2\n\n    Returns:\n        (numpy.ndarray[float]): (T3 x 1) array containing the concatenated data set\n    \"\"\"\n\n    data_3 = []\n    data_1 = data_1[drop_samples_1:]\n    data_2 = data_2[drop_samples_2:]\n\n    for i in range(len(data_1)):\n        data_3.append(data_1[i])\n\n    for i in range(len(data_2)):\n        data_3.append(data_2[i])\n\n    return data_3\n</code></pre>"},{"location":"api/postproc/#oqd_heisenberg_ion.common.postprocess.utils.statistics_binning","title":"<code>statistics_binning</code>","text":"<p>Uses binning to post process QMC estimator data</p> <p>Parameters:</p> <ul> <li> <code>arr</code>               (<code>ndarray[float]</code>)           \u2013            <p>T x 1 array of QMC data where T is the number of simulation steps</p> </li> <li> <code>auto_corr_drop</code>               (<code>int</code>)           \u2013            <p>number of points to remove for auto-correlation</p> </li> <li> <code>eq_drop</code>               (<code>int</code>)           \u2013            <p>number of points to remove for equilibration</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>tuple[float, float]</code>           \u2013            <p>mean and standard error of QMC data</p> </li> </ul> Source code in <code>src/oqd_heisenberg_ion/common/postprocess/utils.py</code> <pre><code>def statistics_binning(arr, auto_corr_drop, eq_drop):\n    \"\"\"\n    Uses binning to post process QMC estimator data\n\n    Args:\n        arr (numpy.ndarray[float]): T x 1 array of QMC data where T is the number of simulation steps\n        auto_corr_drop (int): number of points to remove for auto-correlation\n        eq_drop (int): number of points to remove for equilibration\n\n    Returns:\n        (tuple[float,float]): mean and standard error of QMC data\n    \"\"\"\n\n    arr2 = arr[eq_drop:]\n    arr3 = arr2[0::auto_corr_drop]\n    workingNdim = int(math.log(len(arr3)) / math.log(2))\n    mean = np.mean(arr3)\n    standardError = max_error_binning(arr3, workingNdim - 6)\n    return mean, standardError\n</code></pre>"},{"location":"api/postproc/#oqd_heisenberg_ion.common.postprocess.utils.error_propagation","title":"<code>error_propagation</code>","text":"<p>computes statistical standard error of array</p> <p>Parameters:</p> <ul> <li> <code>data</code>               (<code>ndarray[float]</code>)           \u2013            <p>T x 1 array containing the data</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>float</code>           \u2013            <p>standard error</p> </li> </ul> Source code in <code>src/oqd_heisenberg_ion/common/postprocess/utils.py</code> <pre><code>def error_propagation(data):\n    \"\"\"\n    computes statistical standard error of array\n\n    Args:\n        data (numpy.ndarray[float]): T x 1 array containing the data\n\n    Returns:\n        (float): standard error\n    \"\"\"\n\n    ndim = len(data)\n    error = np.std(data, ddof=0) / np.sqrt(ndim)\n\n    return error\n</code></pre>"},{"location":"api/postproc/#oqd_heisenberg_ion.common.postprocess.utils.max_error_binning","title":"<code>max_error_binning</code>","text":"<p>helper function containing the binning error logic</p> <p>Parameters:</p> <ul> <li> <code>data</code>               (<code>ndarray[float]</code>)           \u2013            <p>T x 1 array containing the data</p> </li> <li> <code>dim</code>               (<code>int</code>)           \u2013            <p>number of binning levels</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>Exception</code>             \u2013            <p>if dim is less than 1 because of insufficient data</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>float</code>           \u2013            <p>binning error</p> </li> </ul> Source code in <code>src/oqd_heisenberg_ion/common/postprocess/utils.py</code> <pre><code>def max_error_binning(data, dim):\n    \"\"\"\n    helper function containing the binning error logic\n\n    Args:\n        data (numpy.ndarray[float]): T x 1 array containing the data\n        dim (int): number of binning levels\n\n    Raises:\n        Exception: if dim is less than 1 because of insufficient data\n\n    Returns:\n        (float): binning error\n    \"\"\"\n\n    if dim &lt;= 1:\n        raise Exception(\"Not enough points MC steps were used for the binning method\\n\")\n\n    error = np.zeros(dim)\n    error[0] = error_propagation(data)\n\n    for i in range(1, dim):\n        bin_dim = int(len(data) / 2)\n        data_bin = np.zeros(bin_dim)\n\n        for j in range(bin_dim):\n            data_bin[j] = 0.5 * (data[2 * j] + data[2 * j + 1])\n        data = data_bin\n        error[i] = error_propagation(data)\n\n    return np.max(error)\n</code></pre>"},{"location":"api/postproc/#oqd_heisenberg_ion.common.postprocess.utils.ed_energy","title":"<code>ed_energy</code>","text":"<p>computes the equilibrium energy from exact diagonalization calculations at given temperature</p> <p>Parameters:</p> <ul> <li> <code>evals</code>               (<code>ndarray[float]</code>)           \u2013            <p>T x 1 array containing the energies for each state</p> </li> <li> <code>T</code>               (<code>float</code>)           \u2013            <p>temperature</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>float</code>           \u2013            <p>equilibrium energy</p> </li> </ul> Source code in <code>src/oqd_heisenberg_ion/common/postprocess/utils.py</code> <pre><code>def ed_energy(evals, T):\n    \"\"\"\n    computes the equilibrium energy from exact diagonalization calculations at given temperature\n\n    Args:\n        evals (numpy.ndarray[float]): T x 1 array containing the energies for each state\n        T (float): temperature\n\n    Returns:\n        (float): equilibrium energy\n    \"\"\"\n\n    beta = 1.0 / T\n\n    energy = 0.0\n    partition = 0.0\n\n    for i in range(len(evals)):\n        energy += np.exp(-beta * evals[i]) * evals[i]\n        partition += np.exp(-beta * evals[i])\n\n    energy /= partition\n\n    return energy\n</code></pre>"},{"location":"api/postproc/#oqd_heisenberg_ion.common.postprocess.utils.compute_histogram_from_shot_data","title":"<code>compute_histogram_from_shot_data</code>","text":"<p>computes the histogram associated with shot data</p> <p>Parameters:</p> <ul> <li> <code>N</code>               (<code>int</code>)           \u2013            <p>number of sites in the lattice</p> </li> <li> <code>num_shots</code>               (<code>int</code>)           \u2013            <p>number of data points</p> </li> <li> <code>shot_data</code>               (<code>ndarray[int]</code>)           \u2013            <p>T x N array of shot data. shot_data[t,k] represents the spin configuration at time t and site k</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>ndarray[float]</code>           \u2013            <p>(T x 1) array containing the histogram frequences where T is the number of possible bitstrings given N</p> </li> </ul> Source code in <code>src/oqd_heisenberg_ion/common/postprocess/utils.py</code> <pre><code>def compute_histogram_from_shot_data(N, num_shots, shot_data):\n    \"\"\"\n    computes the histogram associated with shot data\n\n    Args:\n        N (int): number of sites in the lattice\n        num_shots (int): number of data points\n        shot_data (numpy.ndarray[int]): T x N array of shot data. shot_data[t,k] represents the spin configuration at time t and site k\n\n    Returns:\n        (numpy.ndarray[float]): (T x 1) array containing the histogram frequences where T is the number of possible bitstrings given N\n    \"\"\"\n\n    num_bits = 2**N\n    freqs = np.zeros(num_bits)\n    for i in range(num_shots):\n        bit_str = 0\n        for j in range(N):\n            signed_spin_config = shot_data[i, j]\n            bit_i_j = int(0.5 * (signed_spin_config + np.abs(signed_spin_config)))\n            bit_str += (2 ** (j)) * (bit_i_j)\n        freqs[bit_str] += 1.0 / num_shots\n\n    return freqs\n</code></pre>"},{"location":"api/postproc/#oqd_heisenberg_ion.common.postprocess.utils.kl_divergence","title":"<code>kl_divergence</code>","text":"<p>computes the KL divergence between two histograms</p> <p>Parameters:</p> <ul> <li> <code>hist1</code>               (<code>ndarray[float]</code>)           \u2013            <p>T x 1 array containing the histogram frequences of the first distribution</p> </li> <li> <code>hist2</code>               (<code>ndarray[float]</code>)           \u2013            <p>T x 1 array containing the histogram frequences of the second distribution</p> </li> <li> <code>num_bits</code>               (<code>int</code>)           \u2013            <p>Number of unique measurements in histograms</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>float</code>           \u2013            <p>KL divergence between data sets</p> </li> </ul> Source code in <code>src/oqd_heisenberg_ion/common/postprocess/utils.py</code> <pre><code>def kl_divergence(hist1, hist2, num_bits):\n    \"\"\"\n    computes the KL divergence between two histograms\n\n    Args:\n        hist1 (numpy.ndarray[float]): T x 1 array containing the histogram frequences of the first distribution\n        hist2 (numpy.ndarray[float]): T x 1 array containing the histogram frequences of the second distribution\n        num_bits (int): Number of unique measurements in histograms\n\n    Returns:\n        (float): KL divergence between data sets\n    \"\"\"\n\n    kl_divergence = 0.0\n    for j in range(num_bits):\n        if hist1[j] != 0 and hist2[j] != 0:\n            kl_divergence += hist1[j] * (np.log(hist1[j]) - np.log(hist2[j]))\n\n    return kl_divergence\n</code></pre>"},{"location":"api/preproc/exact_diagonalization/","title":"Exact Diagonalization","text":""},{"location":"api/preproc/exact_diagonalization/#oqd_heisenberg_ion.simulators.ed.preprocessor","title":"<code>oqd_heisenberg_ion.simulators.ed.preprocessor</code>","text":""},{"location":"api/preproc/exact_diagonalization/#oqd_heisenberg_ion.simulators.ed.preprocessor.ExactDiagonalization","title":"<code>ExactDiagonalization</code>","text":"<p>               Bases: <code>Preprocessor</code></p> <p>Preprocessor subclass for Exact Diagonalization. Validates inputs, configures the parameter sets and writes the engine input file</p> Source code in <code>src/oqd_heisenberg_ion/simulators/ed/preprocessor.py</code> <pre><code>class ExactDiagonalization(Preprocessor):\n    \"\"\"\n    Preprocessor subclass for Exact Diagonalization. Validates inputs, configures the parameter sets and writes the engine input file\n    \"\"\"\n\n    def __init__(self, parameter_set_list):\n        \"\"\"\n        constructor for the ED Preprocessor.\n\n        Args:\n            parameter_set_list (list[dict]): list of parameter sets specified with parameter set defined by a dict\n        \"\"\"\n\n        super().__init__(parameter_set_list)\n\n        # self.driver_inputs = []\n\n    def preprocess(self):\n        \"\"\"\n        Preprocesses the simulation parameter sets, and validates root output folder and uuids.\n        Also populates the ED Driver inputs.\n        \"\"\"\n\n        self.check_single_input(\"root_folder\")\n        self.root_folder = self.parameter_set_list[0][\"root_folder\"]\n\n        self.simulation_folder = self.create_output_folder()\n\n        self.extract_cli_requirements()\n\n        self.check_unique_uuids()\n\n        self.configure_simulation()\n\n        return self.driver_inputs\n\n    def configure_simulation(self):\n        \"\"\"\n        Configures all the parameter sets sequentially. Then writes the input file for the engine.\n        \"\"\"\n\n        for i in range(self.num_parameter_sets):\n            parameter_set = self.parameter_set_list[i]\n\n            self.configure_parameter_set(parameter_set)\n\n        self.write_input_file()\n\n    def configure_parameter_set(self, parameter_args):\n        \"\"\"\n        Configures a single parameter set.\n        Determines the run_id, creates the parameter set output folder and parses the str inputs.\n        Also defines the system and appends any required parameters to the parameter set.\n\n        Args:\n            parameter_args (dict): Parameter set arguments specified as key value pairs. Single value for each key specified as a str\n        \"\"\"\n\n        input_config = InputParser(**parameter_args)\n        system_args = input_config.simulation_config[\"system\"]\n\n        misc_args = input_config.simulation_config[\"misc\"]\n        run_id = self.get_run_id(misc_args)\n        misc_args[\"uuid\"] = run_id\n        misc_args[\"output_folder_name\"] = self.output_folder_name\n\n        misc_args[\"simulation_folder\"] = self.simulation_folder\n\n        run_folder = self.create_run_folder(misc_args)\n        misc_args[\"run_folder\"] = run_folder\n\n        system = System(**system_args)\n        system_args = system.update_parameters(system_args)\n\n        if system.interaction_range == \"long_range\":\n            J_ij_file_path = os.path.join(run_folder, \"J_ij_file.csv\")\n            system.interactions.write_to_file(J_ij_file_path)\n            misc_args[\"J_ij_file\"] = J_ij_file_path\n\n        self.processed_configs.append(input_config.simulation_config)\n\n    def extract_cli_requirements(self):\n        \"\"\"\n        Extracts the Julia path if specified as a user input. If not provided, attempts to find the Julia path and throws an error if unsucessful.\n        If the path is available, populates the ED Driver inputs\n        \"\"\"\n\n        julia_path = self.extract_optional_input(\"julia_path\", True)\n        if julia_path is None:\n            julia_path = sh.which(\"julia\")\n            if julia_path is None:\n                raise Exception(\"No Julia path provided\\n\")\n\n        self.driver_inputs = {\"julia_path\": julia_path}\n</code></pre>"},{"location":"api/preproc/exact_diagonalization/#oqd_heisenberg_ion.simulators.ed.preprocessor.ExactDiagonalization.__init__","title":"<code>__init__</code>","text":"<p>constructor for the ED Preprocessor.</p> <p>Parameters:</p> <ul> <li> <code>parameter_set_list</code>               (<code>list[dict]</code>)           \u2013            <p>list of parameter sets specified with parameter set defined by a dict</p> </li> </ul> Source code in <code>src/oqd_heisenberg_ion/simulators/ed/preprocessor.py</code> <pre><code>def __init__(self, parameter_set_list):\n    \"\"\"\n    constructor for the ED Preprocessor.\n\n    Args:\n        parameter_set_list (list[dict]): list of parameter sets specified with parameter set defined by a dict\n    \"\"\"\n\n    super().__init__(parameter_set_list)\n</code></pre>"},{"location":"api/preproc/exact_diagonalization/#oqd_heisenberg_ion.simulators.ed.preprocessor.ExactDiagonalization.preprocess","title":"<code>preprocess</code>","text":"<p>Preprocesses the simulation parameter sets, and validates root output folder and uuids. Also populates the ED Driver inputs.</p> Source code in <code>src/oqd_heisenberg_ion/simulators/ed/preprocessor.py</code> <pre><code>def preprocess(self):\n    \"\"\"\n    Preprocesses the simulation parameter sets, and validates root output folder and uuids.\n    Also populates the ED Driver inputs.\n    \"\"\"\n\n    self.check_single_input(\"root_folder\")\n    self.root_folder = self.parameter_set_list[0][\"root_folder\"]\n\n    self.simulation_folder = self.create_output_folder()\n\n    self.extract_cli_requirements()\n\n    self.check_unique_uuids()\n\n    self.configure_simulation()\n\n    return self.driver_inputs\n</code></pre>"},{"location":"api/preproc/exact_diagonalization/#oqd_heisenberg_ion.simulators.ed.preprocessor.ExactDiagonalization.configure_simulation","title":"<code>configure_simulation</code>","text":"<p>Configures all the parameter sets sequentially. Then writes the input file for the engine.</p> Source code in <code>src/oqd_heisenberg_ion/simulators/ed/preprocessor.py</code> <pre><code>def configure_simulation(self):\n    \"\"\"\n    Configures all the parameter sets sequentially. Then writes the input file for the engine.\n    \"\"\"\n\n    for i in range(self.num_parameter_sets):\n        parameter_set = self.parameter_set_list[i]\n\n        self.configure_parameter_set(parameter_set)\n\n    self.write_input_file()\n</code></pre>"},{"location":"api/preproc/exact_diagonalization/#oqd_heisenberg_ion.simulators.ed.preprocessor.ExactDiagonalization.configure_parameter_set","title":"<code>configure_parameter_set</code>","text":"<p>Configures a single parameter set. Determines the run_id, creates the parameter set output folder and parses the str inputs. Also defines the system and appends any required parameters to the parameter set.</p> <p>Parameters:</p> <ul> <li> <code>parameter_args</code>               (<code>dict</code>)           \u2013            <p>Parameter set arguments specified as key value pairs. Single value for each key specified as a str</p> </li> </ul> Source code in <code>src/oqd_heisenberg_ion/simulators/ed/preprocessor.py</code> <pre><code>def configure_parameter_set(self, parameter_args):\n    \"\"\"\n    Configures a single parameter set.\n    Determines the run_id, creates the parameter set output folder and parses the str inputs.\n    Also defines the system and appends any required parameters to the parameter set.\n\n    Args:\n        parameter_args (dict): Parameter set arguments specified as key value pairs. Single value for each key specified as a str\n    \"\"\"\n\n    input_config = InputParser(**parameter_args)\n    system_args = input_config.simulation_config[\"system\"]\n\n    misc_args = input_config.simulation_config[\"misc\"]\n    run_id = self.get_run_id(misc_args)\n    misc_args[\"uuid\"] = run_id\n    misc_args[\"output_folder_name\"] = self.output_folder_name\n\n    misc_args[\"simulation_folder\"] = self.simulation_folder\n\n    run_folder = self.create_run_folder(misc_args)\n    misc_args[\"run_folder\"] = run_folder\n\n    system = System(**system_args)\n    system_args = system.update_parameters(system_args)\n\n    if system.interaction_range == \"long_range\":\n        J_ij_file_path = os.path.join(run_folder, \"J_ij_file.csv\")\n        system.interactions.write_to_file(J_ij_file_path)\n        misc_args[\"J_ij_file\"] = J_ij_file_path\n\n    self.processed_configs.append(input_config.simulation_config)\n</code></pre>"},{"location":"api/preproc/exact_diagonalization/#oqd_heisenberg_ion.simulators.ed.preprocessor.ExactDiagonalization.extract_cli_requirements","title":"<code>extract_cli_requirements</code>","text":"<p>Extracts the Julia path if specified as a user input. If not provided, attempts to find the Julia path and throws an error if unsucessful. If the path is available, populates the ED Driver inputs</p> Source code in <code>src/oqd_heisenberg_ion/simulators/ed/preprocessor.py</code> <pre><code>def extract_cli_requirements(self):\n    \"\"\"\n    Extracts the Julia path if specified as a user input. If not provided, attempts to find the Julia path and throws an error if unsucessful.\n    If the path is available, populates the ED Driver inputs\n    \"\"\"\n\n    julia_path = self.extract_optional_input(\"julia_path\", True)\n    if julia_path is None:\n        julia_path = sh.which(\"julia\")\n        if julia_path is None:\n            raise Exception(\"No Julia path provided\\n\")\n\n    self.driver_inputs = {\"julia_path\": julia_path}\n</code></pre>"},{"location":"api/preproc/input_parser/","title":"Input Parser","text":""},{"location":"api/preproc/input_parser/#oqd_heisenberg_ion.common.inputs.input_parser","title":"<code>oqd_heisenberg_ion.common.inputs.input_parser</code>","text":""},{"location":"api/preproc/input_parser/#oqd_heisenberg_ion.common.inputs.input_parser.InputParser","title":"<code>InputParser</code>","text":"<p>Parses the provided list of inputs for a single parameter set. Converts strings to required types using the data schema and builds the input configurations for the driver</p> Source code in <code>src/oqd_heisenberg_ion/common/inputs/input_parser.py</code> <pre><code>class InputParser:\n    \"\"\"\n    Parses the provided list of inputs for a single parameter set.\n    Converts strings to required types using the data schema and builds the input configurations for the driver\n    \"\"\"\n\n    def __init__(self, **config_settings):\n        \"\"\"\n        constructs an instance of InputParser. Builds the input_config settings for the driver layer\n\n        Args:\n            **config_settings (dict): key word arguments specifying a single parameter set with str values\n        \"\"\"\n\n        self.dtype_parsers = {\n            str: self.extract_string,\n            int: self.extract_integer,\n            float: self.extract_float,\n            bool: self.extract_bool,\n            \"categorical\": self.extract_categorical,\n        }\n\n        self.input_schema = input_schema\n\n        self.simulation_config = {}\n\n        self.build_input_config(config_settings)\n\n    def extract_integer(self, config_settings, key):\n        \"\"\"\n        converts str to int for parameter specified by key\n\n        Args:\n            config_settings (dict): contains the key value pairs that define the simulation parameter set\n            key (str): parameter key\n\n        Returns:\n            (int): parameter value\n        \"\"\"\n\n        return int(config_settings[key])\n\n    def extract_float(self, config_settings, key):\n        \"\"\"\n        converts str to float for parameter specified by key\n\n        Args:\n            config_settings (dict): contains the key value pairs that define the simulation parameter set\n            key (str): parameter key\n\n        Returns:\n            (float): parameter value\n        \"\"\"\n\n        return float(config_settings[key])\n\n    def extract_string(self, config_settings, key):\n        \"\"\"\n        extracts str parameter specified by key\n\n        Args:\n            config_settings (dict): contains the key value pairs that define the simulation parameter set\n            key (str): parameter key\n\n        Returns:\n            (str): parameter value\n        \"\"\"\n\n        return config_settings[key]\n\n    def extract_bool(self, config_settings, key):\n        \"\"\"\n        converts str to bool for parameter specified by key\n\n        Args:\n            config_settings (dict): contains the key value pairs that define the simulation parameter set\n            key (str): parameter key\n\n        Returns:\n            (bool): parameter value\n        \"\"\"\n\n        if isinstance(config_settings[key], bool):\n            return config_settings[key]\n        else:\n            if config_settings[key].capitalize() == \"True\":\n                return True\n            elif config_settings[key].capitalize() == \"False\":\n                return False\n            else:\n                raise ValueError(\n                    f\"Unrecognized entry for key {key}, value provided: {config_settings[key]}. \"\n                    \"Allowed values are 'True' or 'False'\\n\"\n                )\n\n    def extract_categorical(self, config_settings, key):\n        \"\"\"\n        extracts categorical parameter specified by key. Checks if the provided value is allowed by schema\n\n        Args:\n            config_settings (dict): contains the key value pairs that define the simulation parameter set\n            key (str): parameter key\n\n        Raises:\n            ValueError: if value associated with key is unrecognized by schema\n\n        Returns:\n            (str): parameter value\n        \"\"\"\n\n        val = config_settings[key]\n\n        allowed_vals = self.input_schema[key][\"Categories\"]\n\n        if val in allowed_vals:\n            return convert_to_snake_case(val) if self.input_schema[key][\"ConvertValCase\"] else val\n        else:\n            raise ValueError(\n                f\"Unrecognized input for key: {key}. Value provided: {val}. Allowed values: {allowed_vals}\"\n            )\n\n    def build_input_config(self, config_settings):\n        \"\"\"\n        builds the entire input configuration corresponding to the parameter set with correct types\n\n        Args:\n            config_settings (dict): key word arguments specifying a single parameter set with str values\n\n        \"\"\"\n\n        for key in config_settings.keys():\n            dtype = self.input_schema[key][\"DataType\"]\n            param_type = self.input_schema[key][\"ParameterType\"]\n\n            parser = self.dtype_parsers[dtype]\n            val = parser(config_settings, key)\n\n            if param_type not in self.simulation_config:\n                self.simulation_config[param_type] = {}\n\n            self.simulation_config[param_type][key] = val\n</code></pre>"},{"location":"api/preproc/input_parser/#oqd_heisenberg_ion.common.inputs.input_parser.InputParser.__init__","title":"<code>__init__</code>","text":"<p>constructs an instance of InputParser. Builds the input_config settings for the driver layer</p> <p>Parameters:</p> <ul> <li> <code>**config_settings</code>               (<code>dict</code>, default:                   <code>{}</code> )           \u2013            <p>key word arguments specifying a single parameter set with str values</p> </li> </ul> Source code in <code>src/oqd_heisenberg_ion/common/inputs/input_parser.py</code> <pre><code>def __init__(self, **config_settings):\n    \"\"\"\n    constructs an instance of InputParser. Builds the input_config settings for the driver layer\n\n    Args:\n        **config_settings (dict): key word arguments specifying a single parameter set with str values\n    \"\"\"\n\n    self.dtype_parsers = {\n        str: self.extract_string,\n        int: self.extract_integer,\n        float: self.extract_float,\n        bool: self.extract_bool,\n        \"categorical\": self.extract_categorical,\n    }\n\n    self.input_schema = input_schema\n\n    self.simulation_config = {}\n\n    self.build_input_config(config_settings)\n</code></pre>"},{"location":"api/preproc/input_parser/#oqd_heisenberg_ion.common.inputs.input_parser.InputParser.extract_integer","title":"<code>extract_integer</code>","text":"<p>converts str to int for parameter specified by key</p> <p>Parameters:</p> <ul> <li> <code>config_settings</code>               (<code>dict</code>)           \u2013            <p>contains the key value pairs that define the simulation parameter set</p> </li> <li> <code>key</code>               (<code>str</code>)           \u2013            <p>parameter key</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>int</code>           \u2013            <p>parameter value</p> </li> </ul> Source code in <code>src/oqd_heisenberg_ion/common/inputs/input_parser.py</code> <pre><code>def extract_integer(self, config_settings, key):\n    \"\"\"\n    converts str to int for parameter specified by key\n\n    Args:\n        config_settings (dict): contains the key value pairs that define the simulation parameter set\n        key (str): parameter key\n\n    Returns:\n        (int): parameter value\n    \"\"\"\n\n    return int(config_settings[key])\n</code></pre>"},{"location":"api/preproc/input_parser/#oqd_heisenberg_ion.common.inputs.input_parser.InputParser.extract_float","title":"<code>extract_float</code>","text":"<p>converts str to float for parameter specified by key</p> <p>Parameters:</p> <ul> <li> <code>config_settings</code>               (<code>dict</code>)           \u2013            <p>contains the key value pairs that define the simulation parameter set</p> </li> <li> <code>key</code>               (<code>str</code>)           \u2013            <p>parameter key</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>float</code>           \u2013            <p>parameter value</p> </li> </ul> Source code in <code>src/oqd_heisenberg_ion/common/inputs/input_parser.py</code> <pre><code>def extract_float(self, config_settings, key):\n    \"\"\"\n    converts str to float for parameter specified by key\n\n    Args:\n        config_settings (dict): contains the key value pairs that define the simulation parameter set\n        key (str): parameter key\n\n    Returns:\n        (float): parameter value\n    \"\"\"\n\n    return float(config_settings[key])\n</code></pre>"},{"location":"api/preproc/input_parser/#oqd_heisenberg_ion.common.inputs.input_parser.InputParser.extract_string","title":"<code>extract_string</code>","text":"<p>extracts str parameter specified by key</p> <p>Parameters:</p> <ul> <li> <code>config_settings</code>               (<code>dict</code>)           \u2013            <p>contains the key value pairs that define the simulation parameter set</p> </li> <li> <code>key</code>               (<code>str</code>)           \u2013            <p>parameter key</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>str</code>           \u2013            <p>parameter value</p> </li> </ul> Source code in <code>src/oqd_heisenberg_ion/common/inputs/input_parser.py</code> <pre><code>def extract_string(self, config_settings, key):\n    \"\"\"\n    extracts str parameter specified by key\n\n    Args:\n        config_settings (dict): contains the key value pairs that define the simulation parameter set\n        key (str): parameter key\n\n    Returns:\n        (str): parameter value\n    \"\"\"\n\n    return config_settings[key]\n</code></pre>"},{"location":"api/preproc/input_parser/#oqd_heisenberg_ion.common.inputs.input_parser.InputParser.extract_bool","title":"<code>extract_bool</code>","text":"<p>converts str to bool for parameter specified by key</p> <p>Parameters:</p> <ul> <li> <code>config_settings</code>               (<code>dict</code>)           \u2013            <p>contains the key value pairs that define the simulation parameter set</p> </li> <li> <code>key</code>               (<code>str</code>)           \u2013            <p>parameter key</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>bool</code>           \u2013            <p>parameter value</p> </li> </ul> Source code in <code>src/oqd_heisenberg_ion/common/inputs/input_parser.py</code> <pre><code>def extract_bool(self, config_settings, key):\n    \"\"\"\n    converts str to bool for parameter specified by key\n\n    Args:\n        config_settings (dict): contains the key value pairs that define the simulation parameter set\n        key (str): parameter key\n\n    Returns:\n        (bool): parameter value\n    \"\"\"\n\n    if isinstance(config_settings[key], bool):\n        return config_settings[key]\n    else:\n        if config_settings[key].capitalize() == \"True\":\n            return True\n        elif config_settings[key].capitalize() == \"False\":\n            return False\n        else:\n            raise ValueError(\n                f\"Unrecognized entry for key {key}, value provided: {config_settings[key]}. \"\n                \"Allowed values are 'True' or 'False'\\n\"\n            )\n</code></pre>"},{"location":"api/preproc/input_parser/#oqd_heisenberg_ion.common.inputs.input_parser.InputParser.extract_categorical","title":"<code>extract_categorical</code>","text":"<p>extracts categorical parameter specified by key. Checks if the provided value is allowed by schema</p> <p>Parameters:</p> <ul> <li> <code>config_settings</code>               (<code>dict</code>)           \u2013            <p>contains the key value pairs that define the simulation parameter set</p> </li> <li> <code>key</code>               (<code>str</code>)           \u2013            <p>parameter key</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>ValueError</code>             \u2013            <p>if value associated with key is unrecognized by schema</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>str</code>           \u2013            <p>parameter value</p> </li> </ul> Source code in <code>src/oqd_heisenberg_ion/common/inputs/input_parser.py</code> <pre><code>def extract_categorical(self, config_settings, key):\n    \"\"\"\n    extracts categorical parameter specified by key. Checks if the provided value is allowed by schema\n\n    Args:\n        config_settings (dict): contains the key value pairs that define the simulation parameter set\n        key (str): parameter key\n\n    Raises:\n        ValueError: if value associated with key is unrecognized by schema\n\n    Returns:\n        (str): parameter value\n    \"\"\"\n\n    val = config_settings[key]\n\n    allowed_vals = self.input_schema[key][\"Categories\"]\n\n    if val in allowed_vals:\n        return convert_to_snake_case(val) if self.input_schema[key][\"ConvertValCase\"] else val\n    else:\n        raise ValueError(\n            f\"Unrecognized input for key: {key}. Value provided: {val}. Allowed values: {allowed_vals}\"\n        )\n</code></pre>"},{"location":"api/preproc/input_parser/#oqd_heisenberg_ion.common.inputs.input_parser.InputParser.build_input_config","title":"<code>build_input_config</code>","text":"<p>builds the entire input configuration corresponding to the parameter set with correct types</p> <p>Parameters:</p> <ul> <li> <code>config_settings</code>               (<code>dict</code>)           \u2013            <p>key word arguments specifying a single parameter set with str values</p> </li> </ul> Source code in <code>src/oqd_heisenberg_ion/common/inputs/input_parser.py</code> <pre><code>def build_input_config(self, config_settings):\n    \"\"\"\n    builds the entire input configuration corresponding to the parameter set with correct types\n\n    Args:\n        config_settings (dict): key word arguments specifying a single parameter set with str values\n\n    \"\"\"\n\n    for key in config_settings.keys():\n        dtype = self.input_schema[key][\"DataType\"]\n        param_type = self.input_schema[key][\"ParameterType\"]\n\n        parser = self.dtype_parsers[dtype]\n        val = parser(config_settings, key)\n\n        if param_type not in self.simulation_config:\n            self.simulation_config[param_type] = {}\n\n        self.simulation_config[param_type][key] = val\n</code></pre>"},{"location":"api/preproc/long_range_qmc/","title":"Long Range Quantum Monte Carlo","text":""},{"location":"api/preproc/long_range_qmc/#oqd_heisenberg_ion.simulators.qmc.long_range.preprocessor","title":"<code>oqd_heisenberg_ion.simulators.qmc.long_range.preprocessor</code>","text":""},{"location":"api/preproc/long_range_qmc/#oqd_heisenberg_ion.simulators.qmc.long_range.preprocessor.LongRangeQMC","title":"<code>LongRangeQMC</code>","text":"<p>               Bases: <code>Preprocessor</code></p> <p>Preprocessor subclass for long range QMC. Configures the parameter sets and writes the input file for the engine. Also calls the probability table builder to write the tables to files for use in the QMC simulation</p> Source code in <code>src/oqd_heisenberg_ion/simulators/qmc/long_range/preprocessor.py</code> <pre><code>class LongRangeQMC(Preprocessor):\n    \"\"\"\n    Preprocessor subclass for long range QMC. Configures the parameter sets and writes the input file for the engine.\n    Also calls the probability table builder to write the tables to files for use in the QMC simulation\n    \"\"\"\n\n    def __init__(self, parameter_set_list):\n        \"\"\"\n        executes the preprocessing logic for long range QMC\n\n        Args:\n            parameter_set_list (list[dict]): list of parameter sets specified as dicts with unparsed values\n        \"\"\"\n\n        super().__init__(parameter_set_list)\n\n        self.bin_folder = None\n        self.cpp_source_folder = None\n\n    def preprocess(self):\n        \"\"\"\n        validates user inputs that need to be unique and creates the simulation output folder. Extracts the inputs for the long range QMC driver\n        and executes the parameter set configuration logic\n        \"\"\"\n\n        self.check_single_input(\"root_folder\")\n        self.root_folder = self.parameter_set_list[0][\"root_folder\"]\n\n        self.simulation_folder = self.create_output_folder()\n\n        self.check_single_input(\"number_of_threads\", True)\n\n        self.extract_cli_requirements()\n\n        self.check_unique_uuids()\n\n        self.configure_simulation()\n\n        return self.driver_inputs\n\n    def configure_simulation(self):\n        \"\"\"\n        configures the inputs corresponding to each parameter set requested and writes the input file for the QMC engine\n        \"\"\"\n\n        for i in range(self.num_parameter_sets):\n            self.configure_parameter_set(self.parameter_set_list[i])\n\n        self.write_input_file()\n\n    def configure_parameter_set(self, parameter_args):\n        \"\"\"\n        implements the configuration logic for a single parameter set. Parses inputs, creates the parameter set output directory and\n        calls the probability table builder for each parameter set\n\n        Args:\n            parameter_args (dict): contains a single unparsed parameter set\n        \"\"\"\n\n        input_config = InputParser(**parameter_args)\n        system_args = input_config.simulation_config[\"system\"]\n\n        misc_args = input_config.simulation_config[\"misc\"]\n        run_id = self.get_run_id(misc_args)\n        misc_args[\"uuid\"] = run_id\n        misc_args[\"output_folder_name\"] = self.output_folder_name\n\n        misc_args[\"simulation_folder\"] = self.simulation_folder\n\n        run_folder = self.create_run_folder(misc_args)\n        misc_args[\"run_folder\"] = run_folder\n\n        system = System(**system_args)\n        system_args = system.update_parameters(system_args)\n\n        sampling_args = input_config.simulation_config[\"sampling\"]\n        prob_table_type = sampling_args[\"loop_type\"]\n\n        prob_table_args = ProbabilityTableFactory.extract_args(prob_table_type, **sampling_args)\n        probability_table = ProbabilityTableFactory.create(prob_table_type, system, **prob_table_args)\n        probability_table.write_to_files(run_folder)\n\n        self.processed_configs.append(input_config.simulation_config)\n\n    def extract_cli_requirements(self):\n        \"\"\"\n        prepares the driver inputs by extracting the binary folder and cpp source folder if they are provided. If not provided, attempts to find the source folder in the expected location\n        \"\"\"\n\n        bin_folder = self.extract_optional_input(\"bin_folder\", True)\n        cpp_source_folder = self.extract_optional_input(\"cpp_source_folder\", True)\n\n        if bin_folder is None and cpp_source_folder is None:\n            cpp_source_folder = os.path.dirname(os.path.abspath(__file__)) + \"/engine/\"\n\n        self.driver_inputs = {\"bin_folder\": bin_folder, \"cpp_source_folder\": cpp_source_folder}\n</code></pre>"},{"location":"api/preproc/long_range_qmc/#oqd_heisenberg_ion.simulators.qmc.long_range.preprocessor.LongRangeQMC.__init__","title":"<code>__init__</code>","text":"<p>executes the preprocessing logic for long range QMC</p> <p>Parameters:</p> <ul> <li> <code>parameter_set_list</code>               (<code>list[dict]</code>)           \u2013            <p>list of parameter sets specified as dicts with unparsed values</p> </li> </ul> Source code in <code>src/oqd_heisenberg_ion/simulators/qmc/long_range/preprocessor.py</code> <pre><code>def __init__(self, parameter_set_list):\n    \"\"\"\n    executes the preprocessing logic for long range QMC\n\n    Args:\n        parameter_set_list (list[dict]): list of parameter sets specified as dicts with unparsed values\n    \"\"\"\n\n    super().__init__(parameter_set_list)\n\n    self.bin_folder = None\n    self.cpp_source_folder = None\n</code></pre>"},{"location":"api/preproc/long_range_qmc/#oqd_heisenberg_ion.simulators.qmc.long_range.preprocessor.LongRangeQMC.preprocess","title":"<code>preprocess</code>","text":"<p>validates user inputs that need to be unique and creates the simulation output folder. Extracts the inputs for the long range QMC driver and executes the parameter set configuration logic</p> Source code in <code>src/oqd_heisenberg_ion/simulators/qmc/long_range/preprocessor.py</code> <pre><code>def preprocess(self):\n    \"\"\"\n    validates user inputs that need to be unique and creates the simulation output folder. Extracts the inputs for the long range QMC driver\n    and executes the parameter set configuration logic\n    \"\"\"\n\n    self.check_single_input(\"root_folder\")\n    self.root_folder = self.parameter_set_list[0][\"root_folder\"]\n\n    self.simulation_folder = self.create_output_folder()\n\n    self.check_single_input(\"number_of_threads\", True)\n\n    self.extract_cli_requirements()\n\n    self.check_unique_uuids()\n\n    self.configure_simulation()\n\n    return self.driver_inputs\n</code></pre>"},{"location":"api/preproc/long_range_qmc/#oqd_heisenberg_ion.simulators.qmc.long_range.preprocessor.LongRangeQMC.configure_simulation","title":"<code>configure_simulation</code>","text":"<p>configures the inputs corresponding to each parameter set requested and writes the input file for the QMC engine</p> Source code in <code>src/oqd_heisenberg_ion/simulators/qmc/long_range/preprocessor.py</code> <pre><code>def configure_simulation(self):\n    \"\"\"\n    configures the inputs corresponding to each parameter set requested and writes the input file for the QMC engine\n    \"\"\"\n\n    for i in range(self.num_parameter_sets):\n        self.configure_parameter_set(self.parameter_set_list[i])\n\n    self.write_input_file()\n</code></pre>"},{"location":"api/preproc/long_range_qmc/#oqd_heisenberg_ion.simulators.qmc.long_range.preprocessor.LongRangeQMC.configure_parameter_set","title":"<code>configure_parameter_set</code>","text":"<p>implements the configuration logic for a single parameter set. Parses inputs, creates the parameter set output directory and calls the probability table builder for each parameter set</p> <p>Parameters:</p> <ul> <li> <code>parameter_args</code>               (<code>dict</code>)           \u2013            <p>contains a single unparsed parameter set</p> </li> </ul> Source code in <code>src/oqd_heisenberg_ion/simulators/qmc/long_range/preprocessor.py</code> <pre><code>def configure_parameter_set(self, parameter_args):\n    \"\"\"\n    implements the configuration logic for a single parameter set. Parses inputs, creates the parameter set output directory and\n    calls the probability table builder for each parameter set\n\n    Args:\n        parameter_args (dict): contains a single unparsed parameter set\n    \"\"\"\n\n    input_config = InputParser(**parameter_args)\n    system_args = input_config.simulation_config[\"system\"]\n\n    misc_args = input_config.simulation_config[\"misc\"]\n    run_id = self.get_run_id(misc_args)\n    misc_args[\"uuid\"] = run_id\n    misc_args[\"output_folder_name\"] = self.output_folder_name\n\n    misc_args[\"simulation_folder\"] = self.simulation_folder\n\n    run_folder = self.create_run_folder(misc_args)\n    misc_args[\"run_folder\"] = run_folder\n\n    system = System(**system_args)\n    system_args = system.update_parameters(system_args)\n\n    sampling_args = input_config.simulation_config[\"sampling\"]\n    prob_table_type = sampling_args[\"loop_type\"]\n\n    prob_table_args = ProbabilityTableFactory.extract_args(prob_table_type, **sampling_args)\n    probability_table = ProbabilityTableFactory.create(prob_table_type, system, **prob_table_args)\n    probability_table.write_to_files(run_folder)\n\n    self.processed_configs.append(input_config.simulation_config)\n</code></pre>"},{"location":"api/preproc/long_range_qmc/#oqd_heisenberg_ion.simulators.qmc.long_range.preprocessor.LongRangeQMC.extract_cli_requirements","title":"<code>extract_cli_requirements</code>","text":"<p>prepares the driver inputs by extracting the binary folder and cpp source folder if they are provided. If not provided, attempts to find the source folder in the expected location</p> Source code in <code>src/oqd_heisenberg_ion/simulators/qmc/long_range/preprocessor.py</code> <pre><code>def extract_cli_requirements(self):\n    \"\"\"\n    prepares the driver inputs by extracting the binary folder and cpp source folder if they are provided. If not provided, attempts to find the source folder in the expected location\n    \"\"\"\n\n    bin_folder = self.extract_optional_input(\"bin_folder\", True)\n    cpp_source_folder = self.extract_optional_input(\"cpp_source_folder\", True)\n\n    if bin_folder is None and cpp_source_folder is None:\n        cpp_source_folder = os.path.dirname(os.path.abspath(__file__)) + \"/engine/\"\n\n    self.driver_inputs = {\"bin_folder\": bin_folder, \"cpp_source_folder\": cpp_source_folder}\n</code></pre>"},{"location":"api/preproc/nearest_neighbor_qmc/","title":"Nearest-Neighbor Quantum Monte Carlo","text":""},{"location":"api/preproc/nearest_neighbor_qmc/#oqd_heisenberg_ion.simulators.qmc.nearest_neighbor.preprocessor","title":"<code>oqd_heisenberg_ion.simulators.qmc.nearest_neighbor.preprocessor</code>","text":""},{"location":"api/preproc/nearest_neighbor_qmc/#oqd_heisenberg_ion.simulators.qmc.nearest_neighbor.preprocessor.NearestNeighborQMC","title":"<code>NearestNeighborQMC</code>","text":"<p>               Bases: <code>Preprocessor</code></p> <p>Preprocessor subclass for nearest neighbor QMC. Configures the parameter sets and writes the input file containing the preprocessor updated parameter sets.</p> Source code in <code>src/oqd_heisenberg_ion/simulators/qmc/nearest_neighbor/preprocessor.py</code> <pre><code>class NearestNeighborQMC(Preprocessor):\n    \"\"\"\n    Preprocessor subclass for nearest neighbor QMC. Configures the parameter sets and writes the input file containing the preprocessor updated parameter sets.\n    \"\"\"\n\n    allowed_hamiltonians = {\"afm_heisenberg_fm_Z\", \"XY\", \"fm_heisenberg_fm_Z\"}\n\n    def __init__(self, parameter_set_list):\n        \"\"\"\n        executes the preprocessing logic for nearest neighbor qmc\n\n        Args:\n            parameter_set_list (list[dict]): list of unparsed parameters sets\n        \"\"\"\n\n        super().__init__(parameter_set_list)\n\n        self.driver_inputs = []\n\n    def preprocess(self):\n        \"\"\"\n        configures the input parameter sets for the nearest neighbor qmc calculation,\n        checks that a single root folder is specified, creates the simulation output folder\n        and validates the uuids.\n        \"\"\"\n\n        self.check_single_input(\"root_folder\")\n        self.root_folder = self.parameter_set_list[0][\"root_folder\"]\n\n        self.simulation_folder = self.create_output_folder()\n\n        self.check_unique_uuids()\n\n        self.configure_simulation()\n\n        return self.driver_inputs\n\n    def configure_simulation(self):\n        \"\"\"\n        configures the input parameter sets and writes a tab delimited file containing the configured parameters\n        \"\"\"\n\n        for i in range(self.num_parameter_sets):\n            parameter_set = self.parameter_set_list[i]\n\n            self.configure_parameter_set(parameter_set)\n\n        self.write_input_file()\n\n    def configure_parameter_set(self, parameter_args):\n        \"\"\"\n        configures a single parameter set, specifies and creates the parameter set output folder, defines and validates the system and the sampling parameters for nearest neighbor qmc\n\n        Args:\n            parameter_args (dict): unparsed parameter set\n        \"\"\"\n\n        input_config = InputParser(**parameter_args)\n        system_args = input_config.simulation_config[\"system\"]\n\n        misc_args = input_config.simulation_config[\"misc\"]\n        run_id = self.get_run_id(misc_args)\n        misc_args[\"uuid\"] = run_id\n        misc_args[\"output_folder_name\"] = self.output_folder_name\n\n        misc_args[\"simulation_folder\"] = self.simulation_folder\n\n        run_folder = self.create_run_folder(misc_args)\n        misc_args[\"run_folder\"] = run_folder\n\n        system = System(**system_args)\n        system.geometry.build()\n\n        self.validate_system(system)\n\n        system_args = system.update_parameters(system_args)\n\n        simulation_args = input_config.simulation_config[\"simulation\"]\n        sampling_args = input_config.simulation_config[\"sampling\"]\n        combined_args = simulation_args | sampling_args\n\n        sampling_params = SamplingParameters(**combined_args)\n        sampling_args = sampling_params.update_parameters(sampling_args)\n\n        simulation_parameters = SSEParameters(system, sampling_params, run_folder)\n\n        self.driver_inputs.append(simulation_parameters)\n\n        self.processed_configs.append(input_config.simulation_config)\n\n    def validate_system(self, system):\n        \"\"\"\n        validates the system for nearest neighbor qmc\n\n        Args:\n            system (System): object defining the system to be simulated\n\n        Raises:\n            Exception: if the specified Hamiltonian is not allowed for the nearest neighbor qmc simulator\n            Exception: if the hamiltonian is anti-ferromagnetic and the geometry is not bipartite\n            Exception: if J &lt;= 0 and the hamiltonian is not anti-ferromagnetic\n            Exception: if the interaction range is not nearest neighbor\n        \"\"\"\n\n        if system.model_name not in self.allowed_hamiltonians:\n            raise Exception(\n                \"Unrecognized Hamiltonian name for nearest-neighbor simulator. \"\n                f\"Allowed Hamiltonians are: {self.allowed_hamiltonians}\"\n            )\n\n        if system.model_name == \"afm_heisenberg_fm_Z\":\n            if not system.geometry.bipartite:\n                raise Exception(\"afm_heisenberg_fm_Z Hamiltonian requires a bipartite lattice\\n\")\n\n        if system.hamiltonian_parameters.J &lt;= 0 and system.model_name != \"afm_heisenberg_fm_Z\":\n            raise Exception(\n                \"J sets the energy scale. It must be a positive number for QMC unless the model is afm_heisenberg_fm_Z on a bipartite lattice\\n\"\n            )\n\n        if system.interaction_range != \"nearest_neighbor\":\n            print(system.interaction_range)\n            raise Exception(\"NearestNeighborQMC can only be used for nearest-neighbor interactions\\n\")\n</code></pre>"},{"location":"api/preproc/nearest_neighbor_qmc/#oqd_heisenberg_ion.simulators.qmc.nearest_neighbor.preprocessor.NearestNeighborQMC.__init__","title":"<code>__init__</code>","text":"<p>executes the preprocessing logic for nearest neighbor qmc</p> <p>Parameters:</p> <ul> <li> <code>parameter_set_list</code>               (<code>list[dict]</code>)           \u2013            <p>list of unparsed parameters sets</p> </li> </ul> Source code in <code>src/oqd_heisenberg_ion/simulators/qmc/nearest_neighbor/preprocessor.py</code> <pre><code>def __init__(self, parameter_set_list):\n    \"\"\"\n    executes the preprocessing logic for nearest neighbor qmc\n\n    Args:\n        parameter_set_list (list[dict]): list of unparsed parameters sets\n    \"\"\"\n\n    super().__init__(parameter_set_list)\n\n    self.driver_inputs = []\n</code></pre>"},{"location":"api/preproc/nearest_neighbor_qmc/#oqd_heisenberg_ion.simulators.qmc.nearest_neighbor.preprocessor.NearestNeighborQMC.preprocess","title":"<code>preprocess</code>","text":"<p>configures the input parameter sets for the nearest neighbor qmc calculation, checks that a single root folder is specified, creates the simulation output folder and validates the uuids.</p> Source code in <code>src/oqd_heisenberg_ion/simulators/qmc/nearest_neighbor/preprocessor.py</code> <pre><code>def preprocess(self):\n    \"\"\"\n    configures the input parameter sets for the nearest neighbor qmc calculation,\n    checks that a single root folder is specified, creates the simulation output folder\n    and validates the uuids.\n    \"\"\"\n\n    self.check_single_input(\"root_folder\")\n    self.root_folder = self.parameter_set_list[0][\"root_folder\"]\n\n    self.simulation_folder = self.create_output_folder()\n\n    self.check_unique_uuids()\n\n    self.configure_simulation()\n\n    return self.driver_inputs\n</code></pre>"},{"location":"api/preproc/nearest_neighbor_qmc/#oqd_heisenberg_ion.simulators.qmc.nearest_neighbor.preprocessor.NearestNeighborQMC.configure_simulation","title":"<code>configure_simulation</code>","text":"<p>configures the input parameter sets and writes a tab delimited file containing the configured parameters</p> Source code in <code>src/oqd_heisenberg_ion/simulators/qmc/nearest_neighbor/preprocessor.py</code> <pre><code>def configure_simulation(self):\n    \"\"\"\n    configures the input parameter sets and writes a tab delimited file containing the configured parameters\n    \"\"\"\n\n    for i in range(self.num_parameter_sets):\n        parameter_set = self.parameter_set_list[i]\n\n        self.configure_parameter_set(parameter_set)\n\n    self.write_input_file()\n</code></pre>"},{"location":"api/preproc/nearest_neighbor_qmc/#oqd_heisenberg_ion.simulators.qmc.nearest_neighbor.preprocessor.NearestNeighborQMC.configure_parameter_set","title":"<code>configure_parameter_set</code>","text":"<p>configures a single parameter set, specifies and creates the parameter set output folder, defines and validates the system and the sampling parameters for nearest neighbor qmc</p> <p>Parameters:</p> <ul> <li> <code>parameter_args</code>               (<code>dict</code>)           \u2013            <p>unparsed parameter set</p> </li> </ul> Source code in <code>src/oqd_heisenberg_ion/simulators/qmc/nearest_neighbor/preprocessor.py</code> <pre><code>def configure_parameter_set(self, parameter_args):\n    \"\"\"\n    configures a single parameter set, specifies and creates the parameter set output folder, defines and validates the system and the sampling parameters for nearest neighbor qmc\n\n    Args:\n        parameter_args (dict): unparsed parameter set\n    \"\"\"\n\n    input_config = InputParser(**parameter_args)\n    system_args = input_config.simulation_config[\"system\"]\n\n    misc_args = input_config.simulation_config[\"misc\"]\n    run_id = self.get_run_id(misc_args)\n    misc_args[\"uuid\"] = run_id\n    misc_args[\"output_folder_name\"] = self.output_folder_name\n\n    misc_args[\"simulation_folder\"] = self.simulation_folder\n\n    run_folder = self.create_run_folder(misc_args)\n    misc_args[\"run_folder\"] = run_folder\n\n    system = System(**system_args)\n    system.geometry.build()\n\n    self.validate_system(system)\n\n    system_args = system.update_parameters(system_args)\n\n    simulation_args = input_config.simulation_config[\"simulation\"]\n    sampling_args = input_config.simulation_config[\"sampling\"]\n    combined_args = simulation_args | sampling_args\n\n    sampling_params = SamplingParameters(**combined_args)\n    sampling_args = sampling_params.update_parameters(sampling_args)\n\n    simulation_parameters = SSEParameters(system, sampling_params, run_folder)\n\n    self.driver_inputs.append(simulation_parameters)\n\n    self.processed_configs.append(input_config.simulation_config)\n</code></pre>"},{"location":"api/preproc/nearest_neighbor_qmc/#oqd_heisenberg_ion.simulators.qmc.nearest_neighbor.preprocessor.NearestNeighborQMC.validate_system","title":"<code>validate_system</code>","text":"<p>validates the system for nearest neighbor qmc</p> <p>Parameters:</p> <ul> <li> <code>system</code>               (<code>System</code>)           \u2013            <p>object defining the system to be simulated</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>Exception</code>             \u2013            <p>if the specified Hamiltonian is not allowed for the nearest neighbor qmc simulator</p> </li> <li> <code>Exception</code>             \u2013            <p>if the hamiltonian is anti-ferromagnetic and the geometry is not bipartite</p> </li> <li> <code>Exception</code>             \u2013            <p>if J &lt;= 0 and the hamiltonian is not anti-ferromagnetic</p> </li> <li> <code>Exception</code>             \u2013            <p>if the interaction range is not nearest neighbor</p> </li> </ul> Source code in <code>src/oqd_heisenberg_ion/simulators/qmc/nearest_neighbor/preprocessor.py</code> <pre><code>def validate_system(self, system):\n    \"\"\"\n    validates the system for nearest neighbor qmc\n\n    Args:\n        system (System): object defining the system to be simulated\n\n    Raises:\n        Exception: if the specified Hamiltonian is not allowed for the nearest neighbor qmc simulator\n        Exception: if the hamiltonian is anti-ferromagnetic and the geometry is not bipartite\n        Exception: if J &lt;= 0 and the hamiltonian is not anti-ferromagnetic\n        Exception: if the interaction range is not nearest neighbor\n    \"\"\"\n\n    if system.model_name not in self.allowed_hamiltonians:\n        raise Exception(\n            \"Unrecognized Hamiltonian name for nearest-neighbor simulator. \"\n            f\"Allowed Hamiltonians are: {self.allowed_hamiltonians}\"\n        )\n\n    if system.model_name == \"afm_heisenberg_fm_Z\":\n        if not system.geometry.bipartite:\n            raise Exception(\"afm_heisenberg_fm_Z Hamiltonian requires a bipartite lattice\\n\")\n\n    if system.hamiltonian_parameters.J &lt;= 0 and system.model_name != \"afm_heisenberg_fm_Z\":\n        raise Exception(\n            \"J sets the energy scale. It must be a positive number for QMC unless the model is afm_heisenberg_fm_Z on a bipartite lattice\\n\"\n        )\n\n    if system.interaction_range != \"nearest_neighbor\":\n        print(system.interaction_range)\n        raise Exception(\"NearestNeighborQMC can only be used for nearest-neighbor interactions\\n\")\n</code></pre>"},{"location":"api/preproc/nearest_neighbor_qmc/#oqd_heisenberg_ion.simulators.qmc.nearest_neighbor.preprocess","title":"<code>oqd_heisenberg_ion.simulators.qmc.nearest_neighbor.preprocess</code>","text":""},{"location":"api/preproc/nearest_neighbor_qmc/#oqd_heisenberg_ion.simulators.qmc.nearest_neighbor.preprocess.sampling_params","title":"<code>sampling_params</code>","text":""},{"location":"api/preproc/nearest_neighbor_qmc/#oqd_heisenberg_ion.simulators.qmc.nearest_neighbor.preprocess.sampling_params.SamplingParameters","title":"<code>SamplingParameters</code>","text":"<p>object defining the sampling parameters for nearest-neighbor SSE</p> Source code in <code>src/oqd_heisenberg_ion/simulators/qmc/nearest_neighbor/preprocess/sampling_params.py</code> <pre><code>class SamplingParameters:\n    \"\"\"\n    object defining the sampling parameters for nearest-neighbor SSE\n    \"\"\"\n\n    def __init__(self, **sampling_args):\n        \"\"\"\n        extracts the sampling parameters needed for nearest neighbor QMC. Sets defaults for optional parameters if needed\n\n        Args:\n            **sampling_args (dict): key word arguments that contain the sampling parameters for nearest neighbor QMC\n        \"\"\"\n\n        self.T = sampling_args[\"T\"]\n        self.beta = 1.0 / self.T\n\n        self.equilibration_steps = sampling_args[\"equilibration_steps\"]\n        self.mc_steps = sampling_args[\"simulation_steps\"]\n\n        self.initial_operator_list_size = self.set_optional_parameter(\"initial_operator_list_size\", sampling_args, 50)\n        self.operator_list_update_multiplier = self.set_optional_parameter(\n            \"operator_list_update_multiplier\", sampling_args, 1.25\n        )\n        self.initial_configuration_index = self.set_optional_parameter(\"initial_configuration_index\", sampling_args, 0)\n\n        self.initial_config_seed = self.set_optional_parameter(\"initial_config_seed\", sampling_args, 17951893)\n        self.disconnected_spin_flip_seed = self.set_optional_parameter(\n            \"disconnected_spin_flip_seed\", sampling_args, 674604219\n        )\n        self.off_diagonal_update_seed = self.set_optional_parameter(\n            \"off_diagonal_update_seed\", sampling_args, 961025794\n        )\n        self.metropolis_insert_seed = self.set_optional_parameter(\"metropolis_insert_seed\", sampling_args, 148014634)\n        self.metropolis_remove_seed = self.set_optional_parameter(\"metropolis_remove_seed\", sampling_args, 148014634)\n        self.diagonal_update_seed = self.set_optional_parameter(\"diagonal_update_seed\", sampling_args, 734634223)\n        self.exit_leg_seed = self.set_optional_parameter(\"exit_leg_seed\", sampling_args, 2345346346)\n\n    def set_optional_parameter(self, key, sampling_args, default_val):\n        \"\"\"\n        checks if specified optional sampling parameters for nearest neighbor QMC is provided, if an input is not provided, a default value is returned\n\n        Args:\n            key (str): parameter key\n            sampling_args (dict): user specified key value arguments for parameter set\n            default_val (float): default value of SSE sampling parameter\n\n        Returns:\n            (float): value to be used for parameter specified by key\n        \"\"\"\n\n        if key in sampling_args:\n            var = sampling_args[key]\n        else:\n            var = default_val\n\n        return var\n\n    def update_parameters(self, parameter_dict):\n        \"\"\"\n        updates the parameter dict associated with a parameter set with nearest neighbor SSE parameters\n\n        Returns:\n            (dict): parameter set\n        \"\"\"\n\n        parameter_dict[\"initial_operator_list_size\"] = self.initial_operator_list_size\n        parameter_dict[\"operator_list_update_multiplier\"] = self.operator_list_update_multiplier\n        parameter_dict[\"initial_configuration_index\"] = self.initial_configuration_index\n\n        parameter_dict[\"initial_config_seed\"] = self.initial_config_seed\n        parameter_dict[\"metropolis_insert_seed\"] = self.metropolis_insert_seed\n        parameter_dict[\"metropolis_remove_seed\"] = self.metropolis_remove_seed\n        parameter_dict[\"disconnected_spin_flip_seed\"] = self.disconnected_spin_flip_seed\n        parameter_dict[\"off_diagonal_update_seed\"] = self.off_diagonal_update_seed\n        parameter_dict[\"exit_leg_seed\"] = self.exit_leg_seed\n        parameter_dict[\"diagonal_update_seed\"] = self.diagonal_update_seed\n\n        return parameter_dict\n</code></pre>"},{"location":"api/preproc/nearest_neighbor_qmc/#oqd_heisenberg_ion.simulators.qmc.nearest_neighbor.preprocess.sampling_params.SamplingParameters.__init__","title":"<code>__init__</code>","text":"<p>extracts the sampling parameters needed for nearest neighbor QMC. Sets defaults for optional parameters if needed</p> <p>Parameters:</p> <ul> <li> <code>**sampling_args</code>               (<code>dict</code>, default:                   <code>{}</code> )           \u2013            <p>key word arguments that contain the sampling parameters for nearest neighbor QMC</p> </li> </ul> Source code in <code>src/oqd_heisenberg_ion/simulators/qmc/nearest_neighbor/preprocess/sampling_params.py</code> <pre><code>def __init__(self, **sampling_args):\n    \"\"\"\n    extracts the sampling parameters needed for nearest neighbor QMC. Sets defaults for optional parameters if needed\n\n    Args:\n        **sampling_args (dict): key word arguments that contain the sampling parameters for nearest neighbor QMC\n    \"\"\"\n\n    self.T = sampling_args[\"T\"]\n    self.beta = 1.0 / self.T\n\n    self.equilibration_steps = sampling_args[\"equilibration_steps\"]\n    self.mc_steps = sampling_args[\"simulation_steps\"]\n\n    self.initial_operator_list_size = self.set_optional_parameter(\"initial_operator_list_size\", sampling_args, 50)\n    self.operator_list_update_multiplier = self.set_optional_parameter(\n        \"operator_list_update_multiplier\", sampling_args, 1.25\n    )\n    self.initial_configuration_index = self.set_optional_parameter(\"initial_configuration_index\", sampling_args, 0)\n\n    self.initial_config_seed = self.set_optional_parameter(\"initial_config_seed\", sampling_args, 17951893)\n    self.disconnected_spin_flip_seed = self.set_optional_parameter(\n        \"disconnected_spin_flip_seed\", sampling_args, 674604219\n    )\n    self.off_diagonal_update_seed = self.set_optional_parameter(\n        \"off_diagonal_update_seed\", sampling_args, 961025794\n    )\n    self.metropolis_insert_seed = self.set_optional_parameter(\"metropolis_insert_seed\", sampling_args, 148014634)\n    self.metropolis_remove_seed = self.set_optional_parameter(\"metropolis_remove_seed\", sampling_args, 148014634)\n    self.diagonal_update_seed = self.set_optional_parameter(\"diagonal_update_seed\", sampling_args, 734634223)\n    self.exit_leg_seed = self.set_optional_parameter(\"exit_leg_seed\", sampling_args, 2345346346)\n</code></pre>"},{"location":"api/preproc/nearest_neighbor_qmc/#oqd_heisenberg_ion.simulators.qmc.nearest_neighbor.preprocess.sampling_params.SamplingParameters.set_optional_parameter","title":"<code>set_optional_parameter</code>","text":"<p>checks if specified optional sampling parameters for nearest neighbor QMC is provided, if an input is not provided, a default value is returned</p> <p>Parameters:</p> <ul> <li> <code>key</code>               (<code>str</code>)           \u2013            <p>parameter key</p> </li> <li> <code>sampling_args</code>               (<code>dict</code>)           \u2013            <p>user specified key value arguments for parameter set</p> </li> <li> <code>default_val</code>               (<code>float</code>)           \u2013            <p>default value of SSE sampling parameter</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>float</code>           \u2013            <p>value to be used for parameter specified by key</p> </li> </ul> Source code in <code>src/oqd_heisenberg_ion/simulators/qmc/nearest_neighbor/preprocess/sampling_params.py</code> <pre><code>def set_optional_parameter(self, key, sampling_args, default_val):\n    \"\"\"\n    checks if specified optional sampling parameters for nearest neighbor QMC is provided, if an input is not provided, a default value is returned\n\n    Args:\n        key (str): parameter key\n        sampling_args (dict): user specified key value arguments for parameter set\n        default_val (float): default value of SSE sampling parameter\n\n    Returns:\n        (float): value to be used for parameter specified by key\n    \"\"\"\n\n    if key in sampling_args:\n        var = sampling_args[key]\n    else:\n        var = default_val\n\n    return var\n</code></pre>"},{"location":"api/preproc/nearest_neighbor_qmc/#oqd_heisenberg_ion.simulators.qmc.nearest_neighbor.preprocess.sampling_params.SamplingParameters.update_parameters","title":"<code>update_parameters</code>","text":"<p>updates the parameter dict associated with a parameter set with nearest neighbor SSE parameters</p> <p>Returns:</p> <ul> <li> <code>dict</code>           \u2013            <p>parameter set</p> </li> </ul> Source code in <code>src/oqd_heisenberg_ion/simulators/qmc/nearest_neighbor/preprocess/sampling_params.py</code> <pre><code>def update_parameters(self, parameter_dict):\n    \"\"\"\n    updates the parameter dict associated with a parameter set with nearest neighbor SSE parameters\n\n    Returns:\n        (dict): parameter set\n    \"\"\"\n\n    parameter_dict[\"initial_operator_list_size\"] = self.initial_operator_list_size\n    parameter_dict[\"operator_list_update_multiplier\"] = self.operator_list_update_multiplier\n    parameter_dict[\"initial_configuration_index\"] = self.initial_configuration_index\n\n    parameter_dict[\"initial_config_seed\"] = self.initial_config_seed\n    parameter_dict[\"metropolis_insert_seed\"] = self.metropolis_insert_seed\n    parameter_dict[\"metropolis_remove_seed\"] = self.metropolis_remove_seed\n    parameter_dict[\"disconnected_spin_flip_seed\"] = self.disconnected_spin_flip_seed\n    parameter_dict[\"off_diagonal_update_seed\"] = self.off_diagonal_update_seed\n    parameter_dict[\"exit_leg_seed\"] = self.exit_leg_seed\n    parameter_dict[\"diagonal_update_seed\"] = self.diagonal_update_seed\n\n    return parameter_dict\n</code></pre>"},{"location":"api/preproc/nearest_neighbor_qmc/#oqd_heisenberg_ion.simulators.qmc.nearest_neighbor.preprocess.sampling_params.SSEParameters","title":"<code>SSEParameters</code>","text":"<p>Object to collect all SSE parameters that need to be passed to the nearest neighbor QMC engine</p> Source code in <code>src/oqd_heisenberg_ion/simulators/qmc/nearest_neighbor/preprocess/sampling_params.py</code> <pre><code>class SSEParameters:\n    \"\"\"\n    Object to collect all SSE parameters that need to be passed to the nearest neighbor QMC engine\n    \"\"\"\n\n    def __init__(self, system, sampling_parameters, run_folder):\n\n        self.system = system\n        self.sampling_parameters = sampling_parameters\n\n        self.run_folder = run_folder\n</code></pre>"},{"location":"api/preproc/preprocessor/","title":"Preprocessor Base","text":""},{"location":"api/preproc/preprocessor/#oqd_heisenberg_ion.common.preprocessor","title":"<code>oqd_heisenberg_ion.common.preprocessor</code>","text":""},{"location":"api/preproc/preprocessor/#oqd_heisenberg_ion.common.preprocessor.base","title":"<code>base</code>","text":""},{"location":"api/preproc/preprocessor/#oqd_heisenberg_ion.common.preprocessor.base.Preprocessor","title":"<code>Preprocessor</code>","text":"<p>Preprocessor base class. Handles the preprocessing step before a driver is called Carries a set of keys for which a single value should always be specified. These are: \"root_folder\", \"simulation_folder\", \"number_of_threads\", \"output_folder_name\"</p> <p>Raises:</p> <ul> <li> <code>Exception</code>             \u2013            <p>if a required parameter is not specified</p> </li> <li> <code>Exception</code>             \u2013            <p>if a uuid is repeated</p> </li> <li> <code>Exception</code>             \u2013            <p>if multiple values are provided for a parameter that should have a single value</p> </li> </ul> Source code in <code>src/oqd_heisenberg_ion/common/preprocessor/base.py</code> <pre><code>class Preprocessor:\n    \"\"\"\n    Preprocessor base class. Handles the preprocessing step before a driver is called\n    Carries a set of keys for which a single value should always be specified.\n    These are: \"root_folder\", \"simulation_folder\", \"number_of_threads\", \"output_folder_name\"\n\n    Raises:\n        Exception: if a required parameter is not specified\n        Exception: if a uuid is repeated\n        Exception: if multiple values are provided for a parameter that should have a single value\n    \"\"\"\n\n    keys_single_parameters = {\"root_folder\", \"simulation_folder\", \"number_of_threads\", \"output_folder_name\"}\n\n    def __init__(self, parameter_set_list):\n        \"\"\"\n        constructor for the Preprocessor base class\n\n        Args:\n            parameter_set_list (list[dict]): list of unprocessed parameter sets specified as dicts\n        \"\"\"\n\n        self.parameter_set_list = parameter_set_list\n        self.num_parameter_sets = len(parameter_set_list)\n\n        self.root_folder = None\n        self.simulation_folder = None\n\n        self.driver_inputs = None\n        self.processed_configs = []\n\n    def preprocess(self):\n        \"\"\"\n        Each subclass must implement a preprocess method\n        \"\"\"\n\n        pass\n\n    def create_output_folder(self):\n        \"\"\"\n        creates the output folder to contain the simulation outputs inside the root folder\n\n        Returns:\n            (str): class attribute simulation_folder, the path to the simulation output folder\n        \"\"\"\n\n        output_folder_name_provided = self.check_single_input(\"output_folder_name\", True)\n\n        if output_folder_name_provided:\n            self.output_folder_name = self.parameter_set_list[0][\"output_folder_name\"]\n        else:\n            self.output_folder_name = datetime.now().strftime(\"%Y_%m_%d_%H_%M_%S\")\n\n        self.simulation_folder = os.path.abspath(os.path.join(self.root_folder, self.output_folder_name))\n\n        os.mkdir(self.simulation_folder)\n\n        return self.simulation_folder\n\n    def create_run_folder(self, misc_args):\n        \"\"\"\n        creates the run folder for a given parameter set inside the simulation output folder\n\n        Args:\n            misc_args (dict): contains the key \"uuid\" to specify the run_id corresponding to the associated parameter set\n\n        Returns:\n            (str): path to the parameter set run folder\n        \"\"\"\n\n        simulation_folder = self.simulation_folder\n        run_id = str(misc_args[\"uuid\"])\n        run_folder = os.path.join(simulation_folder, run_id)\n\n        os.mkdir(run_folder)\n\n        return run_folder\n\n    def get_run_id(self, misc_args):\n        \"\"\"\n        Extracts the uuid if specified, and creates one if not specified in the arguments\n\n        Args:\n            misc_args (dict): contains the key \"uuid\" to specify the run_id corresponding to the associated parameter set\n\n        Returns:\n            (str): the uuid associated with the parameter set\n        \"\"\"\n\n        if \"uuid\" in misc_args:\n            run_id = misc_args[\"uuid\"]\n        else:\n            run_id = uuid.uuid4()\n\n        return run_id\n\n    def check_input_provided(self, key, optional=False):\n        \"\"\"\n        checks whether an input has been specified in the parameter set\n\n        Args:\n            key (str): _description_\n            optional (bool, optional): determines whether value associated with key is optional. Defaults to False.\n\n        Raises:\n            Exception: is a required input is not provided\n\n        Returns:\n            (bool): determines whether an input was provided for the given key\n        \"\"\"\n\n        input_provided = key in self.parameter_set_list[0]\n        if not input_provided and not optional:\n            raise Exception(f\"Missing required key: {key}\")\n        else:\n            return input_provided\n\n    def check_unique_uuids(self):\n        \"\"\"\n        checks if multiple uuids are provided and if they are all unique. Does not throw an error if no uuid is provided\n\n        Raises:\n            Exception: if a uuid is repeated\n        \"\"\"\n\n        input_provided = self.check_input_provided(\"uuid\", True)\n        if input_provided:\n            uuid_set = {self.parameter_set_list[i][\"uuid\"] for i in range(self.num_parameter_sets)}\n            if len(uuid_set) != self.num_parameter_sets:\n                raise Exception(\"Specified uuids are not unique\\n\")\n\n    def check_single_input(self, key, optional=False):\n        \"\"\"\n        checks if multiple inputs are provided for a given key if it should have a single input\n\n        Args:\n            key (str): the parameter key\n            optional (bool, optional): specifies if the parameter is optional. Defaults to False.\n\n        Raises:\n            Exception: if multiple inputs provided for a key that should have a single input\n\n        Returns:\n            (bool): determines whether the specified input was provided\n        \"\"\"\n\n        input_provided = self.check_input_provided(key, optional)\n        if input_provided:\n            val = self.parameter_set_list[0][key]\n            for i in range(self.num_parameter_sets):\n                if self.parameter_set_list[i][key] != val:\n                    raise Exception(f\"There should only be one input for key: {key}\")\n\n        return input_provided\n\n    def extract_optional_input(self, key, unique=False):\n        \"\"\"\n        extracts an optional input if provided and return None otherwise\n\n        Args:\n            key (str): parameter key\n            unique (bool, optional): determines if the value needs to be unique. Defaults to False.\n\n        Returns:\n            (str): the value associated with key if provided, otherwise returns None\n        \"\"\"\n\n        if unique:\n            if self.check_single_input(key, True):\n                return self.parameter_set_list[0][key]\n            else:\n                return None\n        else:\n            if self.check_input_provided(key, True):\n                return self.parameter_set_list[0][key]\n            else:\n                return None\n\n    def write_input_file(self):\n        \"\"\"\n        writes a tab-delimited input file for the engine using the parameter set values\n        \"\"\"\n\n        sse_input_file = os.path.join(self.simulation_folder, \"inputs.txt\")\n\n        with open(sse_input_file, \"w\") as f:\n            for param_group_name, param_group in self.processed_configs[0].items():\n                for key in param_group.keys():\n                    text_line = key + \"\\t\" + str(self.processed_configs[0][param_group_name][key])\n                    for i in range(1, self.num_parameter_sets):\n                        if key not in self.keys_single_parameters:\n                            text_line += \",\" + str(self.processed_configs[i][param_group_name][key])\n                    text_line += \"\\n\"\n                    f.write(text_line)\n</code></pre>"},{"location":"api/preproc/preprocessor/#oqd_heisenberg_ion.common.preprocessor.base.Preprocessor.__init__","title":"<code>__init__</code>","text":"<p>constructor for the Preprocessor base class</p> <p>Parameters:</p> <ul> <li> <code>parameter_set_list</code>               (<code>list[dict]</code>)           \u2013            <p>list of unprocessed parameter sets specified as dicts</p> </li> </ul> Source code in <code>src/oqd_heisenberg_ion/common/preprocessor/base.py</code> <pre><code>def __init__(self, parameter_set_list):\n    \"\"\"\n    constructor for the Preprocessor base class\n\n    Args:\n        parameter_set_list (list[dict]): list of unprocessed parameter sets specified as dicts\n    \"\"\"\n\n    self.parameter_set_list = parameter_set_list\n    self.num_parameter_sets = len(parameter_set_list)\n\n    self.root_folder = None\n    self.simulation_folder = None\n\n    self.driver_inputs = None\n    self.processed_configs = []\n</code></pre>"},{"location":"api/preproc/preprocessor/#oqd_heisenberg_ion.common.preprocessor.base.Preprocessor.preprocess","title":"<code>preprocess</code>","text":"<p>Each subclass must implement a preprocess method</p> Source code in <code>src/oqd_heisenberg_ion/common/preprocessor/base.py</code> <pre><code>def preprocess(self):\n    \"\"\"\n    Each subclass must implement a preprocess method\n    \"\"\"\n\n    pass\n</code></pre>"},{"location":"api/preproc/preprocessor/#oqd_heisenberg_ion.common.preprocessor.base.Preprocessor.create_output_folder","title":"<code>create_output_folder</code>","text":"<p>creates the output folder to contain the simulation outputs inside the root folder</p> <p>Returns:</p> <ul> <li> <code>str</code>           \u2013            <p>class attribute simulation_folder, the path to the simulation output folder</p> </li> </ul> Source code in <code>src/oqd_heisenberg_ion/common/preprocessor/base.py</code> <pre><code>def create_output_folder(self):\n    \"\"\"\n    creates the output folder to contain the simulation outputs inside the root folder\n\n    Returns:\n        (str): class attribute simulation_folder, the path to the simulation output folder\n    \"\"\"\n\n    output_folder_name_provided = self.check_single_input(\"output_folder_name\", True)\n\n    if output_folder_name_provided:\n        self.output_folder_name = self.parameter_set_list[0][\"output_folder_name\"]\n    else:\n        self.output_folder_name = datetime.now().strftime(\"%Y_%m_%d_%H_%M_%S\")\n\n    self.simulation_folder = os.path.abspath(os.path.join(self.root_folder, self.output_folder_name))\n\n    os.mkdir(self.simulation_folder)\n\n    return self.simulation_folder\n</code></pre>"},{"location":"api/preproc/preprocessor/#oqd_heisenberg_ion.common.preprocessor.base.Preprocessor.create_run_folder","title":"<code>create_run_folder</code>","text":"<p>creates the run folder for a given parameter set inside the simulation output folder</p> <p>Parameters:</p> <ul> <li> <code>misc_args</code>               (<code>dict</code>)           \u2013            <p>contains the key \"uuid\" to specify the run_id corresponding to the associated parameter set</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>str</code>           \u2013            <p>path to the parameter set run folder</p> </li> </ul> Source code in <code>src/oqd_heisenberg_ion/common/preprocessor/base.py</code> <pre><code>def create_run_folder(self, misc_args):\n    \"\"\"\n    creates the run folder for a given parameter set inside the simulation output folder\n\n    Args:\n        misc_args (dict): contains the key \"uuid\" to specify the run_id corresponding to the associated parameter set\n\n    Returns:\n        (str): path to the parameter set run folder\n    \"\"\"\n\n    simulation_folder = self.simulation_folder\n    run_id = str(misc_args[\"uuid\"])\n    run_folder = os.path.join(simulation_folder, run_id)\n\n    os.mkdir(run_folder)\n\n    return run_folder\n</code></pre>"},{"location":"api/preproc/preprocessor/#oqd_heisenberg_ion.common.preprocessor.base.Preprocessor.get_run_id","title":"<code>get_run_id</code>","text":"<p>Extracts the uuid if specified, and creates one if not specified in the arguments</p> <p>Parameters:</p> <ul> <li> <code>misc_args</code>               (<code>dict</code>)           \u2013            <p>contains the key \"uuid\" to specify the run_id corresponding to the associated parameter set</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>str</code>           \u2013            <p>the uuid associated with the parameter set</p> </li> </ul> Source code in <code>src/oqd_heisenberg_ion/common/preprocessor/base.py</code> <pre><code>def get_run_id(self, misc_args):\n    \"\"\"\n    Extracts the uuid if specified, and creates one if not specified in the arguments\n\n    Args:\n        misc_args (dict): contains the key \"uuid\" to specify the run_id corresponding to the associated parameter set\n\n    Returns:\n        (str): the uuid associated with the parameter set\n    \"\"\"\n\n    if \"uuid\" in misc_args:\n        run_id = misc_args[\"uuid\"]\n    else:\n        run_id = uuid.uuid4()\n\n    return run_id\n</code></pre>"},{"location":"api/preproc/preprocessor/#oqd_heisenberg_ion.common.preprocessor.base.Preprocessor.check_input_provided","title":"<code>check_input_provided</code>","text":"<p>checks whether an input has been specified in the parameter set</p> <p>Parameters:</p> <ul> <li> <code>key</code>               (<code>str</code>)           \u2013            <p>description</p> </li> <li> <code>optional</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>determines whether value associated with key is optional. Defaults to False.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>Exception</code>             \u2013            <p>is a required input is not provided</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>bool</code>           \u2013            <p>determines whether an input was provided for the given key</p> </li> </ul> Source code in <code>src/oqd_heisenberg_ion/common/preprocessor/base.py</code> <pre><code>def check_input_provided(self, key, optional=False):\n    \"\"\"\n    checks whether an input has been specified in the parameter set\n\n    Args:\n        key (str): _description_\n        optional (bool, optional): determines whether value associated with key is optional. Defaults to False.\n\n    Raises:\n        Exception: is a required input is not provided\n\n    Returns:\n        (bool): determines whether an input was provided for the given key\n    \"\"\"\n\n    input_provided = key in self.parameter_set_list[0]\n    if not input_provided and not optional:\n        raise Exception(f\"Missing required key: {key}\")\n    else:\n        return input_provided\n</code></pre>"},{"location":"api/preproc/preprocessor/#oqd_heisenberg_ion.common.preprocessor.base.Preprocessor.check_unique_uuids","title":"<code>check_unique_uuids</code>","text":"<p>checks if multiple uuids are provided and if they are all unique. Does not throw an error if no uuid is provided</p> <p>Raises:</p> <ul> <li> <code>Exception</code>             \u2013            <p>if a uuid is repeated</p> </li> </ul> Source code in <code>src/oqd_heisenberg_ion/common/preprocessor/base.py</code> <pre><code>def check_unique_uuids(self):\n    \"\"\"\n    checks if multiple uuids are provided and if they are all unique. Does not throw an error if no uuid is provided\n\n    Raises:\n        Exception: if a uuid is repeated\n    \"\"\"\n\n    input_provided = self.check_input_provided(\"uuid\", True)\n    if input_provided:\n        uuid_set = {self.parameter_set_list[i][\"uuid\"] for i in range(self.num_parameter_sets)}\n        if len(uuid_set) != self.num_parameter_sets:\n            raise Exception(\"Specified uuids are not unique\\n\")\n</code></pre>"},{"location":"api/preproc/preprocessor/#oqd_heisenberg_ion.common.preprocessor.base.Preprocessor.check_single_input","title":"<code>check_single_input</code>","text":"<p>checks if multiple inputs are provided for a given key if it should have a single input</p> <p>Parameters:</p> <ul> <li> <code>key</code>               (<code>str</code>)           \u2013            <p>the parameter key</p> </li> <li> <code>optional</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>specifies if the parameter is optional. Defaults to False.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>Exception</code>             \u2013            <p>if multiple inputs provided for a key that should have a single input</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>bool</code>           \u2013            <p>determines whether the specified input was provided</p> </li> </ul> Source code in <code>src/oqd_heisenberg_ion/common/preprocessor/base.py</code> <pre><code>def check_single_input(self, key, optional=False):\n    \"\"\"\n    checks if multiple inputs are provided for a given key if it should have a single input\n\n    Args:\n        key (str): the parameter key\n        optional (bool, optional): specifies if the parameter is optional. Defaults to False.\n\n    Raises:\n        Exception: if multiple inputs provided for a key that should have a single input\n\n    Returns:\n        (bool): determines whether the specified input was provided\n    \"\"\"\n\n    input_provided = self.check_input_provided(key, optional)\n    if input_provided:\n        val = self.parameter_set_list[0][key]\n        for i in range(self.num_parameter_sets):\n            if self.parameter_set_list[i][key] != val:\n                raise Exception(f\"There should only be one input for key: {key}\")\n\n    return input_provided\n</code></pre>"},{"location":"api/preproc/preprocessor/#oqd_heisenberg_ion.common.preprocessor.base.Preprocessor.extract_optional_input","title":"<code>extract_optional_input</code>","text":"<p>extracts an optional input if provided and return None otherwise</p> <p>Parameters:</p> <ul> <li> <code>key</code>               (<code>str</code>)           \u2013            <p>parameter key</p> </li> <li> <code>unique</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>determines if the value needs to be unique. Defaults to False.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>str</code>           \u2013            <p>the value associated with key if provided, otherwise returns None</p> </li> </ul> Source code in <code>src/oqd_heisenberg_ion/common/preprocessor/base.py</code> <pre><code>def extract_optional_input(self, key, unique=False):\n    \"\"\"\n    extracts an optional input if provided and return None otherwise\n\n    Args:\n        key (str): parameter key\n        unique (bool, optional): determines if the value needs to be unique. Defaults to False.\n\n    Returns:\n        (str): the value associated with key if provided, otherwise returns None\n    \"\"\"\n\n    if unique:\n        if self.check_single_input(key, True):\n            return self.parameter_set_list[0][key]\n        else:\n            return None\n    else:\n        if self.check_input_provided(key, True):\n            return self.parameter_set_list[0][key]\n        else:\n            return None\n</code></pre>"},{"location":"api/preproc/preprocessor/#oqd_heisenberg_ion.common.preprocessor.base.Preprocessor.write_input_file","title":"<code>write_input_file</code>","text":"<p>writes a tab-delimited input file for the engine using the parameter set values</p> Source code in <code>src/oqd_heisenberg_ion/common/preprocessor/base.py</code> <pre><code>def write_input_file(self):\n    \"\"\"\n    writes a tab-delimited input file for the engine using the parameter set values\n    \"\"\"\n\n    sse_input_file = os.path.join(self.simulation_folder, \"inputs.txt\")\n\n    with open(sse_input_file, \"w\") as f:\n        for param_group_name, param_group in self.processed_configs[0].items():\n            for key in param_group.keys():\n                text_line = key + \"\\t\" + str(self.processed_configs[0][param_group_name][key])\n                for i in range(1, self.num_parameter_sets):\n                    if key not in self.keys_single_parameters:\n                        text_line += \",\" + str(self.processed_configs[i][param_group_name][key])\n                text_line += \"\\n\"\n                f.write(text_line)\n</code></pre>"},{"location":"api/preproc/preprocessor/#oqd_heisenberg_ion.common.preprocessor.factory","title":"<code>factory</code>","text":""},{"location":"api/preproc/preprocessor/#oqd_heisenberg_ion.common.preprocessor.factory.PreprocessorFactory","title":"<code>PreprocessorFactory</code>","text":"<p>Factory for generating the required instance of the Preprocessor subclass. Carries a registry of Preprocessor subclasses</p> <p>Raises:</p> <ul> <li> <code>Exception</code>             \u2013            <p>if requested subclass is not found</p> </li> </ul> Source code in <code>src/oqd_heisenberg_ion/common/preprocessor/factory.py</code> <pre><code>class PreprocessorFactory:\n    \"\"\"\n    Factory for generating the required instance of the Preprocessor subclass. Carries a registry of Preprocessor subclasses\n\n    Raises:\n        Exception: if requested subclass is not found\n    \"\"\"\n\n    registry = {}\n\n    def register(cls, name, subclass):\n        \"\"\"\n        registers the specified subclass with the given name in the factory\n\n        Args:\n            name (str): name to be used while registering the specified subclass\n            subclass (Type[Preprocessor]): the subclass of preprocessor to be registered\n        \"\"\"\n\n        cls.registry[name] = subclass\n\n    def create(cls, name, parameter_set_list):\n        \"\"\"\n        creates an instance of the requested subclass\n\n        Args:\n            name (str): requested subclass name\n            parameter_set_list (list[dict]): list of parameter sets, each set specified as a dict, needed by the preprocessor constructor\n\n        Raises:\n            Exception: if requested Preprocessor subclass is not found\n\n        Returns:\n            (Preprocessor): instance of Preprocessor subclass requested\n        \"\"\"\n\n        if name not in cls.registry:\n            raise Exception(f\"Preprocessor implementation not found for name: {name}\")\n        else:\n            return cls.registry[name](parameter_set_list)\n</code></pre>"},{"location":"api/preproc/preprocessor/#oqd_heisenberg_ion.common.preprocessor.factory.PreprocessorFactory.register","title":"<code>register</code>","text":"<p>registers the specified subclass with the given name in the factory</p> <p>Parameters:</p> <ul> <li> <code>name</code>               (<code>str</code>)           \u2013            <p>name to be used while registering the specified subclass</p> </li> <li> <code>subclass</code>               (<code>Type[Preprocessor]</code>)           \u2013            <p>the subclass of preprocessor to be registered</p> </li> </ul> Source code in <code>src/oqd_heisenberg_ion/common/preprocessor/factory.py</code> <pre><code>def register(cls, name, subclass):\n    \"\"\"\n    registers the specified subclass with the given name in the factory\n\n    Args:\n        name (str): name to be used while registering the specified subclass\n        subclass (Type[Preprocessor]): the subclass of preprocessor to be registered\n    \"\"\"\n\n    cls.registry[name] = subclass\n</code></pre>"},{"location":"api/preproc/preprocessor/#oqd_heisenberg_ion.common.preprocessor.factory.PreprocessorFactory.create","title":"<code>create</code>","text":"<p>creates an instance of the requested subclass</p> <p>Parameters:</p> <ul> <li> <code>name</code>               (<code>str</code>)           \u2013            <p>requested subclass name</p> </li> <li> <code>parameter_set_list</code>               (<code>list[dict]</code>)           \u2013            <p>list of parameter sets, each set specified as a dict, needed by the preprocessor constructor</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>Exception</code>             \u2013            <p>if requested Preprocessor subclass is not found</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Preprocessor</code>           \u2013            <p>instance of Preprocessor subclass requested</p> </li> </ul> Source code in <code>src/oqd_heisenberg_ion/common/preprocessor/factory.py</code> <pre><code>def create(cls, name, parameter_set_list):\n    \"\"\"\n    creates an instance of the requested subclass\n\n    Args:\n        name (str): requested subclass name\n        parameter_set_list (list[dict]): list of parameter sets, each set specified as a dict, needed by the preprocessor constructor\n\n    Raises:\n        Exception: if requested Preprocessor subclass is not found\n\n    Returns:\n        (Preprocessor): instance of Preprocessor subclass requested\n    \"\"\"\n\n    if name not in cls.registry:\n        raise Exception(f\"Preprocessor implementation not found for name: {name}\")\n    else:\n        return cls.registry[name](parameter_set_list)\n</code></pre>"},{"location":"api/preproc/probability_tables/","title":"Probability Tables","text":""},{"location":"api/preproc/probability_tables/#oqd_heisenberg_ion.simulators.qmc.long_range.preprocess","title":"<code>oqd_heisenberg_ion.simulators.qmc.long_range.preprocess</code>","text":""},{"location":"api/preproc/probability_tables/#oqd_heisenberg_ion.simulators.qmc.long_range.preprocess.probability_table","title":"<code>probability_table</code>","text":""},{"location":"api/preproc/probability_tables/#oqd_heisenberg_ion.simulators.qmc.long_range.preprocess.probability_table.base","title":"<code>base</code>","text":""},{"location":"api/preproc/probability_tables/#oqd_heisenberg_ion.simulators.qmc.long_range.preprocess.probability_table.base.ProbabilityTable","title":"<code>ProbabilityTable</code>","text":"<p>ProbabilityTable base class to generate probability table files</p> Source code in <code>src/oqd_heisenberg_ion/simulators/qmc/long_range/preprocess/probability_table/base.py</code> <pre><code>class ProbabilityTable:\n    \"\"\"ProbabilityTable base class to generate probability table files\"\"\"\n\n    args = {}\n\n    def __init__(self, system, **sampling_args):\n        \"\"\"\n        constructor builds the geometry and sets the base member variables\n\n        Args:\n            system (System): object representing the system to be simulated\n            **sampling_args (dict): key word arguments specifying the sampling parameters\n        \"\"\"\n\n        self.system = system\n        self.system.geometry.build()\n\n        self.sampling_parameters = sampling_args\n\n        self.spectrum_offset = None\n        self.max_diag_norm = None\n        self.max_over_states = None\n\n    def validate_system(self):\n        \"\"\"\n        validates the system associated with the ProbabilityTable object\n\n        Raises:\n            Exception: if geometry is not long range, since probability tables are only required for long range geometries\n            Exception: if the energy scale J is less than zero since that can result in negative probabilities\n        \"\"\"\n\n        if not self.system.geometry.interaction_range == \"long_range\":\n            raise Exception(\"Probability tables are constructed for long range systems\\n\")\n\n        if self.system.hamiltonian_parameters.J &lt;= 0:\n            raise Exception(\"J sets the energy scale. It must be positive for long-range QMC\")\n        pass\n\n    def build(self):\n        \"\"\"\n        each ProbabilityTable subclass must implement a build method to populate tables\n        \"\"\"\n        pass\n\n    def write_to_files(self, out_dir):\n        \"\"\"\n        makes the directories required for writing probability tables. Writing logic owned by subclasses\n\n        Args:\n            out_dir (str): directory path for probability tables\n        \"\"\"\n\n        self.out_dir = out_dir\n        self.prob_dir = os.path.join(self.out_dir, \"probability_densities/\")\n        os.makedirs(self.prob_dir)\n</code></pre>"},{"location":"api/preproc/probability_tables/#oqd_heisenberg_ion.simulators.qmc.long_range.preprocess.probability_table.base.ProbabilityTable.__init__","title":"<code>__init__</code>","text":"<p>constructor builds the geometry and sets the base member variables</p> <p>Parameters:</p> <ul> <li> <code>system</code>               (<code>System</code>)           \u2013            <p>object representing the system to be simulated</p> </li> <li> <code>**sampling_args</code>               (<code>dict</code>, default:                   <code>{}</code> )           \u2013            <p>key word arguments specifying the sampling parameters</p> </li> </ul> Source code in <code>src/oqd_heisenberg_ion/simulators/qmc/long_range/preprocess/probability_table/base.py</code> <pre><code>def __init__(self, system, **sampling_args):\n    \"\"\"\n    constructor builds the geometry and sets the base member variables\n\n    Args:\n        system (System): object representing the system to be simulated\n        **sampling_args (dict): key word arguments specifying the sampling parameters\n    \"\"\"\n\n    self.system = system\n    self.system.geometry.build()\n\n    self.sampling_parameters = sampling_args\n\n    self.spectrum_offset = None\n    self.max_diag_norm = None\n    self.max_over_states = None\n</code></pre>"},{"location":"api/preproc/probability_tables/#oqd_heisenberg_ion.simulators.qmc.long_range.preprocess.probability_table.base.ProbabilityTable.validate_system","title":"<code>validate_system</code>","text":"<p>validates the system associated with the ProbabilityTable object</p> <p>Raises:</p> <ul> <li> <code>Exception</code>             \u2013            <p>if geometry is not long range, since probability tables are only required for long range geometries</p> </li> <li> <code>Exception</code>             \u2013            <p>if the energy scale J is less than zero since that can result in negative probabilities</p> </li> </ul> Source code in <code>src/oqd_heisenberg_ion/simulators/qmc/long_range/preprocess/probability_table/base.py</code> <pre><code>def validate_system(self):\n    \"\"\"\n    validates the system associated with the ProbabilityTable object\n\n    Raises:\n        Exception: if geometry is not long range, since probability tables are only required for long range geometries\n        Exception: if the energy scale J is less than zero since that can result in negative probabilities\n    \"\"\"\n\n    if not self.system.geometry.interaction_range == \"long_range\":\n        raise Exception(\"Probability tables are constructed for long range systems\\n\")\n\n    if self.system.hamiltonian_parameters.J &lt;= 0:\n        raise Exception(\"J sets the energy scale. It must be positive for long-range QMC\")\n    pass\n</code></pre>"},{"location":"api/preproc/probability_tables/#oqd_heisenberg_ion.simulators.qmc.long_range.preprocess.probability_table.base.ProbabilityTable.build","title":"<code>build</code>","text":"<p>each ProbabilityTable subclass must implement a build method to populate tables</p> Source code in <code>src/oqd_heisenberg_ion/simulators/qmc/long_range/preprocess/probability_table/base.py</code> <pre><code>def build(self):\n    \"\"\"\n    each ProbabilityTable subclass must implement a build method to populate tables\n    \"\"\"\n    pass\n</code></pre>"},{"location":"api/preproc/probability_tables/#oqd_heisenberg_ion.simulators.qmc.long_range.preprocess.probability_table.base.ProbabilityTable.write_to_files","title":"<code>write_to_files</code>","text":"<p>makes the directories required for writing probability tables. Writing logic owned by subclasses</p> <p>Parameters:</p> <ul> <li> <code>out_dir</code>               (<code>str</code>)           \u2013            <p>directory path for probability tables</p> </li> </ul> Source code in <code>src/oqd_heisenberg_ion/simulators/qmc/long_range/preprocess/probability_table/base.py</code> <pre><code>def write_to_files(self, out_dir):\n    \"\"\"\n    makes the directories required for writing probability tables. Writing logic owned by subclasses\n\n    Args:\n        out_dir (str): directory path for probability tables\n    \"\"\"\n\n    self.out_dir = out_dir\n    self.prob_dir = os.path.join(self.out_dir, \"probability_densities/\")\n    os.makedirs(self.prob_dir)\n</code></pre>"},{"location":"api/preproc/probability_tables/#oqd_heisenberg_ion.simulators.qmc.long_range.preprocess.probability_table.deterministic","title":"<code>deterministic</code>","text":""},{"location":"api/preproc/probability_tables/#oqd_heisenberg_ion.simulators.qmc.long_range.preprocess.probability_table.deterministic.Deterministic","title":"<code>Deterministic</code>","text":"<p>               Bases: <code>ProbabilityTable</code></p> <p>ProbabilityTable subclass for deterministic sampling</p> <p>Raises:</p> <ul> <li> <code>Exception</code>             \u2013            <p>raised if deterministic probability tables are requested for an unsupported hamiltonian type</p> </li> <li> <code>ValueError</code>             \u2013            <p>raised if the spectrum offset is requested but the hamiltonian type is not consistent with sampling type</p> </li> </ul> Source code in <code>src/oqd_heisenberg_ion/simulators/qmc/long_range/preprocess/probability_table/deterministic.py</code> <pre><code>class Deterministic(ProbabilityTable):\n    \"\"\"\n    ProbabilityTable subclass for deterministic sampling\n\n    Raises:\n        Exception: raised if deterministic probability tables are requested for an unsupported hamiltonian type\n        ValueError: raised if the spectrum offset is requested but the hamiltonian type is not consistent with sampling type\n    \"\"\"\n\n    args = {}\n    allowed_hamiltonians = {\"XY\", \"fm_heisenberg_afm_Z\", \"fm_heisenberg_fm_Z\"}\n\n    def __init__(self, system):\n        \"\"\"\n        validates inputs and constructs the probability tables\n\n        Args:\n            system (System): object representing the system to be simulated\n        \"\"\"\n\n        super().__init__(system)\n\n        self.validate_system()\n\n        self.build()\n\n    def validate_system(self):\n        \"\"\"\n        validates the system associated with the ProbabilityTable instance\n\n        Raises:\n            Exception: if hamiltonian name does not match the allowed hamiltonians for deterministic sampling\n        \"\"\"\n\n        super().validate_system()\n\n        hamiltonian_name = self.system.hamiltonian_parameters.hamiltonian_name\n\n        if hamiltonian_name not in self.allowed_hamiltonians:\n            raise Exception(\n                \"Inconsistent hamiltonian and sampling types. Deterministic probability tables \"\n                \"only support the following types: {}\".format(self.allowed_hamiltonians)\n            )\n\n    def build(self):\n        \"\"\"\n        populates the probability tables for deterministic sampling\n        \"\"\"\n\n        self.compute_max_over_states(self.system.geometry.num_bonds, self.system.interactions.J_ij_vector)\n        self.compute_spectrum_offset(self.system.hamiltonian_parameters.hamiltonian_name)\n\n    def compute_spectrum_offset(self, hamiltonian_name):\n        \"\"\"\n        computes the spectrum offset associated with the hamiltonian for SSE\n\n        Args:\n            hamiltonian_name (str): represents the name of the Hamiltonian\n\n        Raises:\n            ValueError: if the spectrum is requested and the Hamiltonian can not be used with deterministic sampling\n        \"\"\"\n\n        if hamiltonian_name == \"XY\":\n            self.spectrum_offset = self.max_diag_norm\n        elif hamiltonian_name == \"fm_heisenberg_afm_Z\" or hamiltonian_name == \"fm_heisenberg_fm_Z\":\n            self.spectrum_offset = 0.5 * self.max_diag_norm\n        else:\n            raise ValueError(\n                \"Invalid Hamiltonian type: {} provided for deterministic probability tables. \"\n                \"Allowed types are {}\".format(hamiltonian_name, self.allowed_hamiltonians)\n            )\n\n    def compute_max_over_states(self, num_bonds, J_ij_vector):\n        \"\"\"\n        computes the max norm probability table required for diagonal updates in the two-step method.\n        See: https://scipost.org/submissions/2107.00766v1/ and https://journals.aps.org/pre/abstract/10.1103/PhysRevE.66.046701 for details\n\n        Args:\n            num_bonds (int): number of interacting bonds in the lattice\n            J_ij_vector (numpy.ndarray[float]): num_bonds x 1 array containing the coupling strengths\n        \"\"\"\n\n        max_over_states = np.zeros(num_bonds)\n        max_diag_norm = 0.0\n\n        for bond in range(num_bonds):\n            J_ij = J_ij_vector[bond]\n            max_over_states[bond] = 0.5 * J_ij\n\n            max_diag_norm += 0.5 * J_ij\n\n        self.max_over_states = max_over_states / max_diag_norm\n        self.max_diag_norm = max_diag_norm\n\n    def write_to_files(self, out_dir):\n        \"\"\"\n        writes the probability tables to files for deterministic sampling\n\n        Args:\n            out_dir (str): file path for writing probability tables\n        \"\"\"\n\n        super().write_to_files(out_dir)\n\n        geometry_file_name = os.path.join(self.prob_dir, \"geometry.csv\")\n        max_over_states_file_name = os.path.join(self.prob_dir, \"max_over_states.csv\")\n\n        geometry_table = self.system.geometry.geometry_table\n        num_bonds = self.system.geometry.num_bonds\n\n        np.savetxt(geometry_file_name, geometry_table, delimiter=\",\", fmt=\"%d\", header=\"NumBonds={}\".format(num_bonds))\n\n        header = \"norm={},spectrum_offset={},loop_update_type={}\".format(\n            self.max_diag_norm, self.spectrum_offset, \"deterministic\"\n        )\n\n        np.savetxt(max_over_states_file_name, self.max_over_states, delimiter=\",\", header=header)\n</code></pre>"},{"location":"api/preproc/probability_tables/#oqd_heisenberg_ion.simulators.qmc.long_range.preprocess.probability_table.deterministic.Deterministic.__init__","title":"<code>__init__</code>","text":"<p>validates inputs and constructs the probability tables</p> <p>Parameters:</p> <ul> <li> <code>system</code>               (<code>System</code>)           \u2013            <p>object representing the system to be simulated</p> </li> </ul> Source code in <code>src/oqd_heisenberg_ion/simulators/qmc/long_range/preprocess/probability_table/deterministic.py</code> <pre><code>def __init__(self, system):\n    \"\"\"\n    validates inputs and constructs the probability tables\n\n    Args:\n        system (System): object representing the system to be simulated\n    \"\"\"\n\n    super().__init__(system)\n\n    self.validate_system()\n\n    self.build()\n</code></pre>"},{"location":"api/preproc/probability_tables/#oqd_heisenberg_ion.simulators.qmc.long_range.preprocess.probability_table.deterministic.Deterministic.validate_system","title":"<code>validate_system</code>","text":"<p>validates the system associated with the ProbabilityTable instance</p> <p>Raises:</p> <ul> <li> <code>Exception</code>             \u2013            <p>if hamiltonian name does not match the allowed hamiltonians for deterministic sampling</p> </li> </ul> Source code in <code>src/oqd_heisenberg_ion/simulators/qmc/long_range/preprocess/probability_table/deterministic.py</code> <pre><code>def validate_system(self):\n    \"\"\"\n    validates the system associated with the ProbabilityTable instance\n\n    Raises:\n        Exception: if hamiltonian name does not match the allowed hamiltonians for deterministic sampling\n    \"\"\"\n\n    super().validate_system()\n\n    hamiltonian_name = self.system.hamiltonian_parameters.hamiltonian_name\n\n    if hamiltonian_name not in self.allowed_hamiltonians:\n        raise Exception(\n            \"Inconsistent hamiltonian and sampling types. Deterministic probability tables \"\n            \"only support the following types: {}\".format(self.allowed_hamiltonians)\n        )\n</code></pre>"},{"location":"api/preproc/probability_tables/#oqd_heisenberg_ion.simulators.qmc.long_range.preprocess.probability_table.deterministic.Deterministic.build","title":"<code>build</code>","text":"<p>populates the probability tables for deterministic sampling</p> Source code in <code>src/oqd_heisenberg_ion/simulators/qmc/long_range/preprocess/probability_table/deterministic.py</code> <pre><code>def build(self):\n    \"\"\"\n    populates the probability tables for deterministic sampling\n    \"\"\"\n\n    self.compute_max_over_states(self.system.geometry.num_bonds, self.system.interactions.J_ij_vector)\n    self.compute_spectrum_offset(self.system.hamiltonian_parameters.hamiltonian_name)\n</code></pre>"},{"location":"api/preproc/probability_tables/#oqd_heisenberg_ion.simulators.qmc.long_range.preprocess.probability_table.deterministic.Deterministic.compute_spectrum_offset","title":"<code>compute_spectrum_offset</code>","text":"<p>computes the spectrum offset associated with the hamiltonian for SSE</p> <p>Parameters:</p> <ul> <li> <code>hamiltonian_name</code>               (<code>str</code>)           \u2013            <p>represents the name of the Hamiltonian</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>ValueError</code>             \u2013            <p>if the spectrum is requested and the Hamiltonian can not be used with deterministic sampling</p> </li> </ul> Source code in <code>src/oqd_heisenberg_ion/simulators/qmc/long_range/preprocess/probability_table/deterministic.py</code> <pre><code>def compute_spectrum_offset(self, hamiltonian_name):\n    \"\"\"\n    computes the spectrum offset associated with the hamiltonian for SSE\n\n    Args:\n        hamiltonian_name (str): represents the name of the Hamiltonian\n\n    Raises:\n        ValueError: if the spectrum is requested and the Hamiltonian can not be used with deterministic sampling\n    \"\"\"\n\n    if hamiltonian_name == \"XY\":\n        self.spectrum_offset = self.max_diag_norm\n    elif hamiltonian_name == \"fm_heisenberg_afm_Z\" or hamiltonian_name == \"fm_heisenberg_fm_Z\":\n        self.spectrum_offset = 0.5 * self.max_diag_norm\n    else:\n        raise ValueError(\n            \"Invalid Hamiltonian type: {} provided for deterministic probability tables. \"\n            \"Allowed types are {}\".format(hamiltonian_name, self.allowed_hamiltonians)\n        )\n</code></pre>"},{"location":"api/preproc/probability_tables/#oqd_heisenberg_ion.simulators.qmc.long_range.preprocess.probability_table.deterministic.Deterministic.compute_max_over_states","title":"<code>compute_max_over_states</code>","text":"<p>computes the max norm probability table required for diagonal updates in the two-step method. See: https://scipost.org/submissions/2107.00766v1/ and https://journals.aps.org/pre/abstract/10.1103/PhysRevE.66.046701 for details</p> <p>Parameters:</p> <ul> <li> <code>num_bonds</code>               (<code>int</code>)           \u2013            <p>number of interacting bonds in the lattice</p> </li> <li> <code>J_ij_vector</code>               (<code>ndarray[float]</code>)           \u2013            <p>num_bonds x 1 array containing the coupling strengths</p> </li> </ul> Source code in <code>src/oqd_heisenberg_ion/simulators/qmc/long_range/preprocess/probability_table/deterministic.py</code> <pre><code>def compute_max_over_states(self, num_bonds, J_ij_vector):\n    \"\"\"\n    computes the max norm probability table required for diagonal updates in the two-step method.\n    See: https://scipost.org/submissions/2107.00766v1/ and https://journals.aps.org/pre/abstract/10.1103/PhysRevE.66.046701 for details\n\n    Args:\n        num_bonds (int): number of interacting bonds in the lattice\n        J_ij_vector (numpy.ndarray[float]): num_bonds x 1 array containing the coupling strengths\n    \"\"\"\n\n    max_over_states = np.zeros(num_bonds)\n    max_diag_norm = 0.0\n\n    for bond in range(num_bonds):\n        J_ij = J_ij_vector[bond]\n        max_over_states[bond] = 0.5 * J_ij\n\n        max_diag_norm += 0.5 * J_ij\n\n    self.max_over_states = max_over_states / max_diag_norm\n    self.max_diag_norm = max_diag_norm\n</code></pre>"},{"location":"api/preproc/probability_tables/#oqd_heisenberg_ion.simulators.qmc.long_range.preprocess.probability_table.deterministic.Deterministic.write_to_files","title":"<code>write_to_files</code>","text":"<p>writes the probability tables to files for deterministic sampling</p> <p>Parameters:</p> <ul> <li> <code>out_dir</code>               (<code>str</code>)           \u2013            <p>file path for writing probability tables</p> </li> </ul> Source code in <code>src/oqd_heisenberg_ion/simulators/qmc/long_range/preprocess/probability_table/deterministic.py</code> <pre><code>def write_to_files(self, out_dir):\n    \"\"\"\n    writes the probability tables to files for deterministic sampling\n\n    Args:\n        out_dir (str): file path for writing probability tables\n    \"\"\"\n\n    super().write_to_files(out_dir)\n\n    geometry_file_name = os.path.join(self.prob_dir, \"geometry.csv\")\n    max_over_states_file_name = os.path.join(self.prob_dir, \"max_over_states.csv\")\n\n    geometry_table = self.system.geometry.geometry_table\n    num_bonds = self.system.geometry.num_bonds\n\n    np.savetxt(geometry_file_name, geometry_table, delimiter=\",\", fmt=\"%d\", header=\"NumBonds={}\".format(num_bonds))\n\n    header = \"norm={},spectrum_offset={},loop_update_type={}\".format(\n        self.max_diag_norm, self.spectrum_offset, \"deterministic\"\n    )\n\n    np.savetxt(max_over_states_file_name, self.max_over_states, delimiter=\",\", header=header)\n</code></pre>"},{"location":"api/preproc/probability_tables/#oqd_heisenberg_ion.simulators.qmc.long_range.preprocess.probability_table.directed_loops","title":"<code>directed_loops</code>","text":""},{"location":"api/preproc/probability_tables/#oqd_heisenberg_ion.simulators.qmc.long_range.preprocess.probability_table.directed_loops.DirectedLoops","title":"<code>DirectedLoops</code>","text":"<p>               Bases: <code>ProbabilityTable</code></p> <p>ProbabilityTable subclass for directed loops sampling See: https://journals.aps.org/pre/abstract/10.1103/PhysRevE.66.046701 for details</p> Source code in <code>src/oqd_heisenberg_ion/simulators/qmc/long_range/preprocess/probability_table/directed_loops.py</code> <pre><code>class DirectedLoops(ProbabilityTable):\n    \"\"\"\n    ProbabilityTable subclass for directed loops sampling\n    See: https://journals.aps.org/pre/abstract/10.1103/PhysRevE.66.046701 for details\n    \"\"\"\n\n    args = {\"gamma\": float, \"ksi\": float, \"distance_dependent_offset\": bool}\n    allowed_hamiltonians = {\"XXZ\", \"XXZh\", \"XY\", \"fm_heisenberg_fm_Z\", \"fm_heisenberg_afm_Z\"}\n\n    def __init__(self, system, gamma, ksi, distance_dependent_offset):\n        \"\"\"\n        constructor computes the field contribution per bond, sets member variables and populates the directed loop probability tables\n\n        Args:\n            system (System): object representing the system to be simulated\n            gamma (float): offset added to weights reduce bounces\n            ksi (float): offset added in the presence of a large field to reduce bounces\n            distance_dependent_offset (bool): determines whether a distance dependant offset should be used\n        \"\"\"\n\n        super().__init__(system, gamma=gamma, ksi=ksi, distance_dependent_offset=distance_dependent_offset)\n\n        self.gamma = gamma\n        self.ksi = ksi\n        self.distance_dependent_offset = distance_dependent_offset\n\n        self.h_B = self.system.compute_h_B()\n\n        self.build()\n\n    def validate_system(self):\n        \"\"\"\n        validates the systema associated with the instance of the ProbabilityTable object\n\n        Raises:\n            Exception: if, for the specified hamiltonian name, directed loop sampling can not be used\n        \"\"\"\n\n        super().validate_system()\n\n        hamiltonian_name = self.system.hamiltonian_parameter.hamiltonian_name\n\n        if hamiltonian_name not in self.allowed_hamiltonians:\n            raise Exception(\n                \"Inconsistent hamiltonian and sampling types. Directed loop probability tables \"\n                \"only support the following types: {}\".format(self.allowed_hamiltonians)\n            )\n\n    def build(self):\n        \"\"\"\n        populates the directed loop probability tables\n        \"\"\"\n\n        num_bonds = self.system.geometry.num_bonds\n\n        self.initialize_tables(num_bonds)\n        self.set_vertex_enum_transition_weights_map()\n\n        J_ij_vector = self.system.interactions.J_ij_vector\n\n        Delta = self.system.hamiltonian_parameters.Delta\n        h_B = self.h_B\n\n        gamma = self.gamma\n        ksi = self.ksi\n        distance_dependent_offset = self.distance_dependent_offset\n\n        self.compute_prob_tables_directed_loops(\n            num_bonds, J_ij_vector, gamma, h_B, Delta, ksi, distance_dependent_offset\n        )\n\n    def initialize_tables(self, num_bonds):\n        \"\"\"\n        initializes the probability tables needed for directed loops sampling\n\n        Args:\n            num_bonds (int): number of interacting bonds in the lattice\n        \"\"\"\n\n        num_rows = vu.num_vertices * vu.num_legs_indices\n\n        self.directed_loop_prob_table = np.zeros((num_rows, num_bonds))\n        self.diag_prob_table = np.zeros((vu.num_diagonal_vertices, num_bonds))\n        self.max_over_states = np.zeros(num_bonds)\n        self.vertex_weights = np.zeros((vu.num_vertices, num_bonds))\n\n        self.spectrum_offset = 0.0\n        self.max_diag_norm = 0.0\n\n    def set_vertex_enum_transition_weights_map(self):\n\n        self.vertex_weight_label_map = {}\n\n        self.num_vertex_enums = 4\n        self.directed_loop_vertex_enums = [\"0\", \"1\", \"5\", \"3\"]\n        self.vertex_enum_weight_list_counts = [1, 2, 2, 1]\n\n        vertex_enum = \"0\"\n        exit_leg_weights_le_0_v_0 = [\"b_3\", None, \"c\", \"b\"]  # l_e = 0\n        self.vertex_weight_label_map[vertex_enum] = [exit_leg_weights_le_0_v_0]\n\n        vertex_enum = \"1\"\n        exit_leg_weights_le_0_v_1 = [\"b_2_p\", \"a_p\", \"c_p\", None]  # l_e = 0\n        exit_leg_weights_le_1_v_1 = [\"a\", \"b_2\", None, \"c\"]  # l_e = 1\n        self.vertex_weight_label_map[vertex_enum] = [exit_leg_weights_le_0_v_1, exit_leg_weights_le_1_v_1]\n\n        vertex_enum = \"5\"\n        exit_leg_weights_le_0_v_5 = [\"b_1\", \"a\", None, \"b\"]  # l_e = 0\n        exit_leg_weights_le_1_v_5 = [\"a_p\", \"b_1_p\", \"b_p\", None]  # l_e = 1\n        self.vertex_weight_label_map[vertex_enum] = [exit_leg_weights_le_0_v_5, exit_leg_weights_le_1_v_5]\n\n        vertex_enum = \"3\"\n        exit_leg_weights_le_0_v_3 = [\"b_3_p\", None, \"c_p\", \"b_p\"]  # l_e = 0\n        self.vertex_weight_label_map[vertex_enum] = [exit_leg_weights_le_0_v_3]\n\n    def update_directed_loop_probs(self, vertex_enum, l_e, l_x, bond, transition_weight):\n\n        init_composite_leg_index, init_row_index = self.get_composite_row_prob_index(vertex_enum, l_e, l_x)\n        normalization = self.vertex_weights[vertex_enum, bond]\n        if normalization != 0.0:\n            self.directed_loop_prob_table[init_row_index, bond] = mu.set_probability(transition_weight / normalization)\n\n        new_vertex_enum, new_l_e, new_l_x = self.get_symmetric_indices(vertex_enum, l_e, l_x, vu.vertical_swap_mapping)\n        new_composite_leg_index, new_row_index = self.get_composite_row_prob_index(new_vertex_enum, new_l_e, new_l_x)\n        self.directed_loop_prob_table[new_row_index, bond] = self.directed_loop_prob_table[init_row_index, bond]\n\n        new_vertex_enum, new_l_e, new_l_x = self.get_symmetric_indices(\n            vertex_enum, l_e, l_x, vu.horizontal_swap_mapping\n        )\n        new_composite_leg_index, new_row_index = self.get_composite_row_prob_index(new_vertex_enum, new_l_e, new_l_x)\n        self.directed_loop_prob_table[new_row_index, bond] = self.directed_loop_prob_table[init_row_index, bond]\n\n        new_vertex_enum, new_l_e, new_l_x = self.get_symmetric_indices(vertex_enum, l_e, l_x, vu.composed_swaps_mapping)\n        new_composite_leg_index, new_row_index = self.get_composite_row_prob_index(new_vertex_enum, new_l_e, new_l_x)\n        self.directed_loop_prob_table[new_row_index, bond] = self.directed_loop_prob_table[init_row_index, bond]\n\n    def get_composite_row_prob_index(self, vertex_enum, entrance_leg_enum, exit_leg_enum):\n\n        composite_leg_index = vu.num_legs_per_vertex * entrance_leg_enum + exit_leg_enum\n        row_index = vu.num_legs_indices * vertex_enum + composite_leg_index\n\n        return composite_leg_index, row_index\n\n    def get_symmetric_indices(self, vertex_enum, entrance_leg_enum, exit_leg_enum, symmetry_leg_mapping):\n\n        init_spin_tuple = vu.leg_spin[vertex_enum]\n        new_spin_tuple = (\n            init_spin_tuple[symmetry_leg_mapping[0]],\n            init_spin_tuple[symmetry_leg_mapping[1]],\n            init_spin_tuple[symmetry_leg_mapping[2]],\n            init_spin_tuple[symmetry_leg_mapping[3]],\n        )\n        new_vertex_enum = vu.vertex_map[new_spin_tuple]\n\n        new_entrance_leg_enum = symmetry_leg_mapping[entrance_leg_enum]\n        new_exit_leg_enum = symmetry_leg_mapping[exit_leg_enum]\n\n        return new_vertex_enum, new_entrance_leg_enum, new_exit_leg_enum\n\n    def update_directed_loop_table(self, bond, transition_weights):\n\n        for i in range(self.num_vertex_enums):\n            vertex_enum = self.directed_loop_vertex_enums[i]\n            num_unique_entrance_legs = self.vertex_enum_weight_list_counts[i]\n\n            for l_e in range(num_unique_entrance_legs):\n                exit_leg_weight_labels = self.vertex_weight_label_map[vertex_enum][l_e]\n\n                for l_x in range(vu.num_legs_per_vertex):\n                    l_x_weight_label = exit_leg_weight_labels[l_x]\n                    l_x_weight = transition_weights[l_x_weight_label] if l_x_weight_label is not None else 0.0\n\n                    self.update_directed_loop_probs(int(vertex_enum), l_e, l_x, bond, l_x_weight)\n\n    def compute_prob_tables_directed_loops(\n        self, num_bonds, J_ij_vector, gamma, h_B, Delta, ksi, distance_dependent_offset\n    ):\n\n        self.transition_weights_calculator = LoopTransitionWeights(gamma, Delta, h_B, ksi, distance_dependent_offset)\n\n        for bond in range(num_bonds):\n            J_ij = J_ij_vector[bond]\n\n            vu.set_vertex_weights(self.vertex_weights, bond, Delta, J_ij, h_B)\n\n            self.diag_prob_table[:, bond] = self.vertex_weights[0:4, bond]\n\n            self.transition_weights_calculator.compute_transition_weights(J_ij)\n\n            transition_weights = self.transition_weights_calculator.transition_weight_container\n            offset = self.transition_weights_calculator.offset_b\n\n            self.vertex_weights[0:4, bond] += offset\n            self.spectrum_offset += offset\n\n            self.diag_prob_table[:, bond] += offset\n\n            self.diag_prob_table = mu.enforce_positive(self.diag_prob_table, bond)\n            self.vertex_weights = mu.enforce_positive(self.vertex_weights, bond)\n\n            self.update_directed_loop_table(bond, transition_weights)\n\n            self.max_over_states[bond] = np.max(self.diag_prob_table[:, bond])\n            self.diag_prob_table[:, bond] /= self.max_over_states[bond]\n            self.max_diag_norm += self.max_over_states[bond]\n\n        self.max_over_states[:] /= self.max_diag_norm\n\n    def write_to_files(self, out_dir):\n        \"\"\"\n        writes the probability tables to csv files for SSE engine\n\n        Args:\n            out_dir (str): directory path for writing probability tables\n        \"\"\"\n\n        super().write_to_files(out_dir)\n\n        geometry_file_name = os.path.join(self.prob_dir, \"geometry.csv\")\n        diag_file_name = os.path.join(self.prob_dir, \"diag_probs.csv\")\n        max_over_states_file_name = os.path.join(self.prob_dir, \"max_over_states.csv\")\n        loop_update_table_file_name = os.path.join(self.prob_dir, \"off_diag_table.csv\")\n        vertex_weights_file_name = os.path.join(self.prob_dir, \"vertex_weights.csv\")\n\n        geometry_table = self.system.geometry.geometry_table\n        num_bonds = self.system.geometry.num_bonds\n        np.savetxt(geometry_file_name, geometry_table, delimiter=\",\", fmt=\"%d\", header=\"NumBonds={}\".format(num_bonds))\n\n        header = \"norm={},spectrum_offset={},loop_update_type={}\".format(\n            self.max_diag_norm, self.spectrum_offset, \"DirectedLoops\"\n        )\n\n        np.savetxt(diag_file_name, self.diag_prob_table, delimiter=\",\", header=header)\n        np.savetxt(vertex_weights_file_name, self.vertex_weights, delimiter=\",\", header=header)\n        np.savetxt(max_over_states_file_name, self.max_over_states, delimiter=\",\", header=header)\n        np.savetxt(loop_update_table_file_name, self.directed_loop_prob_table, delimiter=\",\", header=header)\n</code></pre>"},{"location":"api/preproc/probability_tables/#oqd_heisenberg_ion.simulators.qmc.long_range.preprocess.probability_table.directed_loops.DirectedLoops.__init__","title":"<code>__init__</code>","text":"<p>constructor computes the field contribution per bond, sets member variables and populates the directed loop probability tables</p> <p>Parameters:</p> <ul> <li> <code>system</code>               (<code>System</code>)           \u2013            <p>object representing the system to be simulated</p> </li> <li> <code>gamma</code>               (<code>float</code>)           \u2013            <p>offset added to weights reduce bounces</p> </li> <li> <code>ksi</code>               (<code>float</code>)           \u2013            <p>offset added in the presence of a large field to reduce bounces</p> </li> <li> <code>distance_dependent_offset</code>               (<code>bool</code>)           \u2013            <p>determines whether a distance dependant offset should be used</p> </li> </ul> Source code in <code>src/oqd_heisenberg_ion/simulators/qmc/long_range/preprocess/probability_table/directed_loops.py</code> <pre><code>def __init__(self, system, gamma, ksi, distance_dependent_offset):\n    \"\"\"\n    constructor computes the field contribution per bond, sets member variables and populates the directed loop probability tables\n\n    Args:\n        system (System): object representing the system to be simulated\n        gamma (float): offset added to weights reduce bounces\n        ksi (float): offset added in the presence of a large field to reduce bounces\n        distance_dependent_offset (bool): determines whether a distance dependant offset should be used\n    \"\"\"\n\n    super().__init__(system, gamma=gamma, ksi=ksi, distance_dependent_offset=distance_dependent_offset)\n\n    self.gamma = gamma\n    self.ksi = ksi\n    self.distance_dependent_offset = distance_dependent_offset\n\n    self.h_B = self.system.compute_h_B()\n\n    self.build()\n</code></pre>"},{"location":"api/preproc/probability_tables/#oqd_heisenberg_ion.simulators.qmc.long_range.preprocess.probability_table.directed_loops.DirectedLoops.validate_system","title":"<code>validate_system</code>","text":"<p>validates the systema associated with the instance of the ProbabilityTable object</p> <p>Raises:</p> <ul> <li> <code>Exception</code>             \u2013            <p>if, for the specified hamiltonian name, directed loop sampling can not be used</p> </li> </ul> Source code in <code>src/oqd_heisenberg_ion/simulators/qmc/long_range/preprocess/probability_table/directed_loops.py</code> <pre><code>def validate_system(self):\n    \"\"\"\n    validates the systema associated with the instance of the ProbabilityTable object\n\n    Raises:\n        Exception: if, for the specified hamiltonian name, directed loop sampling can not be used\n    \"\"\"\n\n    super().validate_system()\n\n    hamiltonian_name = self.system.hamiltonian_parameter.hamiltonian_name\n\n    if hamiltonian_name not in self.allowed_hamiltonians:\n        raise Exception(\n            \"Inconsistent hamiltonian and sampling types. Directed loop probability tables \"\n            \"only support the following types: {}\".format(self.allowed_hamiltonians)\n        )\n</code></pre>"},{"location":"api/preproc/probability_tables/#oqd_heisenberg_ion.simulators.qmc.long_range.preprocess.probability_table.directed_loops.DirectedLoops.build","title":"<code>build</code>","text":"<p>populates the directed loop probability tables</p> Source code in <code>src/oqd_heisenberg_ion/simulators/qmc/long_range/preprocess/probability_table/directed_loops.py</code> <pre><code>def build(self):\n    \"\"\"\n    populates the directed loop probability tables\n    \"\"\"\n\n    num_bonds = self.system.geometry.num_bonds\n\n    self.initialize_tables(num_bonds)\n    self.set_vertex_enum_transition_weights_map()\n\n    J_ij_vector = self.system.interactions.J_ij_vector\n\n    Delta = self.system.hamiltonian_parameters.Delta\n    h_B = self.h_B\n\n    gamma = self.gamma\n    ksi = self.ksi\n    distance_dependent_offset = self.distance_dependent_offset\n\n    self.compute_prob_tables_directed_loops(\n        num_bonds, J_ij_vector, gamma, h_B, Delta, ksi, distance_dependent_offset\n    )\n</code></pre>"},{"location":"api/preproc/probability_tables/#oqd_heisenberg_ion.simulators.qmc.long_range.preprocess.probability_table.directed_loops.DirectedLoops.initialize_tables","title":"<code>initialize_tables</code>","text":"<p>initializes the probability tables needed for directed loops sampling</p> <p>Parameters:</p> <ul> <li> <code>num_bonds</code>               (<code>int</code>)           \u2013            <p>number of interacting bonds in the lattice</p> </li> </ul> Source code in <code>src/oqd_heisenberg_ion/simulators/qmc/long_range/preprocess/probability_table/directed_loops.py</code> <pre><code>def initialize_tables(self, num_bonds):\n    \"\"\"\n    initializes the probability tables needed for directed loops sampling\n\n    Args:\n        num_bonds (int): number of interacting bonds in the lattice\n    \"\"\"\n\n    num_rows = vu.num_vertices * vu.num_legs_indices\n\n    self.directed_loop_prob_table = np.zeros((num_rows, num_bonds))\n    self.diag_prob_table = np.zeros((vu.num_diagonal_vertices, num_bonds))\n    self.max_over_states = np.zeros(num_bonds)\n    self.vertex_weights = np.zeros((vu.num_vertices, num_bonds))\n\n    self.spectrum_offset = 0.0\n    self.max_diag_norm = 0.0\n</code></pre>"},{"location":"api/preproc/probability_tables/#oqd_heisenberg_ion.simulators.qmc.long_range.preprocess.probability_table.directed_loops.DirectedLoops.write_to_files","title":"<code>write_to_files</code>","text":"<p>writes the probability tables to csv files for SSE engine</p> <p>Parameters:</p> <ul> <li> <code>out_dir</code>               (<code>str</code>)           \u2013            <p>directory path for writing probability tables</p> </li> </ul> Source code in <code>src/oqd_heisenberg_ion/simulators/qmc/long_range/preprocess/probability_table/directed_loops.py</code> <pre><code>def write_to_files(self, out_dir):\n    \"\"\"\n    writes the probability tables to csv files for SSE engine\n\n    Args:\n        out_dir (str): directory path for writing probability tables\n    \"\"\"\n\n    super().write_to_files(out_dir)\n\n    geometry_file_name = os.path.join(self.prob_dir, \"geometry.csv\")\n    diag_file_name = os.path.join(self.prob_dir, \"diag_probs.csv\")\n    max_over_states_file_name = os.path.join(self.prob_dir, \"max_over_states.csv\")\n    loop_update_table_file_name = os.path.join(self.prob_dir, \"off_diag_table.csv\")\n    vertex_weights_file_name = os.path.join(self.prob_dir, \"vertex_weights.csv\")\n\n    geometry_table = self.system.geometry.geometry_table\n    num_bonds = self.system.geometry.num_bonds\n    np.savetxt(geometry_file_name, geometry_table, delimiter=\",\", fmt=\"%d\", header=\"NumBonds={}\".format(num_bonds))\n\n    header = \"norm={},spectrum_offset={},loop_update_type={}\".format(\n        self.max_diag_norm, self.spectrum_offset, \"DirectedLoops\"\n    )\n\n    np.savetxt(diag_file_name, self.diag_prob_table, delimiter=\",\", header=header)\n    np.savetxt(vertex_weights_file_name, self.vertex_weights, delimiter=\",\", header=header)\n    np.savetxt(max_over_states_file_name, self.max_over_states, delimiter=\",\", header=header)\n    np.savetxt(loop_update_table_file_name, self.directed_loop_prob_table, delimiter=\",\", header=header)\n</code></pre>"},{"location":"api/preproc/probability_tables/#oqd_heisenberg_ion.simulators.qmc.long_range.preprocess.probability_table.directed_loops.LoopTransitionWeights","title":"<code>LoopTransitionWeights</code>","text":"<p>contains the logic for computing the transition weights in the directed loop SSE method See https://journals.aps.org/pre/abstract/10.1103/PhysRevE.66.046701 for details</p> Source code in <code>src/oqd_heisenberg_ion/simulators/qmc/long_range/preprocess/probability_table/directed_loops.py</code> <pre><code>class LoopTransitionWeights:\n    \"\"\"\n    contains the logic for computing the transition weights in the directed loop SSE method\n    See https://journals.aps.org/pre/abstract/10.1103/PhysRevE.66.046701 for details\n    \"\"\"\n\n    def __init__(self, gamma, Delta, h_B, ksi, distance_dependent_offset):\n\n        keys = [\"a\", \"b\", \"c\", \"a_p\", \"b_p\", \"c_p\", \"b_1\", \"b_2\", \"b_3\", \"b_1_p\", \"b_2_p\", \"b_3_p\"]\n        self.transition_weight_container = {key: None for key in keys}\n\n        self.Delta = Delta\n        self.h_B = h_B\n\n        self.gamma = gamma\n        self.ksi = ksi\n        self.distance_dependent_offset = distance_dependent_offset\n\n        if self.h_B &lt; 0.0:\n            raise Exception(\"h_B needs to be greater than or equal to 0\")\n\n    def populate_unprimed_transition_weights(self, a, b, c):\n\n        self.transition_weight_container[\"a\"] = a\n        self.transition_weight_container[\"b\"] = b\n        self.transition_weight_container[\"c\"] = c\n\n    def populate_primed_transition_weights(self, a_p, b_p, c_p):\n\n        self.transition_weight_container[\"a_p\"] = a_p\n        self.transition_weight_container[\"b_p\"] = b_p\n        self.transition_weight_container[\"c_p\"] = c_p\n\n    def populate_unprimed_bounce_weights(self, b_1, b_2, b_3):\n\n        self.transition_weight_container[\"b_1\"] = b_1\n        self.transition_weight_container[\"b_2\"] = b_2\n        self.transition_weight_container[\"b_3\"] = b_3\n\n    def populate_primed_bounce_weights(self, b_1_p, b_2_p, b_3_p):\n\n        self.transition_weight_container[\"b_1_p\"] = b_1_p\n        self.transition_weight_container[\"b_2_p\"] = b_2_p\n        self.transition_weight_container[\"b_3_p\"] = b_3_p\n\n    def tranisiton_weights_small_field(self, Delta_over_four_J_ij, Delta_positive, Delta_negative):\n\n        self.offset_b = Delta_over_four_J_ij\n\n        if self.h_B &gt;= Delta_negative:\n            b_3_p = 0.0\n            epsilon = -Delta_negative / 2.0 + self.h_B / 2.0 + self.gamma\n        else:\n            b_3_p = Delta_negative - self.h_B + self.ksi\n            epsilon = self.gamma\n\n        if self.h_B &lt;= -Delta_negative:\n            b_3 = 0.0\n        else:\n            b_3 = Delta_negative + self.h_B + self.ksi\n\n        a_p = -Delta_negative / 2.0 + self.h_B / 2.0 + b_3_p / 2.0\n        b_p = Delta_positive / 2.0 - self.h_B / 2.0 - b_3_p / 2.0\n        c_p = Delta_negative / 2.0 + epsilon - self.h_B / 2.0 - b_3_p / 2.0\n\n        a = -Delta_negative / 2.0 - self.h_B / 2.0 + b_3 / 2.0\n        b = Delta_positive / 2.0 + self.h_B / 2.0 - b_3 / 2.0\n        c = epsilon + Delta_negative / 2.0 + self.h_B / 2.0 - b_3 / 2.0\n\n        b_1_p = 0.0\n        b_2_p = 0.0\n        b_1 = 0.0\n        b_2 = 0.0\n\n        self.offset_b += epsilon\n        self.epsilon = epsilon\n\n        self.populate_unprimed_transition_weights(a, b, c)\n        self.populate_primed_transition_weights(a_p, b_p, c_p)\n        self.populate_unprimed_bounce_weights(b_1, b_2, b_3)\n        self.populate_primed_bounce_weights(b_1_p, b_2_p, b_3_p)\n\n    def transition_weights_negative_Delta(self, Delta_over_four_J_ij, Delta_positive, Delta_negative, J_ij):\n\n        if self.h_B == 0.0:\n            self.offset_b = -(self.Delta / 4.0) * J_ij\n            if self.Delta &lt;= -1.0:\n                if self.distance_dependent_offset:\n                    epsilon = self.gamma - (self.Delta / 10.0) * J_ij\n                    c_p = self.gamma - (self.Delta / 10.0) * J_ij\n                    # epsilon = gamma + 0.1/(r_b_pow_alpha)\n                    # c_p = gamma + 0.1/(r_b_pow_alpha)\n                else:\n                    epsilon = self.gamma\n                    c_p = self.gamma\n                c = c_p\n                a_p = (1.0 / 2.0) * J_ij\n                b_p = 0.0\n                a = a_p\n                b = b_p\n                b_2_p = -((1.0 + self.Delta) / 2.0) * J_ij\n                b_2 = b_2_p\n                b_3_p = 0.0\n                b_1_p = 0.0\n                b_1 = b_1_p\n                b_3 = b_3_p\n            else:\n                b_2_p = 0.0\n                b_p = ((1.0 + self.Delta) / (4.0)) * J_ij\n                a_p = ((1.0 - self.Delta) / (4.0)) * J_ij\n                c_p = self.gamma\n                epsilon = ((1.0 + self.Delta) / (4.0)) * J_ij + self.gamma\n                c = c_p\n                a = a_p\n                b = b_p\n                b_1_p = 0.0\n                b_3_p = 0.0\n                b_2 = b_2_p\n                b_1 = b_1_p\n                b_3 = b_3_p\n        else:\n            self.offset_b = self.h_B - Delta_over_four_J_ij\n\n            if self.h_B &lt;= Delta_positive:\n                b_2_p = 0.0\n                epsilon = Delta_positive / 2.0 - self.h_B / 2.0 + self.gamma\n            else:\n                b_2_p = self.h_B - Delta_positive + self.ksi\n                epsilon = self.gamma\n\n            if self.h_B &lt;= -Delta_positive:\n                b_2 = -self.h_B - Delta_positive + self.ksi\n            else:\n                b_2 = 0.0\n\n            if self.h_B &lt;= -Delta_negative:\n                b_3 = 0.0\n            else:\n                b_3 = self.h_B + Delta_negative + self.ksi\n\n            a_p = -Delta_negative / 2.0 + self.h_B / 2.0 - b_2_p / 2.0\n            b_p = Delta_positive / 2.0 - self.h_B / 2.0 + b_2_p / 2.0\n            c_p = epsilon - Delta_positive / 2.0 + self.h_B / 2.0 - b_2_p / 2.0\n\n            a = -Delta_negative / 2.0 - self.h_B / 2.0 + b_3 / 2.0 - b_2 / 2.0\n            b = Delta_positive / 2.0 + self.h_B / 2.0 + b_2 / 2.0 - b_3 / 2.0\n            c = 3.0 * self.h_B / 2.0 + epsilon - Delta_positive / 2.0 - b_2 / 2.0 - b_3 / 2.0\n\n            b_1 = 0.0\n            b_1_p = 0.0\n            b_3_p = 0.0\n\n        self.offset_b += epsilon\n        self.epsilon = epsilon\n\n        self.populate_unprimed_transition_weights(a, b, c)\n        self.populate_primed_transition_weights(a_p, b_p, c_p)\n        self.populate_unprimed_bounce_weights(b_1, b_2, b_3)\n        self.populate_primed_bounce_weights(b_1_p, b_2_p, b_3_p)\n\n    def transition_weights_large_field(self, Delta_positive, Delta_negative, J_ij):\n\n        self.offset_b = self.h_B\n        one_over_four_J_ij = (1.0 / 4.0) * J_ij\n\n        if self.h_B &lt;= Delta_negative:\n            b_3_p = Delta_negative - self.h_B + self.ksi\n            epsilon = self.gamma\n        else:\n            b_3_p = 0.0\n            if self.h_B &lt;= Delta_positive and self.h_B &lt;= 2.0 * one_over_four_J_ij:\n                epsilon = one_over_four_J_ij - self.h_B / 2.0 + self.gamma\n            else:\n                epsilon = self.gamma\n\n        if self.h_B &lt;= Delta_positive:\n            b_2_p = 0.0\n        else:\n            b_2_p = self.h_B - Delta_positive + self.ksi\n\n        if self.h_B &lt; -Delta_negative:\n            b_3 = 0\n        else:\n            b_3 = self.h_B + Delta_negative + self.ksi\n\n        a_p = -Delta_negative / 2.0 + self.h_B / 2.0 + b_3_p / 2.0 - b_2_p / 2.0\n        b_p = Delta_positive / 2.0 - self.h_B / 2.0 - b_3_p / 2.0 + b_2_p / 2.0\n        c_p = epsilon - one_over_four_J_ij + self.h_B / 2.0 - b_3_p / 2.0 - b_2_p / 2.0\n\n        a = -Delta_negative / 2.0 - self.h_B / 2.0 + b_3 / 2.0\n        b = Delta_positive / 2.0 + self.h_B / 2.0 - b_3 / 2.0\n        c = epsilon - one_over_four_J_ij + 3.0 * self.h_B / 2.0 - b_3 / 2.0\n\n        b_1 = 0.0\n        b_2 = 0.0\n        b_1_p = 0.0\n\n        self.offset_b += epsilon\n        self.epsilon = epsilon\n\n        self.populate_unprimed_transition_weights(a, b, c)\n        self.populate_primed_transition_weights(a_p, b_p, c_p)\n        self.populate_unprimed_bounce_weights(b_1, b_2, b_3)\n        self.populate_primed_bounce_weights(b_1_p, b_2_p, b_3_p)\n\n    def compute_transition_weights(self, J_ij):\n\n        Delta_over_four_J_ij = (self.Delta / 4.0) * J_ij\n\n        Delta_positive = ((self.Delta + 1.0) / (2.0)) * J_ij\n        Delta_negative = ((self.Delta - 1.0) / (2.0)) * J_ij\n\n        if Delta_over_four_J_ij &gt; self.h_B:\n            self.tranisiton_weights_small_field(Delta_over_four_J_ij, Delta_positive, Delta_negative)\n        elif self.Delta &lt; 0.0:\n            self.transition_weights_negative_Delta(Delta_over_four_J_ij, Delta_positive, Delta_negative, J_ij)\n        else:\n            self.transition_weights_large_field(Delta_positive, Delta_negative, J_ij)\n</code></pre>"},{"location":"api/preproc/probability_tables/#oqd_heisenberg_ion.simulators.qmc.long_range.preprocess.probability_table.factory","title":"<code>factory</code>","text":""},{"location":"api/preproc/probability_tables/#oqd_heisenberg_ion.simulators.qmc.long_range.preprocess.probability_table.factory.ProbabilityTableFactory","title":"<code>ProbabilityTableFactory</code>","text":"<p>Factory for generating the required instance of the ProbabilityTable subclass. Carries a registry of ProbabilityTable subclasses</p> Source code in <code>src/oqd_heisenberg_ion/simulators/qmc/long_range/preprocess/probability_table/factory.py</code> <pre><code>class ProbabilityTableFactory:\n    \"\"\"\n    Factory for generating the required instance of the ProbabilityTable subclass. Carries a registry of ProbabilityTable subclasses\n    \"\"\"\n\n    registry = {}\n\n    def register(cls, name, subclass):\n        \"\"\"\n        adds the specified subclass to the registry\n\n        Args:\n            name (str): name to be used for subclass\n            subclass (Type[ProbabilityTable]): ProbabilityTable subclass to be registered\n        \"\"\"\n\n        cls.registry[name] = subclass\n\n    def extract_args(cls, name, **kwargs):\n        \"\"\"\n        extracts the arguments associated with a given subclass\n\n        Args:\n            name (str): subclass name (must exist in registry)\n            **kwargs (dict): key word arguments. Must contain inputs for the specific subclass\n\n        Returns:\n            (dict): contains the subclass arguments as key value pairs\n        \"\"\"\n\n        arg_vals = {}\n        for key, arg_dtype in cls.registry[name].args.items():\n            arg_vals[key] = arg_dtype(kwargs[key])\n\n        return arg_vals\n\n    def create(cls, name, system, **kwargs):\n        \"\"\"\n        creates an instance of the subclass specified\n\n        Args:\n            name (str): name of requested subclass\n\n        Raises:\n            Exception: if the requested ProbabilityTable is not found in the registry\n\n        Returns:\n            (ProbabilityTable): instance of the the requested subclass\n        \"\"\"\n\n        if name not in cls.registry:\n            raise Exception(f\"Probability Table implementation not found for name: {name}\")\n        else:\n            return cls.registry[name](system, **kwargs)\n</code></pre>"},{"location":"api/preproc/probability_tables/#oqd_heisenberg_ion.simulators.qmc.long_range.preprocess.probability_table.factory.ProbabilityTableFactory.register","title":"<code>register</code>","text":"<p>adds the specified subclass to the registry</p> <p>Parameters:</p> <ul> <li> <code>name</code>               (<code>str</code>)           \u2013            <p>name to be used for subclass</p> </li> <li> <code>subclass</code>               (<code>Type[ProbabilityTable]</code>)           \u2013            <p>ProbabilityTable subclass to be registered</p> </li> </ul> Source code in <code>src/oqd_heisenberg_ion/simulators/qmc/long_range/preprocess/probability_table/factory.py</code> <pre><code>def register(cls, name, subclass):\n    \"\"\"\n    adds the specified subclass to the registry\n\n    Args:\n        name (str): name to be used for subclass\n        subclass (Type[ProbabilityTable]): ProbabilityTable subclass to be registered\n    \"\"\"\n\n    cls.registry[name] = subclass\n</code></pre>"},{"location":"api/preproc/probability_tables/#oqd_heisenberg_ion.simulators.qmc.long_range.preprocess.probability_table.factory.ProbabilityTableFactory.extract_args","title":"<code>extract_args</code>","text":"<p>extracts the arguments associated with a given subclass</p> <p>Parameters:</p> <ul> <li> <code>name</code>               (<code>str</code>)           \u2013            <p>subclass name (must exist in registry)</p> </li> <li> <code>**kwargs</code>               (<code>dict</code>, default:                   <code>{}</code> )           \u2013            <p>key word arguments. Must contain inputs for the specific subclass</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>dict</code>           \u2013            <p>contains the subclass arguments as key value pairs</p> </li> </ul> Source code in <code>src/oqd_heisenberg_ion/simulators/qmc/long_range/preprocess/probability_table/factory.py</code> <pre><code>def extract_args(cls, name, **kwargs):\n    \"\"\"\n    extracts the arguments associated with a given subclass\n\n    Args:\n        name (str): subclass name (must exist in registry)\n        **kwargs (dict): key word arguments. Must contain inputs for the specific subclass\n\n    Returns:\n        (dict): contains the subclass arguments as key value pairs\n    \"\"\"\n\n    arg_vals = {}\n    for key, arg_dtype in cls.registry[name].args.items():\n        arg_vals[key] = arg_dtype(kwargs[key])\n\n    return arg_vals\n</code></pre>"},{"location":"api/preproc/probability_tables/#oqd_heisenberg_ion.simulators.qmc.long_range.preprocess.probability_table.factory.ProbabilityTableFactory.create","title":"<code>create</code>","text":"<p>creates an instance of the subclass specified</p> <p>Parameters:</p> <ul> <li> <code>name</code>               (<code>str</code>)           \u2013            <p>name of requested subclass</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>Exception</code>             \u2013            <p>if the requested ProbabilityTable is not found in the registry</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>ProbabilityTable</code>           \u2013            <p>instance of the the requested subclass</p> </li> </ul> Source code in <code>src/oqd_heisenberg_ion/simulators/qmc/long_range/preprocess/probability_table/factory.py</code> <pre><code>def create(cls, name, system, **kwargs):\n    \"\"\"\n    creates an instance of the subclass specified\n\n    Args:\n        name (str): name of requested subclass\n\n    Raises:\n        Exception: if the requested ProbabilityTable is not found in the registry\n\n    Returns:\n        (ProbabilityTable): instance of the the requested subclass\n    \"\"\"\n\n    if name not in cls.registry:\n        raise Exception(f\"Probability Table implementation not found for name: {name}\")\n    else:\n        return cls.registry[name](system, **kwargs)\n</code></pre>"},{"location":"api/preproc/probability_tables/#oqd_heisenberg_ion.simulators.qmc.long_range.preprocess.probability_table.heatbath","title":"<code>heatbath</code>","text":""},{"location":"api/preproc/probability_tables/#oqd_heisenberg_ion.simulators.qmc.long_range.preprocess.probability_table.heatbath.Heatbath","title":"<code>Heatbath</code>","text":"<p>               Bases: <code>ProbabilityTable</code></p> <p>ProbabilityTable subclass for heatbath sampling See: https://journals.aps.org/pre/abstract/10.1103/PhysRevE.66.046701 for details</p> Source code in <code>src/oqd_heisenberg_ion/simulators/qmc/long_range/preprocess/probability_table/heatbath.py</code> <pre><code>class Heatbath(ProbabilityTable):\n    \"\"\"\n    ProbabilityTable subclass for heatbath sampling\n    See: https://journals.aps.org/pre/abstract/10.1103/PhysRevE.66.046701 for details\n    \"\"\"\n\n    args = {\"gamma\": float}\n    allowed_hamiltonians = {\"XXZ\", \"XXZh\", \"XY\", \"fm_heisenberg_fm_Z\", \"fm_heisenberg_afm_Z\"}\n\n    def __init__(self, system, gamma):\n        \"\"\"\n        constructor computes the field contribution per bond, sets member variables and populates the heatbath probability tables\n\n        Args:\n            system (System): object representing the system to be simulated\n            gamma (float): offset added to weights reduce bounces\n        \"\"\"\n\n        super().__init__(system, gamma=gamma)\n\n        self.gamma = gamma\n\n        self.h_B = self.system.compute_h_B()\n\n        self.validate_system()\n\n        self.build()\n\n    def validate_system(self):\n        \"\"\"\n        validates the systema associated with the instance of the ProbabilityTable object\n\n        Raises:\n            Exception: if, for the specified hamiltonian name, heatbath sampling can not be used\n        \"\"\"\n\n        super().validate_system()\n\n        hamiltonian_name = self.system.hamiltonian_parameters.hamiltonian_name\n\n        if hamiltonian_name not in self.allowed_hamiltonians:\n            raise Exception(\n                \"Inconsistent hamiltonian and sampling types. Heatbath probability tables \"\n                \"only support the following types: {}\".format(self.allowed_hamiltonians)\n            )\n\n    def build(self):\n        \"\"\"\n        populates the heatbath probability tables\n        \"\"\"\n\n        num_bonds = self.system.geometry.num_bonds\n        J_ij_vector = self.system.interactions.J_ij_vector\n        gamma = self.gamma\n        h_B = self.h_B\n        Delta = self.system.hamiltonian_parameters.Delta\n\n        self.initialize_tables(num_bonds)\n        self.compute_prob_tables_heat_bath(num_bonds, J_ij_vector, gamma, h_B, Delta)\n\n        return 0\n\n    def initialize_tables(self, num_bonds):\n        \"\"\"\n        initializes the probability tables needed for heatbath sampling\n\n        Args:\n            num_bonds (int): number of interacting bonds in the lattice\n        \"\"\"\n\n        self.num_rows = vu.num_vertices * vu.num_legs_indices\n        self.heat_bath_prob_table = np.zeros((self.num_rows, num_bonds))\n\n        self.diag_prob_table = np.zeros((vu.num_diagonal_vertices, num_bonds))\n        self.max_over_states = np.zeros(num_bonds)\n        self.vertex_weights = np.zeros((vu.num_vertices, num_bonds))\n\n        self.spectrum_offset = 0.0\n        self.max_diag_norm = 0.0\n\n        return 0\n\n    # Helper function used by compute_prob_tables_heat_bath\n    def compute_offset(self, gamma, Delta, J_ij, h_B):\n\n        if h_B &lt; 0.0:\n            raise Exception(\"h_B needs to be greater than or equal to 0\")\n        else:\n            Delta_over_four_J_ij = (Delta / 4.0) * J_ij\n\n            if Delta_over_four_J_ij &gt; h_B:\n                offset_b = Delta_over_four_J_ij\n\n            elif Delta &lt; 0.0:\n                offset_b = h_B - Delta_over_four_J_ij\n\n            else:\n                offset_b = h_B\n\n            offset_b += gamma\n\n            return offset_b\n\n    def update_heat_bath_probs(self, bond):\n\n        for vertex_enum in range(vu.num_vertices):\n            for l_e in range(vu.num_legs_per_vertex):\n                norm = 0.0\n                count_invalid_vertices = 0\n\n                for l_x in range(vu.num_legs_per_vertex):\n                    composite_leg_index = vu.num_legs_per_vertex * l_e + l_x\n                    row_index = vu.num_legs_indices * vertex_enum + composite_leg_index\n\n                    # new_vertex = get_new_vertex(v_map, l_spin, l_e, l_x, vertex_enum)\n                    new_vertex = vu.new_vertex_map[vertex_enum, composite_leg_index]\n\n                    if new_vertex == -1:\n                        count_invalid_vertices += 1\n                        self.heat_bath_prob_table[row_index, bond] = 0.0\n                    else:\n                        self.heat_bath_prob_table[row_index, bond] = mu.set_probability(\n                            self.vertex_weights[new_vertex, bond]\n                        )\n                        norm += self.vertex_weights[new_vertex, bond]\n\n                self.heat_bath_prob_table[row_index - vu.num_legs_per_vertex + 1 : row_index + 1, bond] /= norm\n\n        return 0\n\n    # Generating this table might be slow for large systems because size grows as N^2.\n    # Simpler but slightly slower approach would be to:\n    # compute non-zero heat bath probabilities on the fly\n    def compute_prob_tables_heat_bath(self, num_bonds, J_ij_vector, gamma, h_B, Delta):\n\n        for bond in range(num_bonds):\n            J_ij = J_ij_vector[bond]\n\n            vu.set_vertex_weights(self.vertex_weights, bond, Delta, J_ij, h_B)\n\n            self.diag_prob_table[:, bond] = self.vertex_weights[0:4, bond]\n\n            offset = self.compute_offset(gamma, Delta, J_ij, h_B)\n\n            self.vertex_weights[0:4, bond] += offset\n            self.spectrum_offset += offset\n\n            self.diag_prob_table[:, bond] += offset\n\n            self.diag_prob_table = mu.enforce_positive(self.diag_prob_table, bond)\n            self.vertex_weights = mu.enforce_positive(self.vertex_weights, bond)\n\n            self.max_over_states[bond] = np.max(self.diag_prob_table[:, bond])\n            self.diag_prob_table[:, bond] /= self.max_over_states[bond]\n            self.max_diag_norm += self.max_over_states[bond]\n\n            self.update_heat_bath_probs(bond)\n\n        self.max_over_states[:] /= self.max_diag_norm\n\n        return 0\n\n    def write_to_files(self, out_dir):\n        \"\"\"\n        writes the probability tables to csv files for SSE engine\n\n        Args:\n            out_dir (str): directory path for writing probability tables\n        \"\"\"\n\n        super().write_to_files(out_dir)\n\n        geometry_file_name = os.path.join(self.prob_dir, \"geometry.csv\")\n        diag_file_name = os.path.join(self.prob_dir, \"diag_probs.csv\")\n        max_over_states_file_name = os.path.join(self.prob_dir, \"max_over_states.csv\")\n        loop_update_table_file_name = os.path.join(self.prob_dir, \"off_diag_table.csv\")\n        vertex_weights_file_name = os.path.join(self.prob_dir, \"vertex_weights.csv\")\n\n        geometry_table = self.system.geometry.geometry_table\n        num_bonds = self.system.geometry.num_bonds\n        np.savetxt(geometry_file_name, geometry_table, delimiter=\",\", fmt=\"%d\", header=\"NumBonds={}\".format(num_bonds))\n\n        header = \"norm={},spectrum_offset={},loop_update_type={}\".format(\n            self.max_diag_norm, self.spectrum_offset, \"heatbath\"\n        )\n\n        np.savetxt(diag_file_name, self.diag_prob_table, delimiter=\",\", header=header)\n        np.savetxt(vertex_weights_file_name, self.vertex_weights, delimiter=\",\", header=header)\n        np.savetxt(max_over_states_file_name, self.max_over_states, delimiter=\",\", header=header)\n        np.savetxt(loop_update_table_file_name, self.heat_bath_prob_table, delimiter=\",\", header=header)\n\n        return 0\n</code></pre>"},{"location":"api/preproc/probability_tables/#oqd_heisenberg_ion.simulators.qmc.long_range.preprocess.probability_table.heatbath.Heatbath.__init__","title":"<code>__init__</code>","text":"<p>constructor computes the field contribution per bond, sets member variables and populates the heatbath probability tables</p> <p>Parameters:</p> <ul> <li> <code>system</code>               (<code>System</code>)           \u2013            <p>object representing the system to be simulated</p> </li> <li> <code>gamma</code>               (<code>float</code>)           \u2013            <p>offset added to weights reduce bounces</p> </li> </ul> Source code in <code>src/oqd_heisenberg_ion/simulators/qmc/long_range/preprocess/probability_table/heatbath.py</code> <pre><code>def __init__(self, system, gamma):\n    \"\"\"\n    constructor computes the field contribution per bond, sets member variables and populates the heatbath probability tables\n\n    Args:\n        system (System): object representing the system to be simulated\n        gamma (float): offset added to weights reduce bounces\n    \"\"\"\n\n    super().__init__(system, gamma=gamma)\n\n    self.gamma = gamma\n\n    self.h_B = self.system.compute_h_B()\n\n    self.validate_system()\n\n    self.build()\n</code></pre>"},{"location":"api/preproc/probability_tables/#oqd_heisenberg_ion.simulators.qmc.long_range.preprocess.probability_table.heatbath.Heatbath.validate_system","title":"<code>validate_system</code>","text":"<p>validates the systema associated with the instance of the ProbabilityTable object</p> <p>Raises:</p> <ul> <li> <code>Exception</code>             \u2013            <p>if, for the specified hamiltonian name, heatbath sampling can not be used</p> </li> </ul> Source code in <code>src/oqd_heisenberg_ion/simulators/qmc/long_range/preprocess/probability_table/heatbath.py</code> <pre><code>def validate_system(self):\n    \"\"\"\n    validates the systema associated with the instance of the ProbabilityTable object\n\n    Raises:\n        Exception: if, for the specified hamiltonian name, heatbath sampling can not be used\n    \"\"\"\n\n    super().validate_system()\n\n    hamiltonian_name = self.system.hamiltonian_parameters.hamiltonian_name\n\n    if hamiltonian_name not in self.allowed_hamiltonians:\n        raise Exception(\n            \"Inconsistent hamiltonian and sampling types. Heatbath probability tables \"\n            \"only support the following types: {}\".format(self.allowed_hamiltonians)\n        )\n</code></pre>"},{"location":"api/preproc/probability_tables/#oqd_heisenberg_ion.simulators.qmc.long_range.preprocess.probability_table.heatbath.Heatbath.build","title":"<code>build</code>","text":"<p>populates the heatbath probability tables</p> Source code in <code>src/oqd_heisenberg_ion/simulators/qmc/long_range/preprocess/probability_table/heatbath.py</code> <pre><code>def build(self):\n    \"\"\"\n    populates the heatbath probability tables\n    \"\"\"\n\n    num_bonds = self.system.geometry.num_bonds\n    J_ij_vector = self.system.interactions.J_ij_vector\n    gamma = self.gamma\n    h_B = self.h_B\n    Delta = self.system.hamiltonian_parameters.Delta\n\n    self.initialize_tables(num_bonds)\n    self.compute_prob_tables_heat_bath(num_bonds, J_ij_vector, gamma, h_B, Delta)\n\n    return 0\n</code></pre>"},{"location":"api/preproc/probability_tables/#oqd_heisenberg_ion.simulators.qmc.long_range.preprocess.probability_table.heatbath.Heatbath.initialize_tables","title":"<code>initialize_tables</code>","text":"<p>initializes the probability tables needed for heatbath sampling</p> <p>Parameters:</p> <ul> <li> <code>num_bonds</code>               (<code>int</code>)           \u2013            <p>number of interacting bonds in the lattice</p> </li> </ul> Source code in <code>src/oqd_heisenberg_ion/simulators/qmc/long_range/preprocess/probability_table/heatbath.py</code> <pre><code>def initialize_tables(self, num_bonds):\n    \"\"\"\n    initializes the probability tables needed for heatbath sampling\n\n    Args:\n        num_bonds (int): number of interacting bonds in the lattice\n    \"\"\"\n\n    self.num_rows = vu.num_vertices * vu.num_legs_indices\n    self.heat_bath_prob_table = np.zeros((self.num_rows, num_bonds))\n\n    self.diag_prob_table = np.zeros((vu.num_diagonal_vertices, num_bonds))\n    self.max_over_states = np.zeros(num_bonds)\n    self.vertex_weights = np.zeros((vu.num_vertices, num_bonds))\n\n    self.spectrum_offset = 0.0\n    self.max_diag_norm = 0.0\n\n    return 0\n</code></pre>"},{"location":"api/preproc/probability_tables/#oqd_heisenberg_ion.simulators.qmc.long_range.preprocess.probability_table.heatbath.Heatbath.write_to_files","title":"<code>write_to_files</code>","text":"<p>writes the probability tables to csv files for SSE engine</p> <p>Parameters:</p> <ul> <li> <code>out_dir</code>               (<code>str</code>)           \u2013            <p>directory path for writing probability tables</p> </li> </ul> Source code in <code>src/oqd_heisenberg_ion/simulators/qmc/long_range/preprocess/probability_table/heatbath.py</code> <pre><code>def write_to_files(self, out_dir):\n    \"\"\"\n    writes the probability tables to csv files for SSE engine\n\n    Args:\n        out_dir (str): directory path for writing probability tables\n    \"\"\"\n\n    super().write_to_files(out_dir)\n\n    geometry_file_name = os.path.join(self.prob_dir, \"geometry.csv\")\n    diag_file_name = os.path.join(self.prob_dir, \"diag_probs.csv\")\n    max_over_states_file_name = os.path.join(self.prob_dir, \"max_over_states.csv\")\n    loop_update_table_file_name = os.path.join(self.prob_dir, \"off_diag_table.csv\")\n    vertex_weights_file_name = os.path.join(self.prob_dir, \"vertex_weights.csv\")\n\n    geometry_table = self.system.geometry.geometry_table\n    num_bonds = self.system.geometry.num_bonds\n    np.savetxt(geometry_file_name, geometry_table, delimiter=\",\", fmt=\"%d\", header=\"NumBonds={}\".format(num_bonds))\n\n    header = \"norm={},spectrum_offset={},loop_update_type={}\".format(\n        self.max_diag_norm, self.spectrum_offset, \"heatbath\"\n    )\n\n    np.savetxt(diag_file_name, self.diag_prob_table, delimiter=\",\", header=header)\n    np.savetxt(vertex_weights_file_name, self.vertex_weights, delimiter=\",\", header=header)\n    np.savetxt(max_over_states_file_name, self.max_over_states, delimiter=\",\", header=header)\n    np.savetxt(loop_update_table_file_name, self.heat_bath_prob_table, delimiter=\",\", header=header)\n\n    return 0\n</code></pre>"},{"location":"api/preproc/system/base/","title":"Base","text":""},{"location":"api/preproc/system/base/#oqd_heisenberg_ion.simulators.preprocess.system.base","title":"<code>oqd_heisenberg_ion.simulators.preprocess.system.base</code>","text":""},{"location":"api/preproc/system/base/#oqd_heisenberg_ion.simulators.preprocess.system.base.System","title":"<code>System</code>","text":"<p>Defines the model. This includes the Hamiltonian parameters, interaction strengths and the lattice geometry</p> Source code in <code>src/oqd_heisenberg_ion/simulators/preprocess/system/base.py</code> <pre><code>class System:\n    \"\"\"\n    Defines the model. This includes the Hamiltonian parameters, interaction strengths and the lattice geometry\n    \"\"\"\n\n    def __init__(self, **kwargs):\n        \"\"\"\n        Defines the system from key word arguments\n\n        Args:\n            **kwargs(dict): key word arguments required to specify the system\n        \"\"\"\n\n        self.model_name = kwargs[\"hamiltonian_name\"]\n        hamiltonian_args = HamiltonianFactory.extract_args(self.model_name, **kwargs)\n        self.hamiltonian_parameters = HamiltonianFactory.create(self.model_name, **hamiltonian_args)\n\n        self.geometry_name = (\n            kwargs[\"interaction_range\"]\n            + \"_\"\n            + kwargs[\"boundary\"]\n            + \"_\"\n            + kwargs[\"spatial_dimension\"]\n            + \"_\"\n            + kwargs[\"lattice_type\"]\n        )\n        geometry_args = GeometryFactory.extract_args(self.geometry_name, **kwargs)\n        self.geometry = GeometryFactory.create(self.geometry_name, **geometry_args)\n\n        self.interaction_range = kwargs[\"interaction_range\"]\n        self.interaction_name = self.get_interaction_name(kwargs)\n        self.interaction_args = InteractionsFactory.extract_args(self.interaction_name, **kwargs)\n        self.interactions = InteractionsFactory.create(self.interaction_name, self.geometry, **self.interaction_args)\n\n    def get_interaction_name(self, kwarg_dict):\n        \"\"\"\n        Extracts sets the interaction_name from inputs if long range interactions are specified by inputs\n\n        Args:\n            kwarg_dict (dict): contains the interaction_type key value pair\n\n        Returns:\n            (str): interaction name\n        \"\"\"\n\n        if self.interaction_range == \"long_range\":\n            return kwarg_dict[\"interaction_type\"]\n        else:\n            return self.interaction_range\n\n    def compute_h_B(self):\n        \"\"\"\n        computes the required h_B parameter for stochastic series expansion based on the field strength, the energy scale and the geometry\n\n        Returns:\n            (float): h_B, the field contribution of a single bond in SSE\n        \"\"\"\n\n        h = self.hamiltonian_parameters.h\n        J = self.hamiltonian_parameters.J\n        num_neighbors = self.geometry.num_neighbors_per_site\n\n        return h / (J * num_neighbors)\n\n    def update_parameters(self, parameter_dict):\n        \"\"\"\n        updates a dictionary with system parameters\n\n        Args:\n            parameter_dict (dict): parameter set specified as key word arguments\n\n        Returns:\n            (dict): updated parameter set\n        \"\"\"\n\n        self.hamiltonian_parameters.update_parameters(parameter_dict)\n        self.geometry.update_parameters(parameter_dict)\n\n        return parameter_dict\n</code></pre>"},{"location":"api/preproc/system/base/#oqd_heisenberg_ion.simulators.preprocess.system.base.System.__init__","title":"<code>__init__</code>","text":"<p>Defines the system from key word arguments</p> <p>Parameters:</p> <ul> <li> <code>**kwargs</code>               (<code>dict</code>, default:                   <code>{}</code> )           \u2013            <p>key word arguments required to specify the system</p> </li> </ul> Source code in <code>src/oqd_heisenberg_ion/simulators/preprocess/system/base.py</code> <pre><code>def __init__(self, **kwargs):\n    \"\"\"\n    Defines the system from key word arguments\n\n    Args:\n        **kwargs(dict): key word arguments required to specify the system\n    \"\"\"\n\n    self.model_name = kwargs[\"hamiltonian_name\"]\n    hamiltonian_args = HamiltonianFactory.extract_args(self.model_name, **kwargs)\n    self.hamiltonian_parameters = HamiltonianFactory.create(self.model_name, **hamiltonian_args)\n\n    self.geometry_name = (\n        kwargs[\"interaction_range\"]\n        + \"_\"\n        + kwargs[\"boundary\"]\n        + \"_\"\n        + kwargs[\"spatial_dimension\"]\n        + \"_\"\n        + kwargs[\"lattice_type\"]\n    )\n    geometry_args = GeometryFactory.extract_args(self.geometry_name, **kwargs)\n    self.geometry = GeometryFactory.create(self.geometry_name, **geometry_args)\n\n    self.interaction_range = kwargs[\"interaction_range\"]\n    self.interaction_name = self.get_interaction_name(kwargs)\n    self.interaction_args = InteractionsFactory.extract_args(self.interaction_name, **kwargs)\n    self.interactions = InteractionsFactory.create(self.interaction_name, self.geometry, **self.interaction_args)\n</code></pre>"},{"location":"api/preproc/system/base/#oqd_heisenberg_ion.simulators.preprocess.system.base.System.get_interaction_name","title":"<code>get_interaction_name</code>","text":"<p>Extracts sets the interaction_name from inputs if long range interactions are specified by inputs</p> <p>Parameters:</p> <ul> <li> <code>kwarg_dict</code>               (<code>dict</code>)           \u2013            <p>contains the interaction_type key value pair</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>str</code>           \u2013            <p>interaction name</p> </li> </ul> Source code in <code>src/oqd_heisenberg_ion/simulators/preprocess/system/base.py</code> <pre><code>def get_interaction_name(self, kwarg_dict):\n    \"\"\"\n    Extracts sets the interaction_name from inputs if long range interactions are specified by inputs\n\n    Args:\n        kwarg_dict (dict): contains the interaction_type key value pair\n\n    Returns:\n        (str): interaction name\n    \"\"\"\n\n    if self.interaction_range == \"long_range\":\n        return kwarg_dict[\"interaction_type\"]\n    else:\n        return self.interaction_range\n</code></pre>"},{"location":"api/preproc/system/base/#oqd_heisenberg_ion.simulators.preprocess.system.base.System.compute_h_B","title":"<code>compute_h_B</code>","text":"<p>computes the required h_B parameter for stochastic series expansion based on the field strength, the energy scale and the geometry</p> <p>Returns:</p> <ul> <li> <code>float</code>           \u2013            <p>h_B, the field contribution of a single bond in SSE</p> </li> </ul> Source code in <code>src/oqd_heisenberg_ion/simulators/preprocess/system/base.py</code> <pre><code>def compute_h_B(self):\n    \"\"\"\n    computes the required h_B parameter for stochastic series expansion based on the field strength, the energy scale and the geometry\n\n    Returns:\n        (float): h_B, the field contribution of a single bond in SSE\n    \"\"\"\n\n    h = self.hamiltonian_parameters.h\n    J = self.hamiltonian_parameters.J\n    num_neighbors = self.geometry.num_neighbors_per_site\n\n    return h / (J * num_neighbors)\n</code></pre>"},{"location":"api/preproc/system/base/#oqd_heisenberg_ion.simulators.preprocess.system.base.System.update_parameters","title":"<code>update_parameters</code>","text":"<p>updates a dictionary with system parameters</p> <p>Parameters:</p> <ul> <li> <code>parameter_dict</code>               (<code>dict</code>)           \u2013            <p>parameter set specified as key word arguments</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>dict</code>           \u2013            <p>updated parameter set</p> </li> </ul> Source code in <code>src/oqd_heisenberg_ion/simulators/preprocess/system/base.py</code> <pre><code>def update_parameters(self, parameter_dict):\n    \"\"\"\n    updates a dictionary with system parameters\n\n    Args:\n        parameter_dict (dict): parameter set specified as key word arguments\n\n    Returns:\n        (dict): updated parameter set\n    \"\"\"\n\n    self.hamiltonian_parameters.update_parameters(parameter_dict)\n    self.geometry.update_parameters(parameter_dict)\n\n    return parameter_dict\n</code></pre>"},{"location":"api/preproc/system/geometry/","title":"Geometry","text":""},{"location":"api/preproc/system/geometry/#oqd_heisenberg_ion.simulators.preprocess.system.geometry","title":"<code>oqd_heisenberg_ion.simulators.preprocess.system.geometry</code>","text":""},{"location":"api/preproc/system/geometry/#oqd_heisenberg_ion.simulators.preprocess.system.geometry.Geometry","title":"<code>Geometry</code>","text":"<p>Geometry base class to determine lattice properties</p> Source code in <code>src/oqd_heisenberg_ion/simulators/preprocess/system/geometry.py</code> <pre><code>class Geometry:\n    \"\"\"\n    Geometry base class to determine lattice properties\n    \"\"\"\n\n    args = {}\n\n    def __init__(self):\n        \"\"\"\n        constructor specifies the member variables that determine the lattice properties\n        \"\"\"\n\n        self.spatial_dimension = None\n\n        self.boundary = None\n        self.interaction_range = None\n        self.lattice_type = None\n\n        self.N_config = None\n        self.N = None\n        self.num_bonds = None\n        self.num_neighbors_per_site = None\n\n        self.sites = None\n        self.distances = None\n        self.geometry_table = None\n\n        self.bipartite = False\n\n    def initialize_tables(self):\n        \"\"\"\n        initialize the geometry table, distances and sites as numpy arrays\n        \"\"\"\n\n        self.geometry_table = np.zeros((self.num_bonds, 3))\n        self.distances = np.zeros(self.num_bonds)\n        self.sites = np.zeros((self.num_bonds, 2), dtype=int)\n\n    def build(self):\n        \"\"\"\n        Each Geometry subclass should implement a build function to populate the geometry tables\n        \"\"\"\n        pass\n\n    def update_parameters(self, parameter_dict):\n        \"\"\"\n        updates a given parameters set with lattice properties\n\n        Args:\n            parameter_dict (dict): single parameter set\n\n        Returns:\n            (dict): updated parameter set\n        \"\"\"\n\n        parameter_dict[\"spatial_dimension\"] = self.spatial_dimension\n        parameter_dict[\"boundary\"] = self.boundary\n        parameter_dict[\"interaction_range\"] = self.interaction_range\n        parameter_dict[\"N\"] = self.N\n        parameter_dict[\"num_bonds\"] = self.num_bonds\n\n        return parameter_dict\n</code></pre>"},{"location":"api/preproc/system/geometry/#oqd_heisenberg_ion.simulators.preprocess.system.geometry.Geometry.__init__","title":"<code>__init__</code>","text":"<p>constructor specifies the member variables that determine the lattice properties</p> Source code in <code>src/oqd_heisenberg_ion/simulators/preprocess/system/geometry.py</code> <pre><code>def __init__(self):\n    \"\"\"\n    constructor specifies the member variables that determine the lattice properties\n    \"\"\"\n\n    self.spatial_dimension = None\n\n    self.boundary = None\n    self.interaction_range = None\n    self.lattice_type = None\n\n    self.N_config = None\n    self.N = None\n    self.num_bonds = None\n    self.num_neighbors_per_site = None\n\n    self.sites = None\n    self.distances = None\n    self.geometry_table = None\n\n    self.bipartite = False\n</code></pre>"},{"location":"api/preproc/system/geometry/#oqd_heisenberg_ion.simulators.preprocess.system.geometry.Geometry.initialize_tables","title":"<code>initialize_tables</code>","text":"<p>initialize the geometry table, distances and sites as numpy arrays</p> Source code in <code>src/oqd_heisenberg_ion/simulators/preprocess/system/geometry.py</code> <pre><code>def initialize_tables(self):\n    \"\"\"\n    initialize the geometry table, distances and sites as numpy arrays\n    \"\"\"\n\n    self.geometry_table = np.zeros((self.num_bonds, 3))\n    self.distances = np.zeros(self.num_bonds)\n    self.sites = np.zeros((self.num_bonds, 2), dtype=int)\n</code></pre>"},{"location":"api/preproc/system/geometry/#oqd_heisenberg_ion.simulators.preprocess.system.geometry.Geometry.build","title":"<code>build</code>","text":"<p>Each Geometry subclass should implement a build function to populate the geometry tables</p> Source code in <code>src/oqd_heisenberg_ion/simulators/preprocess/system/geometry.py</code> <pre><code>def build(self):\n    \"\"\"\n    Each Geometry subclass should implement a build function to populate the geometry tables\n    \"\"\"\n    pass\n</code></pre>"},{"location":"api/preproc/system/geometry/#oqd_heisenberg_ion.simulators.preprocess.system.geometry.Geometry.update_parameters","title":"<code>update_parameters</code>","text":"<p>updates a given parameters set with lattice properties</p> <p>Parameters:</p> <ul> <li> <code>parameter_dict</code>               (<code>dict</code>)           \u2013            <p>single parameter set</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>dict</code>           \u2013            <p>updated parameter set</p> </li> </ul> Source code in <code>src/oqd_heisenberg_ion/simulators/preprocess/system/geometry.py</code> <pre><code>def update_parameters(self, parameter_dict):\n    \"\"\"\n    updates a given parameters set with lattice properties\n\n    Args:\n        parameter_dict (dict): single parameter set\n\n    Returns:\n        (dict): updated parameter set\n    \"\"\"\n\n    parameter_dict[\"spatial_dimension\"] = self.spatial_dimension\n    parameter_dict[\"boundary\"] = self.boundary\n    parameter_dict[\"interaction_range\"] = self.interaction_range\n    parameter_dict[\"N\"] = self.N\n    parameter_dict[\"num_bonds\"] = self.num_bonds\n\n    return parameter_dict\n</code></pre>"},{"location":"api/preproc/system/geometry/#oqd_heisenberg_ion.simulators.preprocess.system.geometry.GeometryFactory","title":"<code>GeometryFactory</code>","text":"<p>Factory for generating the required instance of the Geometry subclass. Carries a registry of Geometry subclasses</p> <p>Raises:</p> <ul> <li> <code>Exception</code>             \u2013            <p>if requested geometry subclass is not found</p> </li> </ul> Source code in <code>src/oqd_heisenberg_ion/simulators/preprocess/system/geometry.py</code> <pre><code>class GeometryFactory:\n    \"\"\"\n    Factory for generating the required instance of the Geometry subclass. Carries a registry of Geometry subclasses\n\n    Raises:\n        Exception: if requested geometry subclass is not found\n    \"\"\"\n\n    registry = {}\n\n    def register(cls, name, subclass):\n        \"\"\"\n        adds the specified subclass to the registry\n\n        Args:\n            name (str): name to be used for subclass\n            subclass (Type[Geometry]): Geometry subclass to be registered\n        \"\"\"\n\n        cls.registry[name] = subclass\n\n    def extract_args(cls, name, **kwargs):\n        \"\"\"\n        extracts the arguments associated with a given subclass\n\n        Args:\n            name (str): subclass name (must exist in registry)\n            **kwargs (dict): key word arguments. Must contain inputs for the specific subclass\n\n        Returns:\n            (dict): contains the subclass arguments as key value pairs\n        \"\"\"\n\n        arg_vals = {}\n        for key, arg_dtype in cls.registry[name].args.items():\n            arg_vals[key] = arg_dtype(kwargs[key])\n\n        return arg_vals\n\n    def create(cls, name, **kwargs):\n        \"\"\"\n        creates an instance of the subclass specified\n\n        Args:\n            name (str): name of requested subclass\n\n        Raises:\n            Exception: if the requested Geometry is not found in the registry\n\n        Returns:\n            (Geometry): instance of the the requested subclass\n        \"\"\"\n\n        if name not in cls.registry:\n            raise Exception(f\"Geometry implementation not found for geometry name: {name}\")\n        else:\n            return cls.registry[name](**kwargs)\n</code></pre>"},{"location":"api/preproc/system/geometry/#oqd_heisenberg_ion.simulators.preprocess.system.geometry.GeometryFactory.register","title":"<code>register</code>","text":"<p>adds the specified subclass to the registry</p> <p>Parameters:</p> <ul> <li> <code>name</code>               (<code>str</code>)           \u2013            <p>name to be used for subclass</p> </li> <li> <code>subclass</code>               (<code>Type[Geometry]</code>)           \u2013            <p>Geometry subclass to be registered</p> </li> </ul> Source code in <code>src/oqd_heisenberg_ion/simulators/preprocess/system/geometry.py</code> <pre><code>def register(cls, name, subclass):\n    \"\"\"\n    adds the specified subclass to the registry\n\n    Args:\n        name (str): name to be used for subclass\n        subclass (Type[Geometry]): Geometry subclass to be registered\n    \"\"\"\n\n    cls.registry[name] = subclass\n</code></pre>"},{"location":"api/preproc/system/geometry/#oqd_heisenberg_ion.simulators.preprocess.system.geometry.GeometryFactory.extract_args","title":"<code>extract_args</code>","text":"<p>extracts the arguments associated with a given subclass</p> <p>Parameters:</p> <ul> <li> <code>name</code>               (<code>str</code>)           \u2013            <p>subclass name (must exist in registry)</p> </li> <li> <code>**kwargs</code>               (<code>dict</code>, default:                   <code>{}</code> )           \u2013            <p>key word arguments. Must contain inputs for the specific subclass</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>dict</code>           \u2013            <p>contains the subclass arguments as key value pairs</p> </li> </ul> Source code in <code>src/oqd_heisenberg_ion/simulators/preprocess/system/geometry.py</code> <pre><code>def extract_args(cls, name, **kwargs):\n    \"\"\"\n    extracts the arguments associated with a given subclass\n\n    Args:\n        name (str): subclass name (must exist in registry)\n        **kwargs (dict): key word arguments. Must contain inputs for the specific subclass\n\n    Returns:\n        (dict): contains the subclass arguments as key value pairs\n    \"\"\"\n\n    arg_vals = {}\n    for key, arg_dtype in cls.registry[name].args.items():\n        arg_vals[key] = arg_dtype(kwargs[key])\n\n    return arg_vals\n</code></pre>"},{"location":"api/preproc/system/geometry/#oqd_heisenberg_ion.simulators.preprocess.system.geometry.GeometryFactory.create","title":"<code>create</code>","text":"<p>creates an instance of the subclass specified</p> <p>Parameters:</p> <ul> <li> <code>name</code>               (<code>str</code>)           \u2013            <p>name of requested subclass</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>Exception</code>             \u2013            <p>if the requested Geometry is not found in the registry</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Geometry</code>           \u2013            <p>instance of the the requested subclass</p> </li> </ul> Source code in <code>src/oqd_heisenberg_ion/simulators/preprocess/system/geometry.py</code> <pre><code>def create(cls, name, **kwargs):\n    \"\"\"\n    creates an instance of the subclass specified\n\n    Args:\n        name (str): name of requested subclass\n\n    Raises:\n        Exception: if the requested Geometry is not found in the registry\n\n    Returns:\n        (Geometry): instance of the the requested subclass\n    \"\"\"\n\n    if name not in cls.registry:\n        raise Exception(f\"Geometry implementation not found for geometry name: {name}\")\n    else:\n        return cls.registry[name](**kwargs)\n</code></pre>"},{"location":"api/preproc/system/geometry/#oqd_heisenberg_ion.simulators.preprocess.system.geometry.LongRangeOpenChain","title":"<code>LongRangeOpenChain</code>","text":"<p>               Bases: <code>Geometry</code></p> <p>implements a 1d lattice with long range interactions and open boundaries</p> Source code in <code>src/oqd_heisenberg_ion/simulators/preprocess/system/geometry.py</code> <pre><code>class LongRangeOpenChain(Geometry):\n    \"\"\"\n    implements a 1d lattice with long range interactions and open boundaries\n    \"\"\"\n\n    args = {\"N\": int}\n\n    def __init__(self, N):\n        \"\"\"\n        sets the member variables without constructing the tables.\n\n        Args:\n            N (int): number of sites\n        \"\"\"\n\n        super().__init__()\n\n        self.spatial_dimension = \"1d\"\n\n        self.boundary = \"open\"\n        self.interaction_range = \"long_range\"\n        self.lattice_type = \"chain\"\n\n        self.N = N\n        self.N_config = N\n        self.num_bonds = int(self.N * (self.N - 1) / 2)\n        self.num_neighbors_per_site = N - 1\n\n        # self.initialize_tables()\n        # self.build()\n\n    def initialize_tables(self):\n        \"\"\"\n        initializes the geometry tables\n        \"\"\"\n        return super().initialize_tables()\n\n    def build(self):\n        \"\"\"\n        populates the geometry tables\n        \"\"\"\n\n        self.initialize_tables()\n\n        b = 0\n        for i in range(self.N):\n            for j in range(i + 1, self.N):\n                self.sites[b, 0] = i\n                self.sites[b, 1] = j\n\n                self.distances[b] = j - i\n\n                self.geometry_table[b, 0] = i\n                self.geometry_table[b, 1] = j\n                self.geometry_table[b, 2] = self.distances[b]\n\n                b += 1\n</code></pre>"},{"location":"api/preproc/system/geometry/#oqd_heisenberg_ion.simulators.preprocess.system.geometry.LongRangeOpenChain.__init__","title":"<code>__init__</code>","text":"<p>sets the member variables without constructing the tables.</p> <p>Parameters:</p> <ul> <li> <code>N</code>               (<code>int</code>)           \u2013            <p>number of sites</p> </li> </ul> Source code in <code>src/oqd_heisenberg_ion/simulators/preprocess/system/geometry.py</code> <pre><code>def __init__(self, N):\n    \"\"\"\n    sets the member variables without constructing the tables.\n\n    Args:\n        N (int): number of sites\n    \"\"\"\n\n    super().__init__()\n\n    self.spatial_dimension = \"1d\"\n\n    self.boundary = \"open\"\n    self.interaction_range = \"long_range\"\n    self.lattice_type = \"chain\"\n\n    self.N = N\n    self.N_config = N\n    self.num_bonds = int(self.N * (self.N - 1) / 2)\n    self.num_neighbors_per_site = N - 1\n</code></pre>"},{"location":"api/preproc/system/geometry/#oqd_heisenberg_ion.simulators.preprocess.system.geometry.LongRangeOpenChain.initialize_tables","title":"<code>initialize_tables</code>","text":"<p>initializes the geometry tables</p> Source code in <code>src/oqd_heisenberg_ion/simulators/preprocess/system/geometry.py</code> <pre><code>def initialize_tables(self):\n    \"\"\"\n    initializes the geometry tables\n    \"\"\"\n    return super().initialize_tables()\n</code></pre>"},{"location":"api/preproc/system/geometry/#oqd_heisenberg_ion.simulators.preprocess.system.geometry.LongRangeOpenChain.build","title":"<code>build</code>","text":"<p>populates the geometry tables</p> Source code in <code>src/oqd_heisenberg_ion/simulators/preprocess/system/geometry.py</code> <pre><code>def build(self):\n    \"\"\"\n    populates the geometry tables\n    \"\"\"\n\n    self.initialize_tables()\n\n    b = 0\n    for i in range(self.N):\n        for j in range(i + 1, self.N):\n            self.sites[b, 0] = i\n            self.sites[b, 1] = j\n\n            self.distances[b] = j - i\n\n            self.geometry_table[b, 0] = i\n            self.geometry_table[b, 1] = j\n            self.geometry_table[b, 2] = self.distances[b]\n\n            b += 1\n</code></pre>"},{"location":"api/preproc/system/geometry/#oqd_heisenberg_ion.simulators.preprocess.system.geometry.LongRangePeriodicChain","title":"<code>LongRangePeriodicChain</code>","text":"<p>               Bases: <code>Geometry</code></p> <p>implements a 1d lattice with long range interactions and periodic boundaries</p> Source code in <code>src/oqd_heisenberg_ion/simulators/preprocess/system/geometry.py</code> <pre><code>class LongRangePeriodicChain(Geometry):\n    \"\"\"\n    implements a 1d lattice with long range interactions and periodic boundaries\n    \"\"\"\n\n    args = {\"N\": int}\n\n    def __init__(self, N):\n        \"\"\"\n        sets the member variables without constructing the tables.\n\n        Args:\n            N (int): number of sites\n        \"\"\"\n\n        super().__init__()\n\n        self.spatial_dimension = \"1d\"\n\n        self.boundary = \"periodic\"\n        self.interaction_range = \"long_range\"\n        self.lattice_type = \"chain\"\n\n        self.N = N\n        self.N_config = N\n        self.num_bonds = int(self.N * (self.N - 1) / 2)\n        self.num_neighbors_per_site = N - 1\n\n        # self.initialize_tables()\n        # self.build()\n\n    def initialize_tables(self):\n        \"\"\"\n        initializes the geometry tables\n        \"\"\"\n        return super().initialize_tables()\n\n    def build(self):\n        \"\"\"\n        populates the geometry tables\n        \"\"\"\n\n        self.initialize_tables()\n\n        b = 0\n        for i in range(self.N):\n            for j in range(i + 1, self.N):\n                self.sites[b, 0] = i\n                self.sites[b, 1] = j\n\n                self.geometry_table[b, 0] = i\n                self.geometry_table[b, 1] = j\n\n                if (j - i) &lt;= self.N - (j - i):\n                    self.distances[b] = j - i\n                    self.geometry_table[b, 2] = self.distances[b]\n                else:\n                    self.distances[b] = self.N - (j - i)\n                    self.geometry_table[b, 2] = -self.distances[b]\n\n                b += 1\n</code></pre>"},{"location":"api/preproc/system/geometry/#oqd_heisenberg_ion.simulators.preprocess.system.geometry.LongRangePeriodicChain.__init__","title":"<code>__init__</code>","text":"<p>sets the member variables without constructing the tables.</p> <p>Parameters:</p> <ul> <li> <code>N</code>               (<code>int</code>)           \u2013            <p>number of sites</p> </li> </ul> Source code in <code>src/oqd_heisenberg_ion/simulators/preprocess/system/geometry.py</code> <pre><code>def __init__(self, N):\n    \"\"\"\n    sets the member variables without constructing the tables.\n\n    Args:\n        N (int): number of sites\n    \"\"\"\n\n    super().__init__()\n\n    self.spatial_dimension = \"1d\"\n\n    self.boundary = \"periodic\"\n    self.interaction_range = \"long_range\"\n    self.lattice_type = \"chain\"\n\n    self.N = N\n    self.N_config = N\n    self.num_bonds = int(self.N * (self.N - 1) / 2)\n    self.num_neighbors_per_site = N - 1\n</code></pre>"},{"location":"api/preproc/system/geometry/#oqd_heisenberg_ion.simulators.preprocess.system.geometry.LongRangePeriodicChain.initialize_tables","title":"<code>initialize_tables</code>","text":"<p>initializes the geometry tables</p> Source code in <code>src/oqd_heisenberg_ion/simulators/preprocess/system/geometry.py</code> <pre><code>def initialize_tables(self):\n    \"\"\"\n    initializes the geometry tables\n    \"\"\"\n    return super().initialize_tables()\n</code></pre>"},{"location":"api/preproc/system/geometry/#oqd_heisenberg_ion.simulators.preprocess.system.geometry.LongRangePeriodicChain.build","title":"<code>build</code>","text":"<p>populates the geometry tables</p> Source code in <code>src/oqd_heisenberg_ion/simulators/preprocess/system/geometry.py</code> <pre><code>def build(self):\n    \"\"\"\n    populates the geometry tables\n    \"\"\"\n\n    self.initialize_tables()\n\n    b = 0\n    for i in range(self.N):\n        for j in range(i + 1, self.N):\n            self.sites[b, 0] = i\n            self.sites[b, 1] = j\n\n            self.geometry_table[b, 0] = i\n            self.geometry_table[b, 1] = j\n\n            if (j - i) &lt;= self.N - (j - i):\n                self.distances[b] = j - i\n                self.geometry_table[b, 2] = self.distances[b]\n            else:\n                self.distances[b] = self.N - (j - i)\n                self.geometry_table[b, 2] = -self.distances[b]\n\n            b += 1\n</code></pre>"},{"location":"api/preproc/system/geometry/#oqd_heisenberg_ion.simulators.preprocess.system.geometry.LongRangeOpenTriangular","title":"<code>LongRangeOpenTriangular</code>","text":"<p>               Bases: <code>Geometry</code></p> <p>implements a 2d triangular lattice with long range interactions and periodic boundaries (needs to be tested further)</p> Source code in <code>src/oqd_heisenberg_ion/simulators/preprocess/system/geometry.py</code> <pre><code>class LongRangeOpenTriangular(Geometry):\n    \"\"\"\n    implements a 2d triangular lattice with long range interactions and periodic boundaries (needs to be tested further)\n    \"\"\"\n\n    args = {\"N1\": int, \"N2\": int}\n\n    def __init__(self, N1, N2):\n        \"\"\"\n        sets the member variables without constructing the tables.\n\n        Args:\n            N1 (int): number of sites in the first spatial dimension\n            N2 (int): number of sites in the second spatial dimension\n        \"\"\"\n\n        super().__init__()\n\n        self.spatial_dimension = \"2d\"\n\n        self.boundary = \"periodic\"\n        self.interaction_range = \"long_range\"\n        self.lattice_type = \"chain\"\n\n        self.N = N1 * N2\n        self.N_config = (N1, N2)\n        self.num_bonds = int(self.N * (self.N - 1) / 2)\n        self.num_neighbors_per_site = self.N - 1\n\n        # self.initialize_tables()\n        # self.build()\n\n    def initialize_tables(self):\n        \"\"\"\n        initializes the geometry tables\n        \"\"\"\n        return super().initialize_tables()\n\n    def build(self):\n        \"\"\"\n        populates the geometry tables\n        \"\"\"\n\n        self.initialize_tables()\n\n        a_1 = np.array([1.0, 0.0])\n        a_2 = np.array([-0.5, np.sqrt(3.0) / 2.0])\n\n        N_1 = self.N_config[0]\n        N_2 = self.N_config[1]\n\n        b = 0\n        for i1 in range(N_1):\n            for i2 in range(N_2):\n                i = i1 * N_2 + i2\n\n                for j1 in range(N_1):\n                    for j2 in range(N_2):\n                        j = j1 * N_2 + j2\n\n                        if j &gt; i:\n                            self.sites[b, 0] = i\n                            self.sites[b, 1] = j\n\n                            self.distances[b] = np.norm((j1 - i1) * a_1 + (j2 - i2) * a_2)\n\n                            self.geometry_table[b, 0] = i\n                            self.geometry_table[b, 1] = j\n                            self.geometry_table[b, 2] = self.distances[b]\n\n                            b += 1\n</code></pre>"},{"location":"api/preproc/system/geometry/#oqd_heisenberg_ion.simulators.preprocess.system.geometry.LongRangeOpenTriangular.__init__","title":"<code>__init__</code>","text":"<p>sets the member variables without constructing the tables.</p> <p>Parameters:</p> <ul> <li> <code>N1</code>               (<code>int</code>)           \u2013            <p>number of sites in the first spatial dimension</p> </li> <li> <code>N2</code>               (<code>int</code>)           \u2013            <p>number of sites in the second spatial dimension</p> </li> </ul> Source code in <code>src/oqd_heisenberg_ion/simulators/preprocess/system/geometry.py</code> <pre><code>def __init__(self, N1, N2):\n    \"\"\"\n    sets the member variables without constructing the tables.\n\n    Args:\n        N1 (int): number of sites in the first spatial dimension\n        N2 (int): number of sites in the second spatial dimension\n    \"\"\"\n\n    super().__init__()\n\n    self.spatial_dimension = \"2d\"\n\n    self.boundary = \"periodic\"\n    self.interaction_range = \"long_range\"\n    self.lattice_type = \"chain\"\n\n    self.N = N1 * N2\n    self.N_config = (N1, N2)\n    self.num_bonds = int(self.N * (self.N - 1) / 2)\n    self.num_neighbors_per_site = self.N - 1\n</code></pre>"},{"location":"api/preproc/system/geometry/#oqd_heisenberg_ion.simulators.preprocess.system.geometry.LongRangeOpenTriangular.initialize_tables","title":"<code>initialize_tables</code>","text":"<p>initializes the geometry tables</p> Source code in <code>src/oqd_heisenberg_ion/simulators/preprocess/system/geometry.py</code> <pre><code>def initialize_tables(self):\n    \"\"\"\n    initializes the geometry tables\n    \"\"\"\n    return super().initialize_tables()\n</code></pre>"},{"location":"api/preproc/system/geometry/#oqd_heisenberg_ion.simulators.preprocess.system.geometry.LongRangeOpenTriangular.build","title":"<code>build</code>","text":"<p>populates the geometry tables</p> Source code in <code>src/oqd_heisenberg_ion/simulators/preprocess/system/geometry.py</code> <pre><code>def build(self):\n    \"\"\"\n    populates the geometry tables\n    \"\"\"\n\n    self.initialize_tables()\n\n    a_1 = np.array([1.0, 0.0])\n    a_2 = np.array([-0.5, np.sqrt(3.0) / 2.0])\n\n    N_1 = self.N_config[0]\n    N_2 = self.N_config[1]\n\n    b = 0\n    for i1 in range(N_1):\n        for i2 in range(N_2):\n            i = i1 * N_2 + i2\n\n            for j1 in range(N_1):\n                for j2 in range(N_2):\n                    j = j1 * N_2 + j2\n\n                    if j &gt; i:\n                        self.sites[b, 0] = i\n                        self.sites[b, 1] = j\n\n                        self.distances[b] = np.norm((j1 - i1) * a_1 + (j2 - i2) * a_2)\n\n                        self.geometry_table[b, 0] = i\n                        self.geometry_table[b, 1] = j\n                        self.geometry_table[b, 2] = self.distances[b]\n\n                        b += 1\n</code></pre>"},{"location":"api/preproc/system/geometry/#oqd_heisenberg_ion.simulators.preprocess.system.geometry.NearestNeighborPeriodicChain","title":"<code>NearestNeighborPeriodicChain</code>","text":"<p>               Bases: <code>Geometry</code></p> <p>implements a 1d lattice with nearest neighbor interactions and periodic boundaries</p> Source code in <code>src/oqd_heisenberg_ion/simulators/preprocess/system/geometry.py</code> <pre><code>class NearestNeighborPeriodicChain(Geometry):\n    \"\"\"\n    implements a 1d lattice with nearest neighbor interactions and periodic boundaries\n    \"\"\"\n\n    args = {\"N\": int}\n\n    def __init__(self, N):\n        \"\"\"\n        sets the member variables without constructing the tables.\n\n        Args:\n            N (int): number of sites\n        \"\"\"\n\n        self.spatial_dimension = \"1d\"\n\n        self.boundary = \"periodic\"\n        self.interaction_range = \"nearest_neighbor\"\n        self.lattice_type = \"chain\"\n\n        self.N_config = N\n        self.N = N\n        self.num_bonds = N\n        self.num_neighbors_per_site = 2\n\n        if self.N % 2 == 0:\n            self.bipartite = True\n        else:\n            self.bipartite = False\n\n        # self.initialize_tables()\n        # self.build()\n\n    def initialize_tables(self):\n        \"\"\"\n        initializes the geometry tables\n        \"\"\"\n        return super().initialize_tables()\n\n    def build(self):\n        \"\"\"\n        populates the geometry tables\n        \"\"\"\n\n        self.initialize_tables()\n\n        self.sites = np.zeros((self.num_bonds, 2), dtype=int)\n\n        for i in range(self.N - 1):\n            self.sites[i, 0] = i\n            self.sites[i, 1] = i + 1\n\n        self.sites[self.N - 1, 0] = 0\n        self.sites[self.N - 1, 1] = self.N - 1\n</code></pre>"},{"location":"api/preproc/system/geometry/#oqd_heisenberg_ion.simulators.preprocess.system.geometry.NearestNeighborPeriodicChain.__init__","title":"<code>__init__</code>","text":"<p>sets the member variables without constructing the tables.</p> <p>Parameters:</p> <ul> <li> <code>N</code>               (<code>int</code>)           \u2013            <p>number of sites</p> </li> </ul> Source code in <code>src/oqd_heisenberg_ion/simulators/preprocess/system/geometry.py</code> <pre><code>def __init__(self, N):\n    \"\"\"\n    sets the member variables without constructing the tables.\n\n    Args:\n        N (int): number of sites\n    \"\"\"\n\n    self.spatial_dimension = \"1d\"\n\n    self.boundary = \"periodic\"\n    self.interaction_range = \"nearest_neighbor\"\n    self.lattice_type = \"chain\"\n\n    self.N_config = N\n    self.N = N\n    self.num_bonds = N\n    self.num_neighbors_per_site = 2\n\n    if self.N % 2 == 0:\n        self.bipartite = True\n    else:\n        self.bipartite = False\n</code></pre>"},{"location":"api/preproc/system/geometry/#oqd_heisenberg_ion.simulators.preprocess.system.geometry.NearestNeighborPeriodicChain.initialize_tables","title":"<code>initialize_tables</code>","text":"<p>initializes the geometry tables</p> Source code in <code>src/oqd_heisenberg_ion/simulators/preprocess/system/geometry.py</code> <pre><code>def initialize_tables(self):\n    \"\"\"\n    initializes the geometry tables\n    \"\"\"\n    return super().initialize_tables()\n</code></pre>"},{"location":"api/preproc/system/geometry/#oqd_heisenberg_ion.simulators.preprocess.system.geometry.NearestNeighborPeriodicChain.build","title":"<code>build</code>","text":"<p>populates the geometry tables</p> Source code in <code>src/oqd_heisenberg_ion/simulators/preprocess/system/geometry.py</code> <pre><code>def build(self):\n    \"\"\"\n    populates the geometry tables\n    \"\"\"\n\n    self.initialize_tables()\n\n    self.sites = np.zeros((self.num_bonds, 2), dtype=int)\n\n    for i in range(self.N - 1):\n        self.sites[i, 0] = i\n        self.sites[i, 1] = i + 1\n\n    self.sites[self.N - 1, 0] = 0\n    self.sites[self.N - 1, 1] = self.N - 1\n</code></pre>"},{"location":"api/preproc/system/geometry/#oqd_heisenberg_ion.simulators.preprocess.system.geometry.NearestNeighborOpenChain","title":"<code>NearestNeighborOpenChain</code>","text":"<p>               Bases: <code>Geometry</code></p> <p>implements a 1d lattice with nearest neighbor interactions and open boundaries</p> Source code in <code>src/oqd_heisenberg_ion/simulators/preprocess/system/geometry.py</code> <pre><code>class NearestNeighborOpenChain(Geometry):\n    \"\"\"\n    implements a 1d lattice with nearest neighbor interactions and open boundaries\n    \"\"\"\n\n    args = {\"N\": int}\n\n    def __init__(self, N):\n        \"\"\"\n        sets the member variables without constructing the tables.\n\n        Args:\n            N (int): number of sites\n        \"\"\"\n\n        self.spatial_dimension = \"1d\"\n\n        self.boundary = \"periodic\"\n        self.interaction_range = \"nearest_neighbor\"\n        self.lattice_type = \"chain\"\n\n        self.N_config = N\n        self.N = N\n        self.num_bonds = N\n        self.num_neighbors_per_site = 2\n\n        self.bipartite = True\n\n        # self.initialize_tables()\n        # self.build()\n\n    def initialize_tables(self):\n        \"\"\"\n        initializes the geometry tables\n        \"\"\"\n        return super().initialize_tables()\n\n    def build(self):\n        \"\"\"\n        populates the geometry tables\n        \"\"\"\n\n        self.initialize_tables()\n\n        self.sites = np.zeros((self.num_bonds, 2), dtype=int)\n\n        for i in range(self.N - 1):\n            self.sites[i, 0] = i\n            self.sites[i, 1] = i + 1\n</code></pre>"},{"location":"api/preproc/system/geometry/#oqd_heisenberg_ion.simulators.preprocess.system.geometry.NearestNeighborOpenChain.__init__","title":"<code>__init__</code>","text":"<p>sets the member variables without constructing the tables.</p> <p>Parameters:</p> <ul> <li> <code>N</code>               (<code>int</code>)           \u2013            <p>number of sites</p> </li> </ul> Source code in <code>src/oqd_heisenberg_ion/simulators/preprocess/system/geometry.py</code> <pre><code>def __init__(self, N):\n    \"\"\"\n    sets the member variables without constructing the tables.\n\n    Args:\n        N (int): number of sites\n    \"\"\"\n\n    self.spatial_dimension = \"1d\"\n\n    self.boundary = \"periodic\"\n    self.interaction_range = \"nearest_neighbor\"\n    self.lattice_type = \"chain\"\n\n    self.N_config = N\n    self.N = N\n    self.num_bonds = N\n    self.num_neighbors_per_site = 2\n\n    self.bipartite = True\n</code></pre>"},{"location":"api/preproc/system/geometry/#oqd_heisenberg_ion.simulators.preprocess.system.geometry.NearestNeighborOpenChain.initialize_tables","title":"<code>initialize_tables</code>","text":"<p>initializes the geometry tables</p> Source code in <code>src/oqd_heisenberg_ion/simulators/preprocess/system/geometry.py</code> <pre><code>def initialize_tables(self):\n    \"\"\"\n    initializes the geometry tables\n    \"\"\"\n    return super().initialize_tables()\n</code></pre>"},{"location":"api/preproc/system/geometry/#oqd_heisenberg_ion.simulators.preprocess.system.geometry.NearestNeighborOpenChain.build","title":"<code>build</code>","text":"<p>populates the geometry tables</p> Source code in <code>src/oqd_heisenberg_ion/simulators/preprocess/system/geometry.py</code> <pre><code>def build(self):\n    \"\"\"\n    populates the geometry tables\n    \"\"\"\n\n    self.initialize_tables()\n\n    self.sites = np.zeros((self.num_bonds, 2), dtype=int)\n\n    for i in range(self.N - 1):\n        self.sites[i, 0] = i\n        self.sites[i, 1] = i + 1\n</code></pre>"},{"location":"api/preproc/system/hamiltonian/","title":"Hamiltonian","text":""},{"location":"api/preproc/system/hamiltonian/#oqd_heisenberg_ion.simulators.preprocess.system.hamiltonian","title":"<code>oqd_heisenberg_ion.simulators.preprocess.system.hamiltonian</code>","text":""},{"location":"api/preproc/system/hamiltonian/#oqd_heisenberg_ion.simulators.preprocess.system.hamiltonian.HamiltonianParameters","title":"<code>HamiltonianParameters</code>","text":"<p>Base class for Hamiltonian parameters</p> Source code in <code>src/oqd_heisenberg_ion/simulators/preprocess/system/hamiltonian.py</code> <pre><code>class HamiltonianParameters:\n    \"\"\"\n    Base class for Hamiltonian parameters\n    \"\"\"\n\n    args = {}\n\n    def __init__(self):\n        \"\"\"\n        initializes member variables\n        \"\"\"\n\n        self.hamiltonian_name = None\n        self.hamiltonian_type = None\n        self.Delta = None\n        self.h = None\n        self.J = None\n        self.B = None\n\n    def update_parameters(self, parameter_dict):\n        \"\"\"\n        updates the provided dictionary with hamiltonian parameters\n\n        Args:\n            parameter_dict (dict): dict to be updated\n\n        Returns:\n            (dict): updated dict containing the parameter set\n        \"\"\"\n\n        parameter_dict[\"hamiltonian_name\"] = self.hamiltonian_name\n        parameter_dict[\"hamiltonian_type\"] = self.hamiltonian_type\n        parameter_dict[\"Delta\"] = self.Delta\n        parameter_dict[\"h\"] = self.h\n        parameter_dict[\"J\"] = self.J\n        parameter_dict[\"B\"] = self.B\n\n        return parameter_dict\n</code></pre>"},{"location":"api/preproc/system/hamiltonian/#oqd_heisenberg_ion.simulators.preprocess.system.hamiltonian.HamiltonianParameters.__init__","title":"<code>__init__</code>","text":"<p>initializes member variables</p> Source code in <code>src/oqd_heisenberg_ion/simulators/preprocess/system/hamiltonian.py</code> <pre><code>def __init__(self):\n    \"\"\"\n    initializes member variables\n    \"\"\"\n\n    self.hamiltonian_name = None\n    self.hamiltonian_type = None\n    self.Delta = None\n    self.h = None\n    self.J = None\n    self.B = None\n</code></pre>"},{"location":"api/preproc/system/hamiltonian/#oqd_heisenberg_ion.simulators.preprocess.system.hamiltonian.HamiltonianParameters.update_parameters","title":"<code>update_parameters</code>","text":"<p>updates the provided dictionary with hamiltonian parameters</p> <p>Parameters:</p> <ul> <li> <code>parameter_dict</code>               (<code>dict</code>)           \u2013            <p>dict to be updated</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>dict</code>           \u2013            <p>updated dict containing the parameter set</p> </li> </ul> Source code in <code>src/oqd_heisenberg_ion/simulators/preprocess/system/hamiltonian.py</code> <pre><code>def update_parameters(self, parameter_dict):\n    \"\"\"\n    updates the provided dictionary with hamiltonian parameters\n\n    Args:\n        parameter_dict (dict): dict to be updated\n\n    Returns:\n        (dict): updated dict containing the parameter set\n    \"\"\"\n\n    parameter_dict[\"hamiltonian_name\"] = self.hamiltonian_name\n    parameter_dict[\"hamiltonian_type\"] = self.hamiltonian_type\n    parameter_dict[\"Delta\"] = self.Delta\n    parameter_dict[\"h\"] = self.h\n    parameter_dict[\"J\"] = self.J\n    parameter_dict[\"B\"] = self.B\n\n    return parameter_dict\n</code></pre>"},{"location":"api/preproc/system/hamiltonian/#oqd_heisenberg_ion.simulators.preprocess.system.hamiltonian.HamiltonianFactory","title":"<code>HamiltonianFactory</code>","text":"<p>Factory for generating the required instance of the HamiltonianParameters subclass. Carries a registry of HamiltonianParameters subclasses</p> <p>Raises:</p> <ul> <li> <code>Exception</code>             \u2013            <p>if requested subclass is not found</p> </li> </ul> Source code in <code>src/oqd_heisenberg_ion/simulators/preprocess/system/hamiltonian.py</code> <pre><code>class HamiltonianFactory:\n    \"\"\"\n    Factory for generating the required instance of the HamiltonianParameters subclass. Carries a registry of HamiltonianParameters subclasses\n\n    Raises:\n        Exception: if requested subclass is not found\n    \"\"\"\n\n    registry = {}\n\n    def register(cls, name, subclass):\n        \"\"\"\n        adds the specified subclass to the registry\n\n        Args:\n            name (str): name to be used for subclass\n            subclass (Type[HamiltonianParameters]): HamiltonianParameters subclass to be registered\n        \"\"\"\n\n        cls.registry[name] = subclass\n\n    def extract_args(cls, name, **kwargs):\n        \"\"\"\n        extracts the arguments associated with a given subclass\n\n        Args:\n            name (str): subclass name (must exist in registry)\n            **kwargs (dict): key word arguments. Must contain inputs for the specific subclass\n\n        Returns:\n            (dict): contains the subclass arguments as key value pairs\n        \"\"\"\n\n        arg_vals = {}\n        for key, arg_dtype in cls.registry[name].args.items():\n            arg_vals[key] = arg_dtype(kwargs[key])\n\n        return arg_vals\n\n    def create(cls, name, **kwargs):\n        \"\"\"\n        creates an instance of the subclass specified\n\n        Args:\n            name (str): name of requested subclass\n\n        Raises:\n            Exception: if the requested HamiltonianParameters subclass is not found in the registry\n\n        Returns:\n            (HamiltonianParameters): instance of the the requested subclass\n        \"\"\"\n\n        if name not in cls.registry:\n            raise Exception(f\"HamiltonianParameters implementation not found for name: {name}\")\n        else:\n            return cls.registry[name](**kwargs)\n</code></pre>"},{"location":"api/preproc/system/hamiltonian/#oqd_heisenberg_ion.simulators.preprocess.system.hamiltonian.HamiltonianFactory.register","title":"<code>register</code>","text":"<p>adds the specified subclass to the registry</p> <p>Parameters:</p> <ul> <li> <code>name</code>               (<code>str</code>)           \u2013            <p>name to be used for subclass</p> </li> <li> <code>subclass</code>               (<code>Type[HamiltonianParameters]</code>)           \u2013            <p>HamiltonianParameters subclass to be registered</p> </li> </ul> Source code in <code>src/oqd_heisenberg_ion/simulators/preprocess/system/hamiltonian.py</code> <pre><code>def register(cls, name, subclass):\n    \"\"\"\n    adds the specified subclass to the registry\n\n    Args:\n        name (str): name to be used for subclass\n        subclass (Type[HamiltonianParameters]): HamiltonianParameters subclass to be registered\n    \"\"\"\n\n    cls.registry[name] = subclass\n</code></pre>"},{"location":"api/preproc/system/hamiltonian/#oqd_heisenberg_ion.simulators.preprocess.system.hamiltonian.HamiltonianFactory.extract_args","title":"<code>extract_args</code>","text":"<p>extracts the arguments associated with a given subclass</p> <p>Parameters:</p> <ul> <li> <code>name</code>               (<code>str</code>)           \u2013            <p>subclass name (must exist in registry)</p> </li> <li> <code>**kwargs</code>               (<code>dict</code>, default:                   <code>{}</code> )           \u2013            <p>key word arguments. Must contain inputs for the specific subclass</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>dict</code>           \u2013            <p>contains the subclass arguments as key value pairs</p> </li> </ul> Source code in <code>src/oqd_heisenberg_ion/simulators/preprocess/system/hamiltonian.py</code> <pre><code>def extract_args(cls, name, **kwargs):\n    \"\"\"\n    extracts the arguments associated with a given subclass\n\n    Args:\n        name (str): subclass name (must exist in registry)\n        **kwargs (dict): key word arguments. Must contain inputs for the specific subclass\n\n    Returns:\n        (dict): contains the subclass arguments as key value pairs\n    \"\"\"\n\n    arg_vals = {}\n    for key, arg_dtype in cls.registry[name].args.items():\n        arg_vals[key] = arg_dtype(kwargs[key])\n\n    return arg_vals\n</code></pre>"},{"location":"api/preproc/system/hamiltonian/#oqd_heisenberg_ion.simulators.preprocess.system.hamiltonian.HamiltonianFactory.create","title":"<code>create</code>","text":"<p>creates an instance of the subclass specified</p> <p>Parameters:</p> <ul> <li> <code>name</code>               (<code>str</code>)           \u2013            <p>name of requested subclass</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>Exception</code>             \u2013            <p>if the requested HamiltonianParameters subclass is not found in the registry</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>HamiltonianParameters</code>           \u2013            <p>instance of the the requested subclass</p> </li> </ul> Source code in <code>src/oqd_heisenberg_ion/simulators/preprocess/system/hamiltonian.py</code> <pre><code>def create(cls, name, **kwargs):\n    \"\"\"\n    creates an instance of the subclass specified\n\n    Args:\n        name (str): name of requested subclass\n\n    Raises:\n        Exception: if the requested HamiltonianParameters subclass is not found in the registry\n\n    Returns:\n        (HamiltonianParameters): instance of the the requested subclass\n    \"\"\"\n\n    if name not in cls.registry:\n        raise Exception(f\"HamiltonianParameters implementation not found for name: {name}\")\n    else:\n        return cls.registry[name](**kwargs)\n</code></pre>"},{"location":"api/preproc/system/hamiltonian/#oqd_heisenberg_ion.simulators.preprocess.system.hamiltonian.FMHeisenbergAFMZ","title":"<code>FMHeisenbergAFMZ</code>","text":"<p>               Bases: <code>HamiltonianParameters</code></p> <p>ferromagnetic XXZ model with Delta = -1</p> Source code in <code>src/oqd_heisenberg_ion/simulators/preprocess/system/hamiltonian.py</code> <pre><code>class FMHeisenbergAFMZ(HamiltonianParameters):\n    \"\"\"\n    ferromagnetic XXZ model with Delta = -1\n    \"\"\"\n\n    args = {\"J\": float}\n\n    def __init__(self, J):\n        \"\"\"\n        sets the corresponding member variables\n\n        Args:\n            J (float): energy scale, must be positive for ferromagnetic interactions\n\n        Raises:\n            Exception: if J &lt;= 0\n        \"\"\"\n\n        super().__init__()\n\n        self.hamiltonian_name = \"fm_heisenberg_afm_Z\"\n        self.hamiltonian_type = -1\n        self.Delta = -1.0\n        self.h = 0.0\n        self.J = J\n        self.B = 0.0\n\n        if self.J &lt;= 0:\n            raise Exception(\"J must be positive for ferromagnetic interactions\")\n</code></pre>"},{"location":"api/preproc/system/hamiltonian/#oqd_heisenberg_ion.simulators.preprocess.system.hamiltonian.FMHeisenbergAFMZ.__init__","title":"<code>__init__</code>","text":"<p>sets the corresponding member variables</p> <p>Parameters:</p> <ul> <li> <code>J</code>               (<code>float</code>)           \u2013            <p>energy scale, must be positive for ferromagnetic interactions</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>Exception</code>             \u2013            <p>if J &lt;= 0</p> </li> </ul> Source code in <code>src/oqd_heisenberg_ion/simulators/preprocess/system/hamiltonian.py</code> <pre><code>def __init__(self, J):\n    \"\"\"\n    sets the corresponding member variables\n\n    Args:\n        J (float): energy scale, must be positive for ferromagnetic interactions\n\n    Raises:\n        Exception: if J &lt;= 0\n    \"\"\"\n\n    super().__init__()\n\n    self.hamiltonian_name = \"fm_heisenberg_afm_Z\"\n    self.hamiltonian_type = -1\n    self.Delta = -1.0\n    self.h = 0.0\n    self.J = J\n    self.B = 0.0\n\n    if self.J &lt;= 0:\n        raise Exception(\"J must be positive for ferromagnetic interactions\")\n</code></pre>"},{"location":"api/preproc/system/hamiltonian/#oqd_heisenberg_ion.simulators.preprocess.system.hamiltonian.XY","title":"<code>XY</code>","text":"<p>               Bases: <code>HamiltonianParameters</code></p> <p>XY model</p> Source code in <code>src/oqd_heisenberg_ion/simulators/preprocess/system/hamiltonian.py</code> <pre><code>class XY(HamiltonianParameters):\n    \"\"\"\n    XY model\n    \"\"\"\n\n    args = {\"J\": float}\n\n    def __init__(self, J):\n        \"\"\"\n        sets the corresponding member variables\n\n        Args:\n            J (float): energy scale\n        \"\"\"\n\n        super().__init__()\n\n        self.hamiltonian_name = \"XY\"\n        self.hamiltonian_type = 0\n        self.Delta = 0.0\n        self.h = 0.0\n        self.J = J\n        self.B = 0.0\n</code></pre>"},{"location":"api/preproc/system/hamiltonian/#oqd_heisenberg_ion.simulators.preprocess.system.hamiltonian.XY.__init__","title":"<code>__init__</code>","text":"<p>sets the corresponding member variables</p> <p>Parameters:</p> <ul> <li> <code>J</code>               (<code>float</code>)           \u2013            <p>energy scale</p> </li> </ul> Source code in <code>src/oqd_heisenberg_ion/simulators/preprocess/system/hamiltonian.py</code> <pre><code>def __init__(self, J):\n    \"\"\"\n    sets the corresponding member variables\n\n    Args:\n        J (float): energy scale\n    \"\"\"\n\n    super().__init__()\n\n    self.hamiltonian_name = \"XY\"\n    self.hamiltonian_type = 0\n    self.Delta = 0.0\n    self.h = 0.0\n    self.J = J\n    self.B = 0.0\n</code></pre>"},{"location":"api/preproc/system/hamiltonian/#oqd_heisenberg_ion.simulators.preprocess.system.hamiltonian.FMHeisenbergFMZ","title":"<code>FMHeisenbergFMZ</code>","text":"<p>               Bases: <code>HamiltonianParameters</code></p> <p>ferromagnetic Heisenberg model</p> <p>Raises:</p> <ul> <li> <code>Exception</code>             \u2013            <p>if input energy scale J &lt;= 0</p> </li> </ul> Source code in <code>src/oqd_heisenberg_ion/simulators/preprocess/system/hamiltonian.py</code> <pre><code>class FMHeisenbergFMZ(HamiltonianParameters):\n    \"\"\"\n    ferromagnetic Heisenberg model\n\n    Raises:\n        Exception: if input energy scale J &lt;= 0\n    \"\"\"\n\n    args = {\"J\": float}\n\n    def __init__(self, J):\n        \"\"\"\n        sets the corresponding member variables\n\n        Args:\n            J (float): energy scale, must be positive for ferromagnetic interactions\n\n        Raises:\n            Exception: if J &lt;= 0\n        \"\"\"\n\n        super().__init__()\n\n        self.hamiltonian_name = \"fm_heisenberg_fm_Z\"\n        self.hamiltonian_type = 1\n        self.Delta = 1.0\n        self.h = 0.0\n        self.J = J\n        self.B = 0.0\n\n        if self.J &lt;= 0:\n            raise Exception(\"J must be positive for ferromagnetic interactions\")\n</code></pre>"},{"location":"api/preproc/system/hamiltonian/#oqd_heisenberg_ion.simulators.preprocess.system.hamiltonian.FMHeisenbergFMZ.__init__","title":"<code>__init__</code>","text":"<p>sets the corresponding member variables</p> <p>Parameters:</p> <ul> <li> <code>J</code>               (<code>float</code>)           \u2013            <p>energy scale, must be positive for ferromagnetic interactions</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>Exception</code>             \u2013            <p>if J &lt;= 0</p> </li> </ul> Source code in <code>src/oqd_heisenberg_ion/simulators/preprocess/system/hamiltonian.py</code> <pre><code>def __init__(self, J):\n    \"\"\"\n    sets the corresponding member variables\n\n    Args:\n        J (float): energy scale, must be positive for ferromagnetic interactions\n\n    Raises:\n        Exception: if J &lt;= 0\n    \"\"\"\n\n    super().__init__()\n\n    self.hamiltonian_name = \"fm_heisenberg_fm_Z\"\n    self.hamiltonian_type = 1\n    self.Delta = 1.0\n    self.h = 0.0\n    self.J = J\n    self.B = 0.0\n\n    if self.J &lt;= 0:\n        raise Exception(\"J must be positive for ferromagnetic interactions\")\n</code></pre>"},{"location":"api/preproc/system/hamiltonian/#oqd_heisenberg_ion.simulators.preprocess.system.hamiltonian.XXZ","title":"<code>XXZ</code>","text":"<p>               Bases: <code>HamiltonianParameters</code></p> <p>XXZ model</p> Source code in <code>src/oqd_heisenberg_ion/simulators/preprocess/system/hamiltonian.py</code> <pre><code>class XXZ(HamiltonianParameters):\n    \"\"\"\n    XXZ model\n    \"\"\"\n\n    args = {\"Delta\": float, \"J\": float}\n\n    def __init__(self, Delta, J):\n        \"\"\"\n        sets the corresponding member variables\n\n        Args:\n            J (float): energy scale\n            Delta (float): coefficient of the Z_i Z_j term in the Hamiltonian\n        \"\"\"\n\n        super().__init__()\n\n        self.hamiltonian_name = \"XXZ\"\n        self.Delta = Delta\n        self.hamiltonian_type = 2\n        self.h = 0.0\n        self.J = J\n        self.B = 0.0\n</code></pre>"},{"location":"api/preproc/system/hamiltonian/#oqd_heisenberg_ion.simulators.preprocess.system.hamiltonian.XXZ.__init__","title":"<code>__init__</code>","text":"<p>sets the corresponding member variables</p> <p>Parameters:</p> <ul> <li> <code>J</code>               (<code>float</code>)           \u2013            <p>energy scale</p> </li> <li> <code>Delta</code>               (<code>float</code>)           \u2013            <p>coefficient of the Z_i Z_j term in the Hamiltonian</p> </li> </ul> Source code in <code>src/oqd_heisenberg_ion/simulators/preprocess/system/hamiltonian.py</code> <pre><code>def __init__(self, Delta, J):\n    \"\"\"\n    sets the corresponding member variables\n\n    Args:\n        J (float): energy scale\n        Delta (float): coefficient of the Z_i Z_j term in the Hamiltonian\n    \"\"\"\n\n    super().__init__()\n\n    self.hamiltonian_name = \"XXZ\"\n    self.Delta = Delta\n    self.hamiltonian_type = 2\n    self.h = 0.0\n    self.J = J\n    self.B = 0.0\n</code></pre>"},{"location":"api/preproc/system/hamiltonian/#oqd_heisenberg_ion.simulators.preprocess.system.hamiltonian.XXZh","title":"<code>XXZh</code>","text":"<p>               Bases: <code>HamiltonianParameters</code></p> <p>XXZ model with a longitudinal field</p> Source code in <code>src/oqd_heisenberg_ion/simulators/preprocess/system/hamiltonian.py</code> <pre><code>class XXZh(HamiltonianParameters):\n    \"\"\"\n    XXZ model with a longitudinal field\n    \"\"\"\n\n    args = {\"Delta\": float, \"h\": float, \"J\": float}\n\n    def __init__(self, Delta, h, J):\n        \"\"\"\n        sets the corresponding member variables\n\n        Args:\n            J (float): energy scale\n            Delta (float): coefficient of the Z_i Z_j term in the Hamiltonian\n            h (float): longitudinal field strength, must be positive for QMC\n        \"\"\"\n\n        super().__init__()\n\n        self.hamiltonian_name = \"XXZh\"\n        self.Delta = Delta\n        self.hamiltonian_type = 3\n        self.h = h\n        self.J = J\n        self.B = 0.0\n</code></pre>"},{"location":"api/preproc/system/hamiltonian/#oqd_heisenberg_ion.simulators.preprocess.system.hamiltonian.XXZh.__init__","title":"<code>__init__</code>","text":"<p>sets the corresponding member variables</p> <p>Parameters:</p> <ul> <li> <code>J</code>               (<code>float</code>)           \u2013            <p>energy scale</p> </li> <li> <code>Delta</code>               (<code>float</code>)           \u2013            <p>coefficient of the Z_i Z_j term in the Hamiltonian</p> </li> <li> <code>h</code>               (<code>float</code>)           \u2013            <p>longitudinal field strength, must be positive for QMC</p> </li> </ul> Source code in <code>src/oqd_heisenberg_ion/simulators/preprocess/system/hamiltonian.py</code> <pre><code>def __init__(self, Delta, h, J):\n    \"\"\"\n    sets the corresponding member variables\n\n    Args:\n        J (float): energy scale\n        Delta (float): coefficient of the Z_i Z_j term in the Hamiltonian\n        h (float): longitudinal field strength, must be positive for QMC\n    \"\"\"\n\n    super().__init__()\n\n    self.hamiltonian_name = \"XXZh\"\n    self.Delta = Delta\n    self.hamiltonian_type = 3\n    self.h = h\n    self.J = J\n    self.B = 0.0\n</code></pre>"},{"location":"api/preproc/system/hamiltonian/#oqd_heisenberg_ion.simulators.preprocess.system.hamiltonian.AFMHeisenbergFMZ","title":"<code>AFMHeisenbergFMZ</code>","text":"<p>               Bases: <code>HamiltonianParameters</code></p> <p>anti-ferromagnetic Heisenberg model</p> <p>Raises:</p> <ul> <li> <code>Exception</code>             \u2013            <p>if input energy scale J &gt;= 0</p> </li> </ul> Source code in <code>src/oqd_heisenberg_ion/simulators/preprocess/system/hamiltonian.py</code> <pre><code>class AFMHeisenbergFMZ(HamiltonianParameters):\n    \"\"\"\n    anti-ferromagnetic Heisenberg model\n\n    Raises:\n        Exception: if input energy scale J &gt;= 0\n    \"\"\"\n\n    args = {\"J\": float}\n\n    def __init__(self, J):\n        \"\"\"\n        sets the corresponding member variables\n\n        Args:\n            J (float): energy scale, must be negative for anti-ferromagnetic interactions\n\n        Raises:\n            Exception: if J &gt;= 0\n        \"\"\"\n\n        super().__init__()\n\n        self.hamiltonian_name = \"afm_heisenberg_fm_Z\"\n        self.hamiltonian_type = 4\n        self.Delta = 1.0\n        self.h = 0.0\n        self.J = J\n        self.B = 0.0\n\n        if self.J &gt;= 0:\n            raise Exception(\"J must be negative for anti-ferromagnetic interactions\")\n</code></pre>"},{"location":"api/preproc/system/hamiltonian/#oqd_heisenberg_ion.simulators.preprocess.system.hamiltonian.AFMHeisenbergFMZ.__init__","title":"<code>__init__</code>","text":"<p>sets the corresponding member variables</p> <p>Parameters:</p> <ul> <li> <code>J</code>               (<code>float</code>)           \u2013            <p>energy scale, must be negative for anti-ferromagnetic interactions</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>Exception</code>             \u2013            <p>if J &gt;= 0</p> </li> </ul> Source code in <code>src/oqd_heisenberg_ion/simulators/preprocess/system/hamiltonian.py</code> <pre><code>def __init__(self, J):\n    \"\"\"\n    sets the corresponding member variables\n\n    Args:\n        J (float): energy scale, must be negative for anti-ferromagnetic interactions\n\n    Raises:\n        Exception: if J &gt;= 0\n    \"\"\"\n\n    super().__init__()\n\n    self.hamiltonian_name = \"afm_heisenberg_fm_Z\"\n    self.hamiltonian_type = 4\n    self.Delta = 1.0\n    self.h = 0.0\n    self.J = J\n    self.B = 0.0\n\n    if self.J &gt;= 0:\n        raise Exception(\"J must be negative for anti-ferromagnetic interactions\")\n</code></pre>"},{"location":"api/preproc/system/hamiltonian/#oqd_heisenberg_ion.simulators.preprocess.system.hamiltonian.XXZhB","title":"<code>XXZhB</code>","text":"<p>               Bases: <code>HamiltonianParameters</code></p> <p>XXZ model with a longitudinal field and a transverse field. Only usable with ED</p> Source code in <code>src/oqd_heisenberg_ion/simulators/preprocess/system/hamiltonian.py</code> <pre><code>class XXZhB(HamiltonianParameters):\n    \"\"\"\n    XXZ model with a longitudinal field and a transverse field. Only usable with ED\n    \"\"\"\n\n    args = {\"Delta\": float, \"h\": float, \"B\": float, \"J\": float}\n\n    def __init__(self, Delta, h, B, J):\n        \"\"\"\n        sets the corresponding member variables\n\n        Args:\n            J (float): energy scale\n            Delta (float): coefficient of the Z_i Z_j term in the Hamiltonian\n            h (float): longitudinal field strength\n            B (float): transverse field strength\n        \"\"\"\n\n        super().__init__()\n\n        self.hamiltonian_name = \"XXZh\"\n        self.Delta = Delta\n        self.hamiltonian_type = 5\n        self.h = h\n        self.J = J\n        self.B = B\n</code></pre>"},{"location":"api/preproc/system/hamiltonian/#oqd_heisenberg_ion.simulators.preprocess.system.hamiltonian.XXZhB.__init__","title":"<code>__init__</code>","text":"<p>sets the corresponding member variables</p> <p>Parameters:</p> <ul> <li> <code>J</code>               (<code>float</code>)           \u2013            <p>energy scale</p> </li> <li> <code>Delta</code>               (<code>float</code>)           \u2013            <p>coefficient of the Z_i Z_j term in the Hamiltonian</p> </li> <li> <code>h</code>               (<code>float</code>)           \u2013            <p>longitudinal field strength</p> </li> <li> <code>B</code>               (<code>float</code>)           \u2013            <p>transverse field strength</p> </li> </ul> Source code in <code>src/oqd_heisenberg_ion/simulators/preprocess/system/hamiltonian.py</code> <pre><code>def __init__(self, Delta, h, B, J):\n    \"\"\"\n    sets the corresponding member variables\n\n    Args:\n        J (float): energy scale\n        Delta (float): coefficient of the Z_i Z_j term in the Hamiltonian\n        h (float): longitudinal field strength\n        B (float): transverse field strength\n    \"\"\"\n\n    super().__init__()\n\n    self.hamiltonian_name = \"XXZh\"\n    self.Delta = Delta\n    self.hamiltonian_type = 5\n    self.h = h\n    self.J = J\n    self.B = B\n</code></pre>"},{"location":"api/preproc/system/interactions/","title":"Interactions","text":""},{"location":"api/preproc/system/interactions/#oqd_heisenberg_ion.simulators.preprocess.system.interactions","title":"<code>oqd_heisenberg_ion.simulators.preprocess.system.interactions</code>","text":""},{"location":"api/preproc/system/interactions/#oqd_heisenberg_ion.simulators.preprocess.system.interactions.InteractionsFactory","title":"<code>InteractionsFactory</code>","text":"<p>Factory for generating the required instance of the Interactions subclass. Carries a registry of Interactions subclasses</p> <p>Raises:</p> <ul> <li> <code>Exception</code>             \u2013            <p>if requested subclass is not found</p> </li> </ul> Source code in <code>src/oqd_heisenberg_ion/simulators/preprocess/system/interactions.py</code> <pre><code>class InteractionsFactory:\n    \"\"\"\n    Factory for generating the required instance of the Interactions subclass. Carries a registry of Interactions subclasses\n\n    Raises:\n        Exception: if requested subclass is not found\n    \"\"\"\n\n    registry = {}\n\n    def register(cls, name, subclass):\n        \"\"\"\n        adds the specified subclass to the registry\n\n        Args:\n            name (str): name to be used for subclass\n            subclass (Type[Interactions]): Interactions subclass to be registered\n        \"\"\"\n\n        cls.registry[name] = subclass\n\n    def extract_args(cls, name, **kwargs):\n        \"\"\"\n        extracts the arguments associated with a given subclass\n\n        Args:\n            name (str): subclass name (must exist in registry)\n            **kwargs (dict): key word arguments. Must contain inputs for the specific subclass\n\n        Returns:\n            (dict): contains the subclass arguments as key value pairs\n        \"\"\"\n\n        arg_vals = {}\n        for key, arg_dtype in cls.registry[name].args.items():\n            arg_vals[key] = arg_dtype(kwargs[key])\n\n        return arg_vals\n\n    def create(cls, name, geometry, **kwargs):\n        \"\"\"\n        creates an instance of the subclass specified\n\n        Args:\n            name (str): name of requested subclass\n\n        Raises:\n            Exception: if the requested Interactions subclass is not found in the registry\n\n        Returns:\n            (Interactions): instance of the the requested subclass\n        \"\"\"\n\n        if name not in cls.registry:\n            raise Exception(f\"Interactions implementation not found for interaction name: {name}\")\n        else:\n            return cls.registry[name](geometry, **kwargs)\n</code></pre>"},{"location":"api/preproc/system/interactions/#oqd_heisenberg_ion.simulators.preprocess.system.interactions.InteractionsFactory.register","title":"<code>register</code>","text":"<p>adds the specified subclass to the registry</p> <p>Parameters:</p> <ul> <li> <code>name</code>               (<code>str</code>)           \u2013            <p>name to be used for subclass</p> </li> <li> <code>subclass</code>               (<code>Type[Interactions]</code>)           \u2013            <p>Interactions subclass to be registered</p> </li> </ul> Source code in <code>src/oqd_heisenberg_ion/simulators/preprocess/system/interactions.py</code> <pre><code>def register(cls, name, subclass):\n    \"\"\"\n    adds the specified subclass to the registry\n\n    Args:\n        name (str): name to be used for subclass\n        subclass (Type[Interactions]): Interactions subclass to be registered\n    \"\"\"\n\n    cls.registry[name] = subclass\n</code></pre>"},{"location":"api/preproc/system/interactions/#oqd_heisenberg_ion.simulators.preprocess.system.interactions.InteractionsFactory.extract_args","title":"<code>extract_args</code>","text":"<p>extracts the arguments associated with a given subclass</p> <p>Parameters:</p> <ul> <li> <code>name</code>               (<code>str</code>)           \u2013            <p>subclass name (must exist in registry)</p> </li> <li> <code>**kwargs</code>               (<code>dict</code>, default:                   <code>{}</code> )           \u2013            <p>key word arguments. Must contain inputs for the specific subclass</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>dict</code>           \u2013            <p>contains the subclass arguments as key value pairs</p> </li> </ul> Source code in <code>src/oqd_heisenberg_ion/simulators/preprocess/system/interactions.py</code> <pre><code>def extract_args(cls, name, **kwargs):\n    \"\"\"\n    extracts the arguments associated with a given subclass\n\n    Args:\n        name (str): subclass name (must exist in registry)\n        **kwargs (dict): key word arguments. Must contain inputs for the specific subclass\n\n    Returns:\n        (dict): contains the subclass arguments as key value pairs\n    \"\"\"\n\n    arg_vals = {}\n    for key, arg_dtype in cls.registry[name].args.items():\n        arg_vals[key] = arg_dtype(kwargs[key])\n\n    return arg_vals\n</code></pre>"},{"location":"api/preproc/system/interactions/#oqd_heisenberg_ion.simulators.preprocess.system.interactions.InteractionsFactory.create","title":"<code>create</code>","text":"<p>creates an instance of the subclass specified</p> <p>Parameters:</p> <ul> <li> <code>name</code>               (<code>str</code>)           \u2013            <p>name of requested subclass</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>Exception</code>             \u2013            <p>if the requested Interactions subclass is not found in the registry</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Interactions</code>           \u2013            <p>instance of the the requested subclass</p> </li> </ul> Source code in <code>src/oqd_heisenberg_ion/simulators/preprocess/system/interactions.py</code> <pre><code>def create(cls, name, geometry, **kwargs):\n    \"\"\"\n    creates an instance of the subclass specified\n\n    Args:\n        name (str): name of requested subclass\n\n    Raises:\n        Exception: if the requested Interactions subclass is not found in the registry\n\n    Returns:\n        (Interactions): instance of the the requested subclass\n    \"\"\"\n\n    if name not in cls.registry:\n        raise Exception(f\"Interactions implementation not found for interaction name: {name}\")\n    else:\n        return cls.registry[name](geometry, **kwargs)\n</code></pre>"},{"location":"api/preproc/system/interactions/#oqd_heisenberg_ion.simulators.preprocess.system.interactions.Interactions","title":"<code>Interactions</code>","text":"<p>Interactions base class. Different types of interactions implemented as subclasses</p> Source code in <code>src/oqd_heisenberg_ion/simulators/preprocess/system/interactions.py</code> <pre><code>class Interactions:\n    \"\"\"\n    Interactions base class. Different types of interactions implemented as subclasses\n    \"\"\"\n\n    def __init__(self, geometry):\n        \"\"\"\n        constructor initializes the member variables\n\n        Args:\n            geometry (Geometry): contains contains the lattice sites and distances\n        \"\"\"\n\n        self.geometry = geometry\n        self.J_ij_matrix = None\n        self.J_ij_vector = None\n        self.J_ij_file = None\n\n    def get_J_ij(self):\n        \"\"\"\n        every Interactions subclass must implement a method to populate the interaction matrix\n        \"\"\"\n\n        pass\n</code></pre>"},{"location":"api/preproc/system/interactions/#oqd_heisenberg_ion.simulators.preprocess.system.interactions.Interactions.__init__","title":"<code>__init__</code>","text":"<p>constructor initializes the member variables</p> <p>Parameters:</p> <ul> <li> <code>geometry</code>               (<code>Geometry</code>)           \u2013            <p>contains contains the lattice sites and distances</p> </li> </ul> Source code in <code>src/oqd_heisenberg_ion/simulators/preprocess/system/interactions.py</code> <pre><code>def __init__(self, geometry):\n    \"\"\"\n    constructor initializes the member variables\n\n    Args:\n        geometry (Geometry): contains contains the lattice sites and distances\n    \"\"\"\n\n    self.geometry = geometry\n    self.J_ij_matrix = None\n    self.J_ij_vector = None\n    self.J_ij_file = None\n</code></pre>"},{"location":"api/preproc/system/interactions/#oqd_heisenberg_ion.simulators.preprocess.system.interactions.Interactions.get_J_ij","title":"<code>get_J_ij</code>","text":"<p>every Interactions subclass must implement a method to populate the interaction matrix</p> Source code in <code>src/oqd_heisenberg_ion/simulators/preprocess/system/interactions.py</code> <pre><code>def get_J_ij(self):\n    \"\"\"\n    every Interactions subclass must implement a method to populate the interaction matrix\n    \"\"\"\n\n    pass\n</code></pre>"},{"location":"api/preproc/system/interactions/#oqd_heisenberg_ion.simulators.preprocess.system.interactions.MatrixInput","title":"<code>MatrixInput</code>","text":"<p>               Bases: <code>Interactions</code></p> <p>Used when the interactions are specified via an input file containing an coupling matrix</p> Source code in <code>src/oqd_heisenberg_ion/simulators/preprocess/system/interactions.py</code> <pre><code>class MatrixInput(Interactions):\n    \"\"\"\n    Used when the interactions are specified via an input file containing an coupling matrix\n    \"\"\"\n\n    args = {\"interaction_matrix_file\": str}\n\n    def __init__(self, geometry, interaction_matrix_file):\n        \"\"\"\n        populates the J_ij vector from file\n\n        Args:\n            geometry (Geometry): contains the lattice sites and distances\n            interaction_matrix_file (str): file path to the interaction matrix file\n        \"\"\"\n\n        super().__init__(geometry)\n\n        self.J_ij_file = interaction_matrix_file\n        geometry.initialize_tables()\n        self.get_J_ij(geometry.N, geometry.num_bonds, self.J_ij_file)\n\n    def get_J_ij(self, N, num_bonds, interaction_matrix_file):\n        \"\"\"\n        populates the J_ij vector with the coupling strength for each bond\n\n        Args:\n            N (int): number of sites in the lattice\n            num_bonds (int): number of bonds in the lattice\n            interaction_matrix_file (str): file path to the interactions matrix\n        \"\"\"\n\n        self.J_ij_matrix = np.loadtxt(interaction_matrix_file, delimiter=\",\", skiprows=1)\n        self.J_ij_vector = np.zeros(num_bonds)\n        b = 0\n        for i in range(N):\n            for j in range(i + 1, N):\n                self.J_ij_vector[b] = self.J_ij_matrix[i, j]\n                b += 1\n\n    def write_to_file(self, target_file):\n        \"\"\"\n        copies the input J_ij matrix to specified directory\n\n        Args:\n            target_file (str): path to target file\n        \"\"\"\n\n        sh.copyfile(self.J_ij_file, target_file)\n</code></pre>"},{"location":"api/preproc/system/interactions/#oqd_heisenberg_ion.simulators.preprocess.system.interactions.MatrixInput.__init__","title":"<code>__init__</code>","text":"<p>populates the J_ij vector from file</p> <p>Parameters:</p> <ul> <li> <code>geometry</code>               (<code>Geometry</code>)           \u2013            <p>contains the lattice sites and distances</p> </li> <li> <code>interaction_matrix_file</code>               (<code>str</code>)           \u2013            <p>file path to the interaction matrix file</p> </li> </ul> Source code in <code>src/oqd_heisenberg_ion/simulators/preprocess/system/interactions.py</code> <pre><code>def __init__(self, geometry, interaction_matrix_file):\n    \"\"\"\n    populates the J_ij vector from file\n\n    Args:\n        geometry (Geometry): contains the lattice sites and distances\n        interaction_matrix_file (str): file path to the interaction matrix file\n    \"\"\"\n\n    super().__init__(geometry)\n\n    self.J_ij_file = interaction_matrix_file\n    geometry.initialize_tables()\n    self.get_J_ij(geometry.N, geometry.num_bonds, self.J_ij_file)\n</code></pre>"},{"location":"api/preproc/system/interactions/#oqd_heisenberg_ion.simulators.preprocess.system.interactions.MatrixInput.get_J_ij","title":"<code>get_J_ij</code>","text":"<p>populates the J_ij vector with the coupling strength for each bond</p> <p>Parameters:</p> <ul> <li> <code>N</code>               (<code>int</code>)           \u2013            <p>number of sites in the lattice</p> </li> <li> <code>num_bonds</code>               (<code>int</code>)           \u2013            <p>number of bonds in the lattice</p> </li> <li> <code>interaction_matrix_file</code>               (<code>str</code>)           \u2013            <p>file path to the interactions matrix</p> </li> </ul> Source code in <code>src/oqd_heisenberg_ion/simulators/preprocess/system/interactions.py</code> <pre><code>def get_J_ij(self, N, num_bonds, interaction_matrix_file):\n    \"\"\"\n    populates the J_ij vector with the coupling strength for each bond\n\n    Args:\n        N (int): number of sites in the lattice\n        num_bonds (int): number of bonds in the lattice\n        interaction_matrix_file (str): file path to the interactions matrix\n    \"\"\"\n\n    self.J_ij_matrix = np.loadtxt(interaction_matrix_file, delimiter=\",\", skiprows=1)\n    self.J_ij_vector = np.zeros(num_bonds)\n    b = 0\n    for i in range(N):\n        for j in range(i + 1, N):\n            self.J_ij_vector[b] = self.J_ij_matrix[i, j]\n            b += 1\n</code></pre>"},{"location":"api/preproc/system/interactions/#oqd_heisenberg_ion.simulators.preprocess.system.interactions.MatrixInput.write_to_file","title":"<code>write_to_file</code>","text":"<p>copies the input J_ij matrix to specified directory</p> <p>Parameters:</p> <ul> <li> <code>target_file</code>               (<code>str</code>)           \u2013            <p>path to target file</p> </li> </ul> Source code in <code>src/oqd_heisenberg_ion/simulators/preprocess/system/interactions.py</code> <pre><code>def write_to_file(self, target_file):\n    \"\"\"\n    copies the input J_ij matrix to specified directory\n\n    Args:\n        target_file (str): path to target file\n    \"\"\"\n\n    sh.copyfile(self.J_ij_file, target_file)\n</code></pre>"},{"location":"api/preproc/system/interactions/#oqd_heisenberg_ion.simulators.preprocess.system.interactions.PowerLaw","title":"<code>PowerLaw</code>","text":"<p>               Bases: <code>Interactions</code></p> <p>Used to generate the coupling using power law J_ij = 1/r_{ij}^alpha</p> Source code in <code>src/oqd_heisenberg_ion/simulators/preprocess/system/interactions.py</code> <pre><code>class PowerLaw(Interactions):\n    \"\"\"\n    Used to generate the coupling using power law J_ij = 1/r_{ij}^alpha\n    \"\"\"\n\n    args = {\"alpha\": float}\n\n    def __init__(self, geometry, alpha):\n        \"\"\"\n        constructs the coupling matrix\n\n        Args:\n            geometry (Geometry): contains the lattice sites and distances\n            alpha (float): power law interaction strength exponent\n        \"\"\"\n\n        super().__init__(geometry)\n\n        self.alpha = alpha\n        self.geometry.initialize_tables()\n        self.geometry.build()\n        self.get_J_ij(self.geometry.num_bonds, self.geometry.distances, self.alpha)\n\n    def get_J_ij(self, num_bonds, distances, alpha):\n        \"\"\"\n        populates the J_ij matrix\n\n        Args:\n            num_bonds (int): number of bonds\n            distances (numpy.ndarray[float]): num_bonds x 1 array containing the distances between all pairs of interacting sites\n            alpha (float): interaction strength exponent\n        \"\"\"\n\n        N = self.geometry.N\n        self.J_ij_vector = np.zeros(num_bonds)\n        self.J_ij_matrix = np.zeros((N, N))\n        b = 0\n        for i in range(N):\n            for j in range(i + 1, N):\n                r_pow_alpha = (distances[b]) ** alpha\n                self.J_ij_matrix[i, j] = 1.0 / r_pow_alpha\n                self.J_ij_matrix[j, i] = 1.0 / r_pow_alpha\n                self.J_ij_vector[b] = 1.0 / r_pow_alpha\n                b += 1\n\n    def write_to_file(self, target_file):\n        \"\"\"\n        writes the J_ij matrix to file\n\n        Args:\n            target_file (str): path to target file\n        \"\"\"\n\n        np.savetxt(\n            target_file,\n            self.J_ij_matrix,\n            delimiter=\",\",\n            header=f\"J_ij_matrix, interactions=power_law,alpha={self.alpha}\",\n        )\n</code></pre>"},{"location":"api/preproc/system/interactions/#oqd_heisenberg_ion.simulators.preprocess.system.interactions.PowerLaw.__init__","title":"<code>__init__</code>","text":"<p>constructs the coupling matrix</p> <p>Parameters:</p> <ul> <li> <code>geometry</code>               (<code>Geometry</code>)           \u2013            <p>contains the lattice sites and distances</p> </li> <li> <code>alpha</code>               (<code>float</code>)           \u2013            <p>power law interaction strength exponent</p> </li> </ul> Source code in <code>src/oqd_heisenberg_ion/simulators/preprocess/system/interactions.py</code> <pre><code>def __init__(self, geometry, alpha):\n    \"\"\"\n    constructs the coupling matrix\n\n    Args:\n        geometry (Geometry): contains the lattice sites and distances\n        alpha (float): power law interaction strength exponent\n    \"\"\"\n\n    super().__init__(geometry)\n\n    self.alpha = alpha\n    self.geometry.initialize_tables()\n    self.geometry.build()\n    self.get_J_ij(self.geometry.num_bonds, self.geometry.distances, self.alpha)\n</code></pre>"},{"location":"api/preproc/system/interactions/#oqd_heisenberg_ion.simulators.preprocess.system.interactions.PowerLaw.get_J_ij","title":"<code>get_J_ij</code>","text":"<p>populates the J_ij matrix</p> <p>Parameters:</p> <ul> <li> <code>num_bonds</code>               (<code>int</code>)           \u2013            <p>number of bonds</p> </li> <li> <code>distances</code>               (<code>ndarray[float]</code>)           \u2013            <p>num_bonds x 1 array containing the distances between all pairs of interacting sites</p> </li> <li> <code>alpha</code>               (<code>float</code>)           \u2013            <p>interaction strength exponent</p> </li> </ul> Source code in <code>src/oqd_heisenberg_ion/simulators/preprocess/system/interactions.py</code> <pre><code>def get_J_ij(self, num_bonds, distances, alpha):\n    \"\"\"\n    populates the J_ij matrix\n\n    Args:\n        num_bonds (int): number of bonds\n        distances (numpy.ndarray[float]): num_bonds x 1 array containing the distances between all pairs of interacting sites\n        alpha (float): interaction strength exponent\n    \"\"\"\n\n    N = self.geometry.N\n    self.J_ij_vector = np.zeros(num_bonds)\n    self.J_ij_matrix = np.zeros((N, N))\n    b = 0\n    for i in range(N):\n        for j in range(i + 1, N):\n            r_pow_alpha = (distances[b]) ** alpha\n            self.J_ij_matrix[i, j] = 1.0 / r_pow_alpha\n            self.J_ij_matrix[j, i] = 1.0 / r_pow_alpha\n            self.J_ij_vector[b] = 1.0 / r_pow_alpha\n            b += 1\n</code></pre>"},{"location":"api/preproc/system/interactions/#oqd_heisenberg_ion.simulators.preprocess.system.interactions.PowerLaw.write_to_file","title":"<code>write_to_file</code>","text":"<p>writes the J_ij matrix to file</p> <p>Parameters:</p> <ul> <li> <code>target_file</code>               (<code>str</code>)           \u2013            <p>path to target file</p> </li> </ul> Source code in <code>src/oqd_heisenberg_ion/simulators/preprocess/system/interactions.py</code> <pre><code>def write_to_file(self, target_file):\n    \"\"\"\n    writes the J_ij matrix to file\n\n    Args:\n        target_file (str): path to target file\n    \"\"\"\n\n    np.savetxt(\n        target_file,\n        self.J_ij_matrix,\n        delimiter=\",\",\n        header=f\"J_ij_matrix, interactions=power_law,alpha={self.alpha}\",\n    )\n</code></pre>"},{"location":"api/preproc/system/interactions/#oqd_heisenberg_ion.simulators.preprocess.system.interactions.NearestNeighbors","title":"<code>NearestNeighbors</code>","text":"<p>               Bases: <code>Interactions</code></p> <p>interactions for a nearest neighbor lattice</p> Source code in <code>src/oqd_heisenberg_ion/simulators/preprocess/system/interactions.py</code> <pre><code>class NearestNeighbors(Interactions):\n    \"\"\"\n    interactions for a nearest neighbor lattice\n    \"\"\"\n\n    args = {}\n\n    def __init__(self, geometry):\n        \"\"\"\n        calls the base class constructor, no interaction matrix is needed\n\n        Args:\n            geometry (Geometry): contains the lattice sites and distances\n        \"\"\"\n\n        super().__init__(geometry)\n</code></pre>"},{"location":"api/preproc/system/interactions/#oqd_heisenberg_ion.simulators.preprocess.system.interactions.NearestNeighbors.__init__","title":"<code>__init__</code>","text":"<p>calls the base class constructor, no interaction matrix is needed</p> <p>Parameters:</p> <ul> <li> <code>geometry</code>               (<code>Geometry</code>)           \u2013            <p>contains the lattice sites and distances</p> </li> </ul> Source code in <code>src/oqd_heisenberg_ion/simulators/preprocess/system/interactions.py</code> <pre><code>def __init__(self, geometry):\n    \"\"\"\n    calls the base class constructor, no interaction matrix is needed\n\n    Args:\n        geometry (Geometry): contains the lattice sites and distances\n    \"\"\"\n\n    super().__init__(geometry)\n</code></pre>"},{"location":"user_guide/hamiltonian_types/","title":"Hamiltonian Types","text":"<p>The general anisotropic Heisenberg model admits a variety of special cases such as the XY point (\\(\\Delta = h = 0\\)) and the ferromagnetic isotropic point (\\(\\Delta = 1, h = 0\\)). It can be shown that the vanilla SSE algorithm allows for tremendous optimizations for such special cases due to the increased symmetry of the resulting Hamiltonians. These are referred to as deterministic algorithms and are implemented separately in the Heisenberg Ion package. Moreover, for long range interactions, we first need to construct probability tables that can be used in the sampling process. For nearest-neighbors, no probability tables need to be constructed. Therefore, the deterministic points for nearest-neighbor Hamiltonians can be optimized further. Heisenberg Ion offers a separate SSE implementation for these nearest neighbor edge cases as well. The complete list of Hamiltonian types in the Heisenberg Ion package is as follows: </p>"},{"location":"user_guide/hamiltonian_types/#xxz-with-longitudinal-transverse-fields","title":"XXZ with Longitudinal &amp; Transverse Fields","text":"<p>Hamiltonian:</p> \\[ H = - \\sum_{i &lt; j} J_{ij} \\left( S_x^i S_x^j + S_y^i S_y^j + \\Delta S_z^i S_z^j \\right) + h\\sum_{i} S_z^i \\label{long_range_xxzhb} \\] <ul> <li>Supported Sampling Types: None. This can only be used with ED.  </li> <li>Parameters: \\(J_{ij}, \\Delta, h, B \\in \\mathbb{R}\\).  </li> <li>Remarks: Because of the transverse field, the \\(U(1)\\) symmetry is broken. Therefore, SSE is not supported for this Hamiltonian. </li> <li>Hamiltonian Name: XXZhB</li> </ul>"},{"location":"user_guide/hamiltonian_types/#xxz-with-a-longitudinal-field","title":"XXZ with a Longitudinal Field","text":"<p>Hamiltonian:</p> \\[ H = - \\sum_{i &lt; j} J_{ij} \\left( S_x^i S_x^j + S_y^i S_y^j + \\Delta S_z^i S_z^j \\right) + h\\sum_{i} S_z^i \\label{long_range_xxzh} \\] <ul> <li>Supported Sampling Types: Heatbath or directed loops  </li> <li>Parameters: \\(J_{ij}, \\Delta, h \\in \\mathbb{R}\\), \\(h \\geq 0\\).  </li> <li>Remarks: We restrict to \\(h \\geq 0\\) for SSE since the physics of this system is invariant under the transformation \\(h \\rightarrow -h\\). Moreover, for SSE, we also restrict to ferromagnetic interactions \\(J_{ij} &gt; 0\\) to avoid the sign problem. </li> <li>Hamiltonian Name: XXZh</li> </ul>"},{"location":"user_guide/hamiltonian_types/#xxz","title":"XXZ","text":"<p>Hamiltonian:</p> \\[ H = - \\sum_{i &lt; j} J_{ij} \\left( S_x^i S_x^j + S_y^i S_y^j + \\Delta S_z^i S_z^j \\right) \\label{long_range_xxz} \\] <ul> <li>Supported Sampling Types: Heatbath or directed loops   </li> <li>Parameters: \\(J_{ij}, \\Delta \\in \\mathbb{R}\\) </li> <li>Remarks: This allows for a flipping of all the spins in the lattice in SSE because of the \\(\\mathbb{Z}_2\\) symmetry in the absence of the longitudinal field. For SSE with this model, we restrict to ferromagnetic interactions \\(J_{ij} &gt; 0\\) to avoid the sign problem.</li> <li>Hamiltonian Name: XXZ </li> </ul>"},{"location":"user_guide/hamiltonian_types/#ferromagnetic-isotropic-heisenberg","title":"Ferromagnetic Isotropic Heisenberg","text":"<p>Hamiltonian:</p> \\[ H = - \\sum_{i &lt; j} J_{ij} \\left( S_x^i S_x^j + S_y^i S_y^j + S_z^i S_z^j \\right) \\label{long_range_iso_fm} \\] <ul> <li>Supported Sampling Types: Deterministic </li> <li>Parameters: \\(J_{ij} &gt; 0 \\in \\mathbb{R}\\)</li> <li>Remarks: This model admits a constant SSE weight representation which allows for deterministic SSE loop construction. We restrict to ferromagnetic interactions in general: \\(J_{ij} &gt; 0\\). For ED with anti-ferromagnetic interactions, this can be realized using the general XXZ Hamiltonian and appropriately setting \\(J_ij\\) and \\(\\Delta\\). On a bipartite lattice, this model, with \\(J &gt; 0, \\Delta = 1\\), is equivalent to the anti-ferromagnetic variant (\\(J &lt; 0\\)) with \\(\\Delta = -1\\).</li> <li>Hamiltonian Name: fm_heisenberg_fm_Z</li> </ul>"},{"location":"user_guide/hamiltonian_types/#ferromagnetic-xxz-with-anti-ferromagnetic-diagonals","title":"Ferromagnetic XXZ with Anti-ferromagnetic Diagonals","text":"<p>Hamiltonian:</p> \\[ H = - \\sum_{i &lt; j} J_{ij} \\left( S_x^i S_x^j + S_y^i S_y^j - S_z^i S_z^j \\right) \\label{long_range_iso_afm} \\] <ul> <li>Supported Sampling Types: Deterministic  </li> <li>Parameters: \\(J_{ij} &gt; 0 \\in \\mathbb{R}\\)</li> <li>Remarks: This model admits a constant SSE weight representation which allows for deterministic SSE loop construction. Note that the \\(S_z^i S_z^j\\) term in this model has a negative coefficient, as opposed to the positive coefficient in Eq. \\(\\eqref{long_range_iso_afm}\\). For SSE, we restrict to ferromagnetic interactions: \\(J_{ij} &gt; 0\\). For ED with anti-ferromagnetic interactions, this can be realized using the general XXZ Hamiltonian and appropriately setting \\(J_ij\\) and \\(\\Delta\\). On a bipartite lattice, this model, with \\(J &gt; 0, \\Delta = -1\\), is equivalent to the anti-ferromagnetic variant (\\(J &lt; 0\\)) with \\(\\Delta = 1\\).</li> <li>Hamiltonian Name: fm_heisenberg_afm_Z</li> </ul>"},{"location":"user_guide/hamiltonian_types/#xy","title":"XY","text":"<p>Hamiltonian: </p> \\[ H = - \\sum_{i &lt; j} J_{ij} \\left( S_x^i S_x^j + S_y^i S_y^j\\right) \\label{long_range_xy} \\] <ul> <li>Supported Sampling Types: Deterministic  </li> <li>Parameters: \\(J_{ij} \\in \\mathbb{R}\\)</li> <li>Remarks: This model admits a constant SSE weight representation which allows for deterministic SSE loop construction. For SSE, we restrict to ferromagnetic interactions: \\(J_{ij} &gt; 0\\). On a bipartite lattice, this Hamiltonian is equivalent to its anti-ferromagnetic (corresponding to \\(J_{ij} &lt; 0\\)) variant via a sub-lattice rotation. </li> <li>Hamiltonian Name: XY</li> </ul>"},{"location":"user_guide/hamiltonian_types/#anti-ferromagnetic-isotropic","title":"Anti-ferromagnetic Isotropic","text":"<p>Hamiltonian:</p> \\[ H = - \\sum_{i &lt; j} J_{ij} \\left( S_x^i S_x^{j} + S_y^i S_y^{j} + S_z^i S_z^{j}\\right) \\label{nn_iso_afm} \\] <ul> <li>Supported Sampling Types: Deterministic</li> <li>Parameters:  \\(J_{ij} &lt; 0 \\in \\mathbb{R}\\)</li> <li>Remarks: In SSE, this model can only be used with nearest-neighbor interactions to avoid the sign problem because of the anti-ferromagnetic couplings. Sampling is deterministic. This model, with \\(J &lt; 0, \\Delta = 1\\), is equivalent to the ferromagnetic variant (\\(J &gt; 0\\)) with \\(\\Delta = -1\\) on a bipartite lattice. For ED, again the more general \\(XXZ\\) Hamiltonian can be configured to simulate both ferromagnetic and anti-ferromagnetic interactions with this model. </li> <li>Hamiltonian Name: afm_heisenberg_fm_Z</li> </ul>"},{"location":"user_guide/input_specs/","title":"Input Specification","text":"<p>Heisenberg Ion offers multiple entry points. The canonical approaches are to either use a tab delimited input file to call the Python package from the command line/python script, or specify the parameters in the main Python script directly. However, each of the simulator engines can also be called directly from the command line using a tab-delimited input file prepared specifically for those simulators. This section details some of the natural entry points and also describes all the possible inputs that can to be provided, depending on user requirments.  </p>"},{"location":"user_guide/input_specs/#list-of-parameters","title":"List of Parameters","text":"<p>This section lists all of the parameters that can be used to configure a simulation. </p>"},{"location":"user_guide/input_specs/#categorical-inputs","title":"Categorical Inputs","text":"<p>The following categorical inputs always need to be specified:</p> Parameter Description Allowed Values simulator Simulator name long_range_qmc , nearest_neighbor_qmc , exact_diagonalization hamiltonian_name Hamiltonian name XY , XXZ , XXZh , XXZhB , fm_heisenberg_fm_Z , fm_heisenberg_afm_Z , afm_heisenberg_fm_Z boundary Spatial boundary conditions open , periodic interaction_range Range of interactions long_range , nearest_neighbors interaction_type Type of interactions power_law , matrix_input spatial_dimension Lattice dimension 1d lattice_type Type of geometry rectangular <p>All of the above parameters can be specified as strings.</p>"},{"location":"user_guide/input_specs/#numerical-hamiltonian-specifications","title":"Numerical Hamiltonian Specifications","text":"<p>Depending on the Hamiltonian specified, more parameters might be required to configure the system. The following table lists all the numerical inputs that can be used to define the Hamiltonian:  </p> Parameter Type Description N Integer Number of sites in the lattice. Always required Delta Float Coefficient of the \\(S_z^i S_z^j\\) term in the Hamiltonian. Required for XXZ, XXZh and XXZhB hamiltonian_names alpha Float Defines \\(\\alpha\\) for power law interactions \\(\\left(J_{ij} = 1/r_{ij}^\\alpha\\right)\\). Required if interaction_range is set to long_range and the interaction_type is power_law h Float Longitudinal field strength. Required for XXZh and XXZhB hamiltonian_names J Float Energy scale of the XXZ Hamiltonian. Always required B Float Transverse field strength. Required for the XXZhB hamiltonian_name theta Float Boundary phase twist angle (required for computing spin stiffness in ED). Only used if simulator is set to exact_diagonalization"},{"location":"user_guide/input_specs/#sampling-monte-carlo-parameters","title":"Sampling &amp; Monte Carlo Parameters","text":"<p>If one of the QMC simulators are selected (long_range_qmc or nearest_neighbor_qmc), we need to provide sampling parameters as well. The following table lists all of the sampling parameters that can be specified:</p> Parameter Type Description T Float Temperature needed to define the propagator \\(\\left(\\rho = \\frac{1}{Z} e^{H/T}\\right)\\) loop_type Categorical QMC update type. Can be deterministic, heatbath or directed_loop equilibration_steps Int Number of equilibration steps simulation_steps Int Number of steps for observable estimation operator_list_update_multiplier Float Rate of operator list growth in QMC. Should always be greater than 1 gamma Float Additional shift used in heatbath and directed_loop probability tables. Should always be greater than 0 ksi Float Yes distance_dependent_offset Bool Determines whether an additional bond dependent offset should be used in directed loop probabilites track_spin_configurations Bool Flag to determine whether QMC shot data should be recorded write_final_spin_configuration Bool Flag to determine whether the final QMC configuration should be recorded initial_configuration_index Int Initial configuration of spins. 1 or -1 starts the simulation with all spins up or down respectively. 0 picks each spin randomly. -2 uses the configuration provided. Positive integers k &gt; 1 correspond to lattice site i starting with spin up if i mod k = 0 initial_configuration_file_path String Path to file with initial spin configurations for QMC. Used if initial_configuration_index is -2 initial_operator_list_size Int Starting size of operator list (M) in QMC. When set to -1, uses default value of M=50 number_of_threads Int Number of threads to use if multiple long range QMC calculations are requested. If set to -1, the number of threads is determined to be equal to the number of parameter sets <p>A complete list of QMC algorithms and their target Hamiltonians can be found in the List of SSE Algorithms section of the Algorithns tab.  </p>"},{"location":"user_guide/input_specs/#monte-carlo-seeds","title":"Monte Carlo Seeds","text":"<p>We can also optionally specify seeds to initialize the random number generator needed for QMC. The following table lists the different seeds that can be provided to the SSE |simulators:</p> Seed Name Description initial_config_seed Used if the initial_config_index is set to 0 to randomly pick the starting configuration of each spin disconnected_spin_flip_seed In SSE, disconnected spins can be flipped independently. This seed initializes the generator used for those spin flips off_diagonal_update_seed Needed to seed the off-diagonal update random number generators metropolis_insert_seed Needed to seed the generator used in the Metropolis step of diagonal operator insertions metropolis_remove_seed Needed to seed the generator used in the Metropolis step of diagonal operator insertions diagonal_update_seed Only used for long range QMC. Needed to sample the bond index for operator insertions in diagonal updates exit_leg_seed Only needed for XY, XXZ and XXZh hamiltonian types. Used to initialize generator for selecting exit legs while constructing loops metropolis_bond_generator_seed Only needed for XXZ and XXZh hamiltonian types. Used to probabilistically insert operators at a given bond in diagonal update step in the two-step scheme"},{"location":"user_guide/input_specs/#conflicting-inputs","title":"Conflicting Inputs","text":"<p>Note that if contradictory inputs are specified for the Hamiltonian, (for instance if the input <code>hamiltonian_name</code> is <code>XY</code> and <code>Delta</code> is specified to be <code>1.0</code>), the system specification defaults to properties defined by the <code>hamiltonian_name</code> (the provided value of <code>Delta</code> is ignored). The same is true for specifying the interactions. If the <code>interaction_range</code> is set to <code>nearest_neighbor</code> and the <code>interaction_type</code> is specified to be <code>power_law</code>, the latter is ignored. Similarly, conflicting inputs pertaining to QMC sampler settings are resolved via the <code>loop_type</code> parameter. </p>"},{"location":"user_guide/input_specs/#directory-specification","title":"Directory Specification","text":"<p>In addition to simulation parameters, we also need to provide the output directories (which can be specified as strings). The following tables lists all directory parameters: </p> Parameter Description root_folder Root folder in which the outputs will be stored. Always required bin_folder Directory containing the C++ binaries. If not provided, the Python driver will attempt to compile the C++ program itself. Only required for long_range_qmc cpp_source_folder C++ source files for the long range QMC implementation. If neither the bin_folder nor the cpp_source_folder is provided, the preprocessor attempts to locate the Cpp source files julia_path Path to Julia binaries for the ED simulator. Only needed if the simulator is exact_diagonalization uuid The UUID corresponding to each simulation. If not provided, a unique ID for each simulation is produced by the preprocessor output_folder_name The top-level output folder for the entire program execution. If not provided, the datetime stamp of execution is used to create this directory"},{"location":"user_guide/input_specs/#multiple-parameter-sets","title":"Multiple Parameter Sets","text":"<p>Heisenberg Ion also supports the specification of multiple parameter sets in a single input file. For long range QMC, this allows for the multi-threaded execution of multiple parameter sets simultaneously. For other simulators, this simply iterates over all the parameter sets. To use this functionality, simply replace the value of the parameter(s) that need to iterated over by a comma delimited list of values in the followsing manner: </p> <pre><code>simulator   long_range_qmc\nhamiltonian_name    XY\ninteraction_range   long_range\ninteraction_type    power_law\nN   4,5,6,7\nalpha   1.0,2.0,3.0,4.0\nloop_type   deterministic\n</code></pre> <p>The above example specifies 4 long range QMC runs for the long range XY model with power law interactions using the deterministic loop SSE algorithm. The 4 parameter sets are: \\((N, \\alpha) = (4,1.0), (5,2.0), (6,3.0), (7,4.0)\\). It should be noted that for certain parameters, multple values would not be meaningful and so providing multiple inputs for those fields results in an exception. These parameters are as follows:  </p> <pre><code>simulator\nroot_folder\nsimulation_folder\nnumber_of_threads\noutput_folder_name\n</code></pre>"},{"location":"user_guide/input_specs/#example-parameter-settings","title":"Example Parameter Settings","text":"<p>In this section, we provide example input specifications for ED and QMC. </p>"},{"location":"user_guide/input_specs/#exact-diagonalization","title":"Exact Diagonalization","text":"<pre><code>simulator   exact_diagonalization\n\n# System Parameters\nhamiltonian_name    XY\nboundary    periodic\ninteraction_range   long_range\ninteraction_type    power_law\nalpha   1.0\nspatial_dimension   1d\nlattice_type    rectangular\nN   4,5,6\nJ   1.0\ntheta   0.0\n\n# Output Parameters\nroot_folder ./results\n</code></pre>"},{"location":"user_guide/input_specs/#long-range-quantum-monte-carlo","title":"Long Range Quantum Monte Carlo","text":"<pre><code>simulator   long_range_qmc\n\n# System Parameters\nhamiltonian_name    XY\nboundary    periodic\ninteraction_range   long_range\ninteraction_type    power_law\nalpha   1.0\nspatial_dimension   1d\nlattice_type    rectangular\nN   11,12,13\nJ   1.0\n\n# Simulation Parameters\nT   0.05\nequilibration_steps 100000\nsimulation_steps    100000\noperator_list_update_multiplier 1.05\nloop_type   deterministic\nnumber_of_threads   1\n\n# Output Parameters\nroot_folder ./results\ntrack_spin_configurations   True\nwrite_final_spin_configuration  False\n\n# Initial Configuration Parameters\ninitial_configuration_index 0\ninitial_operator_list_size  -1\n\n# Seeds\ninitial_config_seed 845886\ndisconnected_spin_flip_seed 255995\noff_diagonal_update_seed    893908\nmetropolis_insert_seed  222288\nmetropolis_remove_seed  625433\ndiagonal_update_seed    419814\nexit_leg_seed   525338\n</code></pre>"},{"location":"user_guide/input_specs/#nearest-neighbor-quantum-monte-carlo","title":"Nearest Neighbor Quantum Monte Carlo","text":"<pre><code>simulator   nearest_neighbor_qmc\n\n# System Parameters\nhamiltonian_name    XY\nboundary    periodic\ninteraction_range   nearest_neighbor\nspatial_dimension   1d\nlattice_type    rectangular\nN   11,12,13\nJ   1.0\n\n# Simulation Parameters\nT   0.1\nequilibration_steps 100000\nsimulation_steps    100000\noperator_list_update_multiplier 1.1\nloop_type   deterministic\n\n# Output Parameters\nroot_folder ./results\ntrack_spin_configurations   True\nwrite_final_spin_configuration  False\n\n# Initial Configuration Parameters\ninitial_configuration_index 0\ninitial_operator_list_size  -1\n\n# Seeds\ninitial_config_seed 845886\ndisconnected_spin_flip_seed 255995\noff_diagonal_update_seed    893908\nmetropolis_insert_seed  222288\nmetropolis_remove_seed  625433\ndiagonal_update_seed    419814\nexit_leg_seed   525338\n</code></pre>"},{"location":"user_guide/output_format/","title":"Output Files","text":"<p>The outputs for each calculation are stored in output .csv files produced by each engine. The output directory is determined based on the provided inputs. Here, we explain the general output structure for each simulator. </p>"},{"location":"user_guide/output_format/#output-directory-structure","title":"Output Directory Structure","text":"<p>The top-level output folder is the value provided for the 'root_folder' parameter input. This must exist for the simulation to proceed. In this directory, another folder is created to contain the outputs, the name of which can be specified using the 'output_folder_name' parameter. If no 'output_folder_name' is specified, the datetime stamp of the run is used to name this folder. </p> <p>A tab-delimited input file for each simulator engine (written by the preprocessor) is stored in this output folder, alongside the output folders for each parameter set simulation. The directories corresponding to each parameter set can be named by specifying the uuid field in the input settings. If no uuids are provided, a unique ID is generated by the preprocessor. This simulation output folder will also contain any global logs and C++ build directories. The following tree diagram exhibits two different simulation output folders (named 'output_folder_1' and 'output_folder_2'). </p> <pre><code>root_folder/\n\u251c\u2500\u2500 output_folder_1/\n\u2502 \u251c\u2500\u2500 inputs.txt\n\u2502 \u251c\u2500\u2500 global.log\n\u2502 \u2514\u2500\u2500 build/\n\u2502 \u2514\u2500\u2500 uuid_1/\n\u2502 \u2514\u2500\u2500 uuid_2/\n\u251c\u2500\u2500 output_folder_2/\n\u2502 \u251c\u2500\u2500 inputs.txt\n\u2502 \u2514\u2500\u2500 uuid_1/\n\u2502 \u2514\u2500\u2500 uuid_2/\n\u2502 \u2514\u2500\u2500 uuid_3/\n</code></pre>"},{"location":"user_guide/output_format/#exact-diagonalization-outputs","title":"Exact Diagonalization Outputs","text":"<p>As can be seen from the example above, the contents of the simulation output folder depend on the simulator engine being used. Here, we describe the outputs for exact diagonalization calculations. Inside the parameter set output folder (exemplified by 'uuid_1', 'uuid_2' and 'uuid_3' in the above diagram), ED calculations will create a directory titled 'ed_output'. This folder will contain the files 'eigenvectors.csv' and 'energies.csv'. The 'eigenvectors.csv' file will contain each of the eigenvectors from the ED calculation. Each column will represent a single eigenvector: \\(|E_i\\rangle\\) for the column \\(i\\). The rows will correspond to the overlaps of these eigenvectors with the \\(S_z\\) basis: \\(c_i^j = \\langle \\{\\sigma\\}_j | E_i \\rangle\\) where \\(j\\) is the row number and \\(\\{\\sigma\\}_j\\) is the bitstring corresponding to the integer \\(j\\). </p> <p>The following tree diagram shows the output folder structure for an ED calculation with two parameter sets:  <pre><code>root_folder/\n\u2514\u2500\u2500 output_folder/\n    \u2514\u2500\u2500 inputs.txt\n    \u2514\u2500\u2500 uuid_1/\n        \u251c\u2500\u2500 J_ij_file.csv\n        \u2514\u2500\u2500 ed_output/\n            \u251c\u2500\u2500 eigenvectors.csv\n            \u251c\u2500\u2500 energies.csv\n    \u2514\u2500\u2500 uuid_2/\n        \u251c\u2500\u2500 J_ij_file.csv\n        \u2514\u2500\u2500 ed_output/\n            \u251c\u2500\u2500 eigenvectors.csv\n            \u251c\u2500\u2500 energies.csv\n</code></pre> Note that if the couplings are specified by an input file, then that file is copied to the parameter set output folder ('uuid_1' and 'uuid_2' in the above diagram), represented by 'J_ij_file.csv' in the above diagram. </p>"},{"location":"user_guide/output_format/#nearest-neighbor-quantum-monte-carlo-outputs","title":"Nearest Neighbor Quantum Monte Carlo Outputs","text":"<p>For nearest neighbor QMC, the output folder structure is very similar to ED. Following is a tree diagram showing the output structure of a nearest-neighbor QMC calculation:</p> <pre><code>root_folder/\n\u2514\u2500\u2500 output_folder/\n    \u2514\u2500\u2500 inputs.txt\n    \u2514\u2500\u2500 uuid_1/\n        \u251c\u2500\u2500 simulation_specs.txt\n        \u2514\u2500\u2500 qmc_output/\n            \u251c\u2500\u2500 estimators.csv\n            \u251c\u2500\u2500 final_spin_configurations.csv\n    \u2514\u2500\u2500 uuid_2/\n        \u251c\u2500\u2500 simulation_specs.txt\n        \u2514\u2500\u2500 qmc_output/\n            \u251c\u2500\u2500 estimators.csv\n            \u251c\u2500\u2500 final_spin_configurations.csv\n</code></pre> <p>The 'simulation_specs.txt' is a tab-delimited file generated by the simulator engine that describes the parameter set configuration being used to simulate the system. This is useful for debugging and also for quickly determining the parameter set if the uuid was generated by the preprocessor. </p> <p>The 'qmc_output' folder contains the 'estimators.csv' file and the 'final_spin_configurations.csv' file. The former stores the estimator value for each simulation steps. Currently, we support the energy and magnetization estimators for nearest-neighbor QMC. The 'final_spin_configurations.csv' file stores the value of each site in the lattice (up or down) at the final simulation step.  </p>"},{"location":"user_guide/output_format/#long-range-quantum-monte-carlo-outputs","title":"Long Range Quantum Monte Carlo Outputs","text":"<p>For long range QMC, we also need to produce probability tables required for the Monte Carlo sampling. Moreover, the long range QMC simulator calls a C++ engine. Therefore, the build files associated with the calculation are also stored in the output folder (for the sake of quantitative reproducibility which can be instrumental for debugging and benchmarking). Finally, the C++ program creates extensive logs of the calculation. These are useful for tracking long calculations as they proceed. </p> <p>The following tree diagram represents the output folder structure for long range QMC simulations:  <pre><code>root_folder/\n\u2514\u2500\u2500 output_folder/\n    \u2514\u2500\u2500 inputs.txt\n    \u2514\u2500\u2500 global.log\n    \u2514\u2500\u2500 uuid_1/\n        \u251c\u2500\u2500 parameter_set.log\n        \u251c\u2500\u2500 simulation_specs.txt\n        \u2514\u2500\u2500 probability_densities/\n            \u251c\u2500\u2500 geometry.csv\n            \u251c\u2500\u2500 max_over_states.csv\n            \u251c\u2500\u2500 vertex_weights.csv\n            \u251c\u2500\u2500 diag_probs.csv\n            \u251c\u2500\u2500 off_diag_table.csv\n        \u2514\u2500\u2500 qmc_output/\n            \u251c\u2500\u2500 estimators.csv\n            \u251c\u2500\u2500 spin_configurations.csv\n    \u2514\u2500\u2500 build/\n</code></pre></p> <p>The 'global.log' file contains the global logs generated by the C++ program as it reads the input file and validates the inputs. The 'parameter_set.log' file contains the logs corresponding to the QMC calculation associated with the specific parameter set associated with 'uuid_1'. </p> <p>The 'simulation_specs.txt' is a tab-delimited file generated by the C++ program that describes the parameter set configuration being used to simulate the system. This is useful for debugging and also for quickly determining the parameter set if the uuid was generated by the preprocessor. </p> <p>The QMC estimator outputs are saved to the 'estimators.csv' file. Currently, the supported estimators are the equilibrium energy, magnetization and spin stiffness for long range QMC. The QMC shot data for each simulation step is stored in the 'spin_configurations.csv' file. </p> <p>The probability_densities folder contains the probability tables generated by the preprocessor. These are used by the QMC calculation and the tables produced depend on the sampling type selected for the calculation. For deterministic loops, 'vertex_weights.csv', 'diag_probs.csv' and 'off_diag_table.csv' are not generated. </p>"},{"location":"user_guide/overview/","title":"Overview","text":"<p>Note</p> <p>Heisenberg Ion is still under active development so breaking changes are possible. See Features in Development for details.</p>"},{"location":"user_guide/overview/#hamiltonian","title":"Hamiltonian","text":"<p>Heisenberg Ion is a Quantum Monte Carlo (QMC) Stochastic Series Expansion (SSE) and Exact Diagonalization (ED) simulator for the anisotropic Heisenberg model with a longitudinal field, defined by the Hamiltonian:</p> \\[ H = - \\sum_{i &lt; j} J_{ij} \\left( S_x^i S_x^j + S_y^i S_y^j + \\Delta S_z^i S_z^j \\right) + h\\sum_{i} S_z^i \\label{heisenberg_z_field} \\] <p>Here, \\(S_k^i = \\frac{1}{2} \\sigma_k^i\\) is the spin-1/2 operator corresponding to site \\(i\\), for each \\(k \\in \\{x,y,z\\}\\). The Pauli matrices \\(\\sigma_k\\) are defined as follows: </p> \\[ \\sigma_x = \\begin{pmatrix} 0 &amp; 1 \\\\ 1 &amp; 0 \\end{pmatrix} \\quad \\sigma_y = \\begin{pmatrix} 0 &amp; -i \\\\ i &amp; 0 \\end{pmatrix} \\quad \\sigma_z = \\begin{pmatrix} 1 &amp; 0 \\\\ 0 &amp; -1 \\end{pmatrix} \\] <p>For QMC, if the interactions are long-range, the coupling matrix must be ferromagnetic: \\(J_{ij} &gt; 0 \\ \\forall \\ 1 \\leq i,j \\leq N\\), to avoid the sign problem. Our ED engine allows for entirely arbitrary couplings and also supports the inclusion of a transverse field term. The general ED Hamiltonian is:</p> \\[ H = - \\sum_{i &lt; j} J_{ij} \\left( S_x^i S_x^j + S_y^i S_y^j + \\Delta S_z^i S_z^j \\right) + h\\sum_{i} S_z^i - B\\sum_{i} S_x^i \\label{heisenberg_z_x_fields} \\]"},{"location":"user_guide/overview/#exact-diagonalization","title":"Exact Diagonalization","text":"<p>ED corresponds to constructing the entire \\(2^N \\times 2^N\\) (\\(N\\) is the total number of sites on the lattice) dimensional Hamiltonian matrix in the \\(S_z\\) basis, and diagonalizing it numerically. Since the Hamiltonian dimensions scale exponentially with system size, ED becomes prohibitively expensive for large \\(N\\). In fact, it is easy to show that ED exhibits exponential scaling in both time and memory. However, since it is exact and involves a relatively transparent implementation, it is instrumental for validating more complex algorithmic approaches for many-body physics. For technical details about how the Hamiltonian is constructed in Heisenberg Ion, see Algorithms. </p>"},{"location":"user_guide/overview/#quantum-monte-carlo","title":"Quantum Monte Carlo","text":"<p>QMC is a statistical approach for studying the equilibrium properties of a many-body system. For systems without frustration, such as the isotropic Heisenberg model with nearest-neighbor interactions, it is widely believed that the SSE variant of QMC scales polynomially. For technical details about the Heisenberg Ion SSE approach, see Algorithms. For a complete list of the Hamiltonians and their supported SSE algorithms in Heisenberg Ion, see Hamiltonian Types. We have two QMC engines implemented in Heisenberg Ion. The first targets long range interactions and uses a C++ backend. The other is implemented using Python and simulates isotropic variants of the Heisenberg model, as well as the XY model in the presence of nearest neighbor interactions.  </p>"},{"location":"user_guide/overview/#general-workflow","title":"General Workflow","text":"<p>The general approach for using any of the simulators in the Heisenberg Ion is the same. The workflow can be divided into the following sequential steps: </p>"},{"location":"user_guide/overview/#input-specification","title":"Input Specification","text":"<p>This includes defining the inputs and passing them to the package. These are then parsed to determine the workflow settings. Model specific validation checks are owned by the components being used by the program, typically called by the preprocessor. Details about specifying the inputs can be found in the Input Specification section. </p>"},{"location":"user_guide/overview/#preprocessing","title":"Preprocessing","text":"<p>This involves preparing the input files for the simulator specified by the user. Since the simulators can be considerably different in the inputs they require (e.g. we need to produce probability tables for QMC with long range interaction but not for nearest neighbor interactions), each simulator has its own preprocessor subclass. Details about the different preprocessors can be found in the API Reference. </p>"},{"location":"user_guide/overview/#drivers","title":"Drivers","text":"<p>Our QMC implementation uses C++ backend, and our ED calculator uses a Julia backend. The driver layer uses a command line subprocess to call these engines. For nearest-neighbor QMC, the driver simply calls the relevant implementation class in Python. As with the preprocessors, each simulator carries its own driver implemented as a subclass of the base driver class. Details can be found in the API Reference. </p>"},{"location":"user_guide/overview/#engines","title":"Engines","text":"<p>These modules contain the algorithmic simulation logic. Currently, we support three simulator engines: long-range QMC, nearest-neighbor QMC and ED. The output data files in each case are produced by the engine layer. For technical details, see the relevant sections of the Algorithms tab. Details about the output format can be found in the Output Files section. </p>"},{"location":"user_guide/overview/#postprocessing","title":"Postprocessing","text":"<p>The post processing module includes statistical utilities for the QMC outputs, and simple equilibrium property calculators for the ED data. Other utilities here include methods for computing ground state properties with linear spin wave theory, as well as a KL divergence calculator for comparing small QMC datasets. Some post-processing examples can be found in the examples folder of the repo, exhibited via Jupyter notebooks. Details can be found in the API Reference. </p>"}]}